"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-router";
exports.ids = ["vendor-chunks/react-router"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-router/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/react-router/dist/index.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.AbortedDeferredError),\n/* harmony export */   Await: () => (/* binding */ Await),\n/* harmony export */   MemoryRouter: () => (/* binding */ MemoryRouter),\n/* harmony export */   Navigate: () => (/* binding */ Navigate),\n/* harmony export */   NavigationType: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action),\n/* harmony export */   Outlet: () => (/* binding */ Outlet),\n/* harmony export */   Route: () => (/* binding */ Route),\n/* harmony export */   Router: () => (/* binding */ Router),\n/* harmony export */   RouterProvider: () => (/* binding */ RouterProvider),\n/* harmony export */   Routes: () => (/* binding */ Routes),\n/* harmony export */   UNSAFE_DataRouterContext: () => (/* binding */ DataRouterContext),\n/* harmony export */   UNSAFE_DataRouterStateContext: () => (/* binding */ DataRouterStateContext),\n/* harmony export */   UNSAFE_LocationContext: () => (/* binding */ LocationContext),\n/* harmony export */   UNSAFE_NavigationContext: () => (/* binding */ NavigationContext),\n/* harmony export */   UNSAFE_RouteContext: () => (/* binding */ RouteContext),\n/* harmony export */   UNSAFE_mapRouteProperties: () => (/* binding */ mapRouteProperties),\n/* harmony export */   UNSAFE_useRouteId: () => (/* binding */ useRouteId),\n/* harmony export */   UNSAFE_useRoutesImpl: () => (/* binding */ useRoutesImpl),\n/* harmony export */   createMemoryRouter: () => (/* binding */ createMemoryRouter),\n/* harmony export */   createPath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createPath),\n/* harmony export */   createRoutesFromChildren: () => (/* binding */ createRoutesFromChildren),\n/* harmony export */   createRoutesFromElements: () => (/* binding */ createRoutesFromChildren),\n/* harmony export */   defer: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.defer),\n/* harmony export */   generatePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.generatePath),\n/* harmony export */   isRouteErrorResponse: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse),\n/* harmony export */   json: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.json),\n/* harmony export */   matchPath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchPath),\n/* harmony export */   matchRoutes: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes),\n/* harmony export */   parsePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath),\n/* harmony export */   redirect: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.redirect),\n/* harmony export */   redirectDocument: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.redirectDocument),\n/* harmony export */   renderMatches: () => (/* binding */ renderMatches),\n/* harmony export */   resolvePath: () => (/* reexport safe */ _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolvePath),\n/* harmony export */   useActionData: () => (/* binding */ useActionData),\n/* harmony export */   useAsyncError: () => (/* binding */ useAsyncError),\n/* harmony export */   useAsyncValue: () => (/* binding */ useAsyncValue),\n/* harmony export */   useBlocker: () => (/* binding */ useBlocker),\n/* harmony export */   useHref: () => (/* binding */ useHref),\n/* harmony export */   useInRouterContext: () => (/* binding */ useInRouterContext),\n/* harmony export */   useLoaderData: () => (/* binding */ useLoaderData),\n/* harmony export */   useLocation: () => (/* binding */ useLocation),\n/* harmony export */   useMatch: () => (/* binding */ useMatch),\n/* harmony export */   useMatches: () => (/* binding */ useMatches),\n/* harmony export */   useNavigate: () => (/* binding */ useNavigate),\n/* harmony export */   useNavigation: () => (/* binding */ useNavigation),\n/* harmony export */   useNavigationType: () => (/* binding */ useNavigationType),\n/* harmony export */   useOutlet: () => (/* binding */ useOutlet),\n/* harmony export */   useOutletContext: () => (/* binding */ useOutletContext),\n/* harmony export */   useParams: () => (/* binding */ useParams),\n/* harmony export */   useResolvedPath: () => (/* binding */ useResolvedPath),\n/* harmony export */   useRevalidator: () => (/* binding */ useRevalidator),\n/* harmony export */   useRouteError: () => (/* binding */ useRouteError),\n/* harmony export */   useRouteLoaderData: () => (/* binding */ useRouteLoaderData),\n/* harmony export */   useRoutes: () => (/* binding */ useRoutes)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _remix_run_router__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @remix-run/router */ \"(ssr)/./node_modules/@remix-run/router/dist/router.js\");\n/**\n * React Router v6.20.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \n\n\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n// Create react-specific types from the agnostic types in @remix-run/router to\n// export from react-router\nconst DataRouterContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    DataRouterContext.displayName = \"DataRouter\";\n}\nconst DataRouterStateContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    DataRouterStateContext.displayName = \"DataRouterState\";\n}\nconst AwaitContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    AwaitContext.displayName = \"Await\";\n}\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level `<Router>` API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */ const NavigationContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    NavigationContext.displayName = \"Navigation\";\n}\nconst LocationContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    LocationContext.displayName = \"Location\";\n}\nconst RouteContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    outlet: null,\n    matches: [],\n    isDataRoute: false\n});\nif (true) {\n    RouteContext.displayName = \"Route\";\n}\nconst RouteErrorContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nif (true) {\n    RouteErrorContext.displayName = \"RouteError\";\n}\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/hooks/use-href\n */ function useHref(to, _temp) {\n    let { relative } = _temp === void 0 ? {} : _temp;\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useHref() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let { basename, navigator } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n    let { hash, pathname, search } = useResolvedPath(to, {\n        relative\n    });\n    let joinedPathname = pathname;\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to creating the href.  If this is a root navigation, then just use the raw\n    // basename which allows the basename to have full control over the presence\n    // of a trailing slash on root links\n    if (basename !== \"/\") {\n        joinedPathname = pathname === \"/\" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n            basename,\n            pathname\n        ]);\n    }\n    return navigator.createHref({\n        pathname: joinedPathname,\n        search,\n        hash\n    });\n}\n/**\n * Returns true if this component is a descendant of a `<Router>`.\n *\n * @see https://reactrouter.com/hooks/use-in-router-context\n */ function useInRouterContext() {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext) != null;\n}\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/hooks/use-location\n */ function useLocation() {\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useLocation() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).location;\n}\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/hooks/use-navigation-type\n */ function useNavigationType() {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(LocationContext).navigationType;\n}\n/**\n * Returns a PathMatch object if the given pattern matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * `<NavLink>`.\n *\n * @see https://reactrouter.com/hooks/use-match\n */ function useMatch(pattern) {\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useMatch() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let { pathname } = useLocation();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>(0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchPath)(pattern, pathname), [\n        pathname,\n        pattern\n    ]);\n}\n/**\n * The interface for the navigate() function returned from useNavigate().\n */ const navigateEffectWarning = \"You should call navigate() in a React.useEffect(), not when \" + \"your component is first rendered.\";\n// Mute warnings for calls to useNavigate in SSR environments\nfunction useIsomorphicLayoutEffect(cb) {\n    let isStatic = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext).static;\n    if (!isStatic) {\n        // We should be able to get rid of this once react 18.3 is released\n        // See: https://github.com/facebook/react/pull/26395\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(cb);\n    }\n}\n/**\n * Returns an imperative method for changing the location. Used by `<Link>`s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/hooks/use-navigate\n */ function useNavigate() {\n    let { isDataRoute } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    // Conditional usage is OK here because the usage of a data router is static\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\nfunction useNavigateUnstable() {\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useNavigate() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n    let { basename, navigator } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n    let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getPathContributingMatches)(matches).map((match)=>match.pathnameBase));\n    let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    useIsomorphicLayoutEffect(()=>{\n        activeRef.current = true;\n    });\n    let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(to, options) {\n        if (options === void 0) {\n            options = {};\n        }\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(activeRef.current, navigateEffectWarning) : 0;\n        // Short circuit here since if this happens on first render the navigate\n        // is useless because we haven't wired up our history listener yet\n        if (!activeRef.current) return;\n        if (typeof to === \"number\") {\n            navigator.go(to);\n            return;\n        }\n        let path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\");\n        // If we're operating within a basename, prepend it to the pathname prior\n        // to handing off to history (but only if we're not in a data router,\n        // otherwise it'll prepend the basename inside of the router).\n        // If this is a root navigation, then we navigate to the raw basename\n        // which allows the basename to have full control over the presence of a\n        // trailing slash on root links\n        if (dataRouterContext == null && basename !== \"/\") {\n            path.pathname = path.pathname === \"/\" ? basename : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n                basename,\n                path.pathname\n            ]);\n        }\n        (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n    }, [\n        basename,\n        navigator,\n        routePathnamesJson,\n        locationPathname,\n        dataRouterContext\n    ]);\n    return navigate;\n}\nconst OutletContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/hooks/use-outlet-context\n */ function useOutletContext() {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(OutletContext);\n}\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by `<Outlet>` to render child routes.\n *\n * @see https://reactrouter.com/hooks/use-outlet\n */ function useOutlet(context) {\n    let outlet = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext).outlet;\n    if (outlet) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(OutletContext.Provider, {\n            value: context\n        }, outlet);\n    }\n    return outlet;\n}\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/hooks/use-params\n */ function useParams() {\n    let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let routeMatch = matches[matches.length - 1];\n    return routeMatch ? routeMatch.params : {};\n}\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/hooks/use-resolved-path\n */ function useResolvedPath(to, _temp2) {\n    let { relative } = _temp2 === void 0 ? {} : _temp2;\n    let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let routePathnamesJson = JSON.stringify((0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getPathContributingMatches)(matches).map((match)=>match.pathnameBase));\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>(0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [\n        to,\n        routePathnamesJson,\n        locationPathname,\n        relative\n    ]);\n}\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an `<Outlet>` to render their child route's\n * element.\n *\n * @see https://reactrouter.com/hooks/use-routes\n */ function useRoutes(routes, locationArg) {\n    return useRoutesImpl(routes, locationArg);\n}\n// Internal implementation with accept optional param for RouterProvider usage\nfunction useRoutesImpl(routes, locationArg, dataRouterState) {\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // router loaded. We can help them understand how to avoid that.\n    \"useRoutes() may be used only in the context of a <Router> component.\") : 0 : void 0;\n    let { navigator } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext);\n    let { matches: parentMatches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let routeMatch = parentMatches[parentMatches.length - 1];\n    let parentParams = routeMatch ? routeMatch.params : {};\n    let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n    let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n    let parentRoute = routeMatch && routeMatch.route;\n    if (true) {\n        // You won't get a warning about 2 different <Routes> under a <Route>\n        // without a trailing *, but this is a best-effort warning anyway since we\n        // cannot even give the warning unless they land at the parent route.\n        //\n        // Example:\n        //\n        // <Routes>\n        //   {/* This route path MUST end with /* because otherwise\n        //       it will never match /blog/post/123 */}\n        //   <Route path=\"blog\" element={<Blog />} />\n        //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n        // </Routes>\n        //\n        // function Blog() {\n        //   return (\n        //     <Routes>\n        //       <Route path=\"post/:id\" element={<Post />} />\n        //     </Routes>\n        //   );\n        // }\n        let parentPath = parentRoute && parentRoute.path || \"\";\n        warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + ('\"' + parentPathname + '\" (under <Route path=\"' + parentPath + '\">) but the ') + 'parent route path has no trailing \"*\". This means if you navigate ' + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + ('Please change the parent <Route path=\"' + parentPath + '\"> to <Route ') + ('path=\"' + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + '\">.'));\n    }\n    let locationFromContext = useLocation();\n    let location;\n    if (locationArg) {\n        var _parsedLocationArg$pa;\n        let parsedLocationArg = typeof locationArg === \"string\" ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath)(locationArg) : locationArg;\n        !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \" + \"the location pathname must begin with the portion of the URL pathname that was \" + ('matched by all parent routes. The current pathname base is \"' + parentPathnameBase + '\" ') + ('but pathname \"' + parsedLocationArg.pathname + '\" was given in the `location` prop.')) : 0 : void 0;\n        location = parsedLocationArg;\n    } else {\n        location = locationFromContext;\n    }\n    let pathname = location.pathname || \"/\";\n    let remainingPathname = parentPathnameBase === \"/\" ? pathname : pathname.slice(parentPathnameBase.length) || \"/\";\n    let matches = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.matchRoutes)(routes, {\n        pathname: remainingPathname\n    });\n    if (true) {\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(parentRoute || matches != null, 'No routes matched location \"' + location.pathname + location.search + location.hash + '\" ') : 0;\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(matches == null || matches[matches.length - 1].route.element !== undefined || matches[matches.length - 1].route.Component !== undefined, 'Matched leaf route at location \"' + location.pathname + location.search + location.hash + '\" ' + \"does not have an element or Component. This means it will render an <Outlet /> with a \" + 'null value by default resulting in an \"empty\" page.') : 0;\n    }\n    let renderedMatches = _renderMatches(matches && matches.map((match)=>Object.assign({}, match, {\n            params: Object.assign({}, parentParams, match.params),\n            pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n                parentPathnameBase,\n                // Re-encode pathnames that were decoded inside matchRoutes\n                navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname\n            ]),\n            pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.joinPaths)([\n                parentPathnameBase,\n                // Re-encode pathnames that were decoded inside matchRoutes\n                navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase\n            ])\n        })), parentMatches, dataRouterState);\n    // When a user passes in a `locationArg`, the associated routes need to\n    // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n    // to use the scoped location instead of the global location.\n    if (locationArg && renderedMatches) {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, {\n            value: {\n                location: _extends({\n                    pathname: \"/\",\n                    search: \"\",\n                    hash: \"\",\n                    state: null,\n                    key: \"default\"\n                }, location),\n                navigationType: _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action.Pop\n            }\n        }, renderedMatches);\n    }\n    return renderedMatches;\n}\nfunction DefaultErrorComponent() {\n    let error = useRouteError();\n    let message = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.isRouteErrorResponse)(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\n    let stack = error instanceof Error ? error.stack : null;\n    let lightgrey = \"rgba(200,200,200, 0.5)\";\n    let preStyles = {\n        padding: \"0.5rem\",\n        backgroundColor: lightgrey\n    };\n    let codeStyles = {\n        padding: \"2px 4px\",\n        backgroundColor: lightgrey\n    };\n    let devInfo = null;\n    if (true) {\n        console.error(\"Error handled by React Router default ErrorBoundary:\", error);\n        devInfo = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", {\n            style: codeStyles\n        }, \"ErrorBoundary\"), \" or\", \" \", /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"code\", {\n            style: codeStyles\n        }, \"errorElement\"), \" prop on your route.\"));\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h2\", null, \"Unexpected Application Error!\"), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h3\", {\n        style: {\n            fontStyle: \"italic\"\n        }\n    }, message), stack ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"pre\", {\n        style: preStyles\n    }, stack) : null, devInfo);\n}\nconst defaultErrorElement = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DefaultErrorComponent, null);\nclass RenderErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            location: props.location,\n            revalidation: props.revalidation,\n            error: props.error\n        };\n    }\n    static getDerivedStateFromError(error) {\n        return {\n            error: error\n        };\n    }\n    static getDerivedStateFromProps(props, state) {\n        // When we get into an error state, the user will likely click \"back\" to the\n        // previous page that didn't have an error. Because this wraps the entire\n        // application, that will have no effect--the error page continues to display.\n        // This gives us a mechanism to recover from the error when the location changes.\n        //\n        // Whether we're in an error state or not, we update the location in state\n        // so that when we are in an error state, it gets reset when a new location\n        // comes in and the user recovers from the error.\n        if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n            return {\n                error: props.error,\n                location: props.location,\n                revalidation: props.revalidation\n            };\n        }\n        // If we're not changing locations, preserve the location but still surface\n        // any new errors that may come through. We retain the existing error, we do\n        // this because the error provided from the app state may be cleared without\n        // the location changing.\n        return {\n            error: props.error || state.error,\n            location: state.location,\n            revalidation: props.revalidation || state.revalidation\n        };\n    }\n    componentDidCatch(error, errorInfo) {\n        console.error(\"React Router caught the following error during render\", error, errorInfo);\n    }\n    render() {\n        return this.state.error ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, {\n            value: this.props.routeContext\n        }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteErrorContext.Provider, {\n            value: this.state.error,\n            children: this.props.component\n        })) : this.props.children;\n    }\n}\nfunction RenderedRoute(_ref) {\n    let { routeContext, match, children } = _ref;\n    let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n    // Track how deep we got in our render pass to emulate SSR componentDidCatch\n    // in a DataStaticRouter\n    if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n        dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RouteContext.Provider, {\n        value: routeContext\n    }, children);\n}\nfunction _renderMatches(matches, parentMatches, dataRouterState) {\n    var _dataRouterState2;\n    if (parentMatches === void 0) {\n        parentMatches = [];\n    }\n    if (dataRouterState === void 0) {\n        dataRouterState = null;\n    }\n    if (matches == null) {\n        var _dataRouterState;\n        if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {\n            // Don't bail if we have data router errors so we can render them in the\n            // boundary.  Use the pre-matched (or shimmed) matches\n            matches = dataRouterState.matches;\n        } else {\n            return null;\n        }\n    }\n    let renderedMatches = matches;\n    // If we have data errors, trim matches to the highest error boundary\n    let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;\n    if (errors != null) {\n        let errorIndex = renderedMatches.findIndex((m)=>m.route.id && (errors == null ? void 0 : errors[m.route.id]));\n        !(errorIndex >= 0) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"Could not find a matching route for errors on route IDs: \" + Object.keys(errors).join(\",\")) : 0 : void 0;\n        renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n    }\n    return renderedMatches.reduceRight((outlet, match, index)=>{\n        let error = match.route.id ? errors == null ? void 0 : errors[match.route.id] : null;\n        // Only data routers handle errors\n        let errorElement = null;\n        if (dataRouterState) {\n            errorElement = match.route.errorElement || defaultErrorElement;\n        }\n        let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));\n        let getChildren = ()=>{\n            let children;\n            if (error) {\n                children = errorElement;\n            } else if (match.route.Component) {\n                // Note: This is a de-optimized path since React won't re-use the\n                // ReactElement since it's identity changes with each new\n                // React.createElement call.  We keep this so folks can use\n                // `<Route Component={...}>` in `<Routes>` but generally `Component`\n                // usage is only advised in `RouterProvider` when we can convert it to\n                // `element` ahead of time.\n                children = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(match.route.Component, null);\n            } else if (match.route.element) {\n                children = match.route.element;\n            } else {\n                children = outlet;\n            }\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderedRoute, {\n                match: match,\n                routeContext: {\n                    outlet,\n                    matches,\n                    isDataRoute: dataRouterState != null\n                },\n                children: children\n            });\n        };\n        // Only wrap in an error boundary within data router usages when we have an\n        // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to\n        // an ancestor ErrorBoundary/errorElement\n        return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderErrorBoundary, {\n            location: dataRouterState.location,\n            revalidation: dataRouterState.revalidation,\n            component: errorElement,\n            error: error,\n            children: getChildren(),\n            routeContext: {\n                outlet: null,\n                matches,\n                isDataRoute: true\n            }\n        }) : getChildren();\n    }, null);\n}\nvar DataRouterHook = /*#__PURE__*/ function(DataRouterHook) {\n    DataRouterHook[\"UseBlocker\"] = \"useBlocker\";\n    DataRouterHook[\"UseRevalidator\"] = \"useRevalidator\";\n    DataRouterHook[\"UseNavigateStable\"] = \"useNavigate\";\n    return DataRouterHook;\n}(DataRouterHook || {});\nvar DataRouterStateHook = /*#__PURE__*/ function(DataRouterStateHook) {\n    DataRouterStateHook[\"UseBlocker\"] = \"useBlocker\";\n    DataRouterStateHook[\"UseLoaderData\"] = \"useLoaderData\";\n    DataRouterStateHook[\"UseActionData\"] = \"useActionData\";\n    DataRouterStateHook[\"UseRouteError\"] = \"useRouteError\";\n    DataRouterStateHook[\"UseNavigation\"] = \"useNavigation\";\n    DataRouterStateHook[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\n    DataRouterStateHook[\"UseMatches\"] = \"useMatches\";\n    DataRouterStateHook[\"UseRevalidator\"] = \"useRevalidator\";\n    DataRouterStateHook[\"UseNavigateStable\"] = \"useNavigate\";\n    DataRouterStateHook[\"UseRouteId\"] = \"useRouteId\";\n    return DataRouterStateHook;\n}(DataRouterStateHook || {});\nfunction getDataRouterConsoleError(hookName) {\n    return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n    let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterContext);\n    !ctx ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return ctx;\n}\nfunction useDataRouterState(hookName) {\n    let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(DataRouterStateContext);\n    !state ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return state;\n}\nfunction useRouteContext(hookName) {\n    let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    !route ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return route;\n}\n// Internal version with hookName-aware debugging\nfunction useCurrentRouteId(hookName) {\n    let route = useRouteContext(hookName);\n    let thisRoute = route.matches[route.matches.length - 1];\n    !thisRoute.route.id ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, hookName + ' can only be used on routes that contain a unique \"id\"') : 0 : void 0;\n    return thisRoute.route.id;\n}\n/**\n * Returns the ID for the nearest contextual route\n */ function useRouteId() {\n    return useCurrentRouteId(DataRouterStateHook.UseRouteId);\n}\n/**\n * Returns the current navigation, defaulting to an \"idle\" navigation when\n * no navigation is in progress\n */ function useNavigation() {\n    let state = useDataRouterState(DataRouterStateHook.UseNavigation);\n    return state.navigation;\n}\n/**\n * Returns a revalidate function for manually triggering revalidation, as well\n * as the current state of any manual revalidations\n */ function useRevalidator() {\n    let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n    let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            revalidate: dataRouterContext.router.revalidate,\n            state: state.revalidation\n        }), [\n        dataRouterContext.router.revalidate,\n        state.revalidation\n    ]);\n}\n/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n */ function useMatches() {\n    let { matches, loaderData } = useDataRouterState(DataRouterStateHook.UseMatches);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>matches.map((m)=>(0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_convertRouteMatchToUiMatch)(m, loaderData)), [\n        matches,\n        loaderData\n    ]);\n}\n/**\n * Returns the loader data for the nearest ancestor Route loader\n */ function useLoaderData() {\n    let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n    if (state.errors && state.errors[routeId] != null) {\n        console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \" + routeId + \")\");\n        return undefined;\n    }\n    return state.loaderData[routeId];\n}\n/**\n * Returns the loaderData for the given routeId\n */ function useRouteLoaderData(routeId) {\n    let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n    return state.loaderData[routeId];\n}\n/**\n * Returns the action data for the nearest ancestor Route action\n */ function useActionData() {\n    let state = useDataRouterState(DataRouterStateHook.UseActionData);\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n    return state.actionData ? state.actionData[routeId] : undefined;\n}\n/**\n * Returns the nearest ancestor Route error, which could be a loader/action\n * error or a render error.  This is intended to be called from your\n * ErrorBoundary/errorElement to display a proper error message.\n */ function useRouteError() {\n    var _state$errors;\n    let error = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteErrorContext);\n    let state = useDataRouterState(DataRouterStateHook.UseRouteError);\n    let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\n    // If this was a render error, we put it in a RouteError context inside\n    // of RenderErrorBoundary\n    if (error) {\n        return error;\n    }\n    // Otherwise look for errors from our data router state\n    return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\n}\n/**\n * Returns the happy-path data from the nearest ancestor `<Await />` value\n */ function useAsyncValue() {\n    let value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);\n    return value == null ? void 0 : value._data;\n}\n/**\n * Returns the error from the nearest ancestor `<Await />` value\n */ function useAsyncError() {\n    let value = react__WEBPACK_IMPORTED_MODULE_0__.useContext(AwaitContext);\n    return value == null ? void 0 : value._error;\n}\nlet blockerId = 0;\n/**\n * Allow the application to block navigations within the SPA and present the\n * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\n * using half-filled form data.  This does not handle hard-reloads or\n * cross-origin navigations.\n */ function useBlocker(shouldBlock) {\n    let { router, basename } = useDataRouterContext(DataRouterHook.UseBlocker);\n    let state = useDataRouterState(DataRouterStateHook.UseBlocker);\n    let [blockerKey, setBlockerKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(\"\");\n    let blockerFunction = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((arg)=>{\n        if (typeof shouldBlock !== \"function\") {\n            return !!shouldBlock;\n        }\n        if (basename === \"/\") {\n            return shouldBlock(arg);\n        }\n        // If they provided us a function and we've got an active basename, strip\n        // it from the locations we expose to the user to match the behavior of\n        // useLocation\n        let { currentLocation, nextLocation, historyAction } = arg;\n        return shouldBlock({\n            currentLocation: _extends({}, currentLocation, {\n                pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(currentLocation.pathname, basename) || currentLocation.pathname\n            }),\n            nextLocation: _extends({}, nextLocation, {\n                pathname: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(nextLocation.pathname, basename) || nextLocation.pathname\n            }),\n            historyAction\n        });\n    }, [\n        basename,\n        shouldBlock\n    ]);\n    // This effect is in charge of blocker key assignment and deletion (which is\n    // tightly coupled to the key)\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        let key = String(++blockerId);\n        setBlockerKey(key);\n        return ()=>router.deleteBlocker(key);\n    }, [\n        router\n    ]);\n    // This effect handles assigning the blockerFunction.  This is to handle\n    // unstable blocker function identities, and happens only after the prior\n    // effect so we don't get an orphaned blockerFunction in the router with a\n    // key of \"\".  Until then we just have the IDLE_BLOCKER.\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (blockerKey !== \"\") {\n            router.getBlocker(blockerKey, blockerFunction);\n        }\n    }, [\n        router,\n        blockerKey,\n        blockerFunction\n    ]);\n    // Prefer the blocker from `state` not `router.state` since DataRouterContext\n    // is memoized so this ensures we update on blocker state updates\n    return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.IDLE_BLOCKER;\n}\n/**\n * Stable version of useNavigate that is used when we are in the context of\n * a RouterProvider.\n */ function useNavigateStable() {\n    let { router } = useDataRouterContext(DataRouterHook.UseNavigateStable);\n    let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\n    let activeRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    useIsomorphicLayoutEffect(()=>{\n        activeRef.current = true;\n    });\n    let navigate = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(to, options) {\n        if (options === void 0) {\n            options = {};\n        }\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(activeRef.current, navigateEffectWarning) : 0;\n        // Short circuit here since if this happens on first render the navigate\n        // is useless because we haven't wired up our router subscriber yet\n        if (!activeRef.current) return;\n        if (typeof to === \"number\") {\n            router.navigate(to);\n        } else {\n            router.navigate(to, _extends({\n                fromRouteId: id\n            }, options));\n        }\n    }, [\n        router,\n        id\n    ]);\n    return navigate;\n}\nconst alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n    if (!cond && !alreadyWarned[key]) {\n        alreadyWarned[key] = true;\n         true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, message) : 0;\n    }\n}\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/ const START_TRANSITION = \"startTransition\";\nconst startTransitionImpl = react__WEBPACK_IMPORTED_MODULE_0__[START_TRANSITION];\n/**\n * Given a Remix Router instance, render the appropriate UI\n */ function RouterProvider(_ref) {\n    let { fallbackElement, router, future } = _ref;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state);\n    let { v7_startTransition } = future || {};\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState)=>{\n        if (v7_startTransition && startTransitionImpl) {\n            startTransitionImpl(()=>setStateImpl(newState));\n        } else {\n            setStateImpl(newState);\n        }\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    // Need to use a layout effect here so we are subscribed early enough to\n    // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>router.subscribe(setState), [\n        router,\n        setState\n    ]);\n    let navigator = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        return {\n            createHref: router.createHref,\n            encodeLocation: router.encodeLocation,\n            go: (n)=>router.navigate(n),\n            push: (to, state, opts)=>router.navigate(to, {\n                    state,\n                    preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n                }),\n            replace: (to, state, opts)=>router.navigate(to, {\n                    replace: true,\n                    state,\n                    preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n                })\n        };\n    }, [\n        router\n    ]);\n    let basename = router.basename || \"/\";\n    let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            router,\n            navigator,\n            static: false,\n            basename\n        }), [\n        router,\n        navigator,\n        basename\n    ]);\n    // The fragment and {null} here are important!  We need them to keep React 18's\n    // useId happy when we are server-rendering since we may have a <script> here\n    // containing the hydrated server-side staticContext (from StaticRouterProvider).\n    // useId relies on the component tree structure to generate deterministic id's\n    // so we need to ensure it remains the same on the client even though\n    // we don't need the <script> tag\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterContext.Provider, {\n        value: dataRouterContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRouterStateContext.Provider, {\n        value: state\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {\n        basename: basename,\n        location: state.location,\n        navigationType: state.historyAction,\n        navigator: navigator\n    }, state.initialized ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRoutes, {\n        routes: router.routes,\n        state: state\n    }) : fallbackElement))), null);\n}\nfunction DataRoutes(_ref2) {\n    let { routes, state } = _ref2;\n    return useRoutesImpl(routes, undefined, state);\n}\n/**\n * A `<Router>` that stores all entries in memory.\n *\n * @see https://reactrouter.com/router-components/memory-router\n */ function MemoryRouter(_ref3) {\n    let { basename, children, initialEntries, initialIndex, future } = _ref3;\n    let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createMemoryHistory)({\n            initialEntries,\n            initialIndex,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    let { v7_startTransition } = future || {};\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState)=>{\n        v7_startTransition && startTransitionImpl ? startTransitionImpl(()=>setStateImpl(newState)) : setStateImpl(newState);\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/components/navigate\n */ function Navigate(_ref4) {\n    let { to, replace, state, relative } = _ref4;\n    !useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, // the router loaded. We can help them understand how to avoid that.\n    \"<Navigate> may be used only in the context of a <Router> component.\") : 0 : void 0;\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(!react__WEBPACK_IMPORTED_MODULE_0__.useContext(NavigationContext).static, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : 0;\n    let { matches } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RouteContext);\n    let { pathname: locationPathname } = useLocation();\n    let navigate = useNavigate();\n    // Resolve the path outside of the effect so that when effects run twice in\n    // StrictMode they navigate to the same place\n    let path = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.resolveTo)(to, (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_getPathContributingMatches)(matches).map((match)=>match.pathnameBase), locationPathname, relative === \"path\");\n    let jsonPath = JSON.stringify(path);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>navigate(JSON.parse(jsonPath), {\n            replace,\n            state,\n            relative\n        }), [\n        navigate,\n        jsonPath,\n        relative,\n        replace,\n        state\n    ]);\n    return null;\n}\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/components/outlet\n */ function Outlet(props) {\n    return useOutlet(props.context);\n}\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/components/route\n */ function Route(_props) {\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\") : 0;\n}\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a `<Router>` directly. Instead, you'll render a\n * router that is more specific to your environment such as a `<BrowserRouter>`\n * in web browsers or a `<StaticRouter>` for server rendering.\n *\n * @see https://reactrouter.com/router-components/router\n */ function Router(_ref5) {\n    let { basename: basenameProp = \"/\", children = null, location: locationProp, navigationType = _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.Action.Pop, navigator, static: staticProp = false } = _ref5;\n    !!useInRouterContext() ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"You cannot render a <Router> inside another <Router>.\" + \" You should never have more than one in your app.\") : 0 : void 0;\n    // Preserve trailing slashes on basename, so we can let the user control\n    // the enforcement of trailing slashes throughout the app\n    let basename = basenameProp.replace(/^\\/*/, \"/\");\n    let navigationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            basename,\n            navigator,\n            static: staticProp\n        }), [\n        basename,\n        navigator,\n        staticProp\n    ]);\n    if (typeof locationProp === \"string\") {\n        locationProp = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.parsePath)(locationProp);\n    }\n    let { pathname = \"/\", search = \"\", hash = \"\", state = null, key = \"default\" } = locationProp;\n    let locationContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        let trailingPathname = (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(pathname, basename);\n        if (trailingPathname == null) {\n            return null;\n        }\n        return {\n            location: {\n                pathname: trailingPathname,\n                search,\n                hash,\n                state,\n                key\n            },\n            navigationType\n        };\n    }, [\n        basename,\n        pathname,\n        search,\n        hash,\n        state,\n        key,\n        navigationType\n    ]);\n     true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(locationContext != null, '<Router basename=\"' + basename + '\"> is not able to match the URL ' + ('\"' + pathname + search + hash + '\" because it does not start with the ') + \"basename, so the <Router> won't render anything.\") : 0;\n    if (locationContext == null) {\n        return null;\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(NavigationContext.Provider, {\n        value: navigationContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(LocationContext.Provider, {\n        children: children,\n        value: locationContext\n    }));\n}\n/**\n * A container for a nested tree of `<Route>` elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/components/routes\n */ function Routes(_ref6) {\n    let { children, location } = _ref6;\n    return useRoutes(createRoutesFromChildren(children), location);\n}\n/**\n * Component to use for rendering lazily loaded data from returning defer()\n * in a loader function\n */ function Await(_ref7) {\n    let { children, errorElement, resolve } = _ref7;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitErrorBoundary, {\n        resolve: resolve,\n        errorElement: errorElement\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ResolveAwait, null, children));\n}\nvar AwaitRenderStatus = /*#__PURE__*/ function(AwaitRenderStatus) {\n    AwaitRenderStatus[AwaitRenderStatus[\"pending\"] = 0] = \"pending\";\n    AwaitRenderStatus[AwaitRenderStatus[\"success\"] = 1] = \"success\";\n    AwaitRenderStatus[AwaitRenderStatus[\"error\"] = 2] = \"error\";\n    return AwaitRenderStatus;\n}(AwaitRenderStatus || {});\nconst neverSettledPromise = new Promise(()=>{});\nclass AwaitErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props){\n        super(props);\n        this.state = {\n            error: null\n        };\n    }\n    static getDerivedStateFromError(error) {\n        return {\n            error\n        };\n    }\n    componentDidCatch(error, errorInfo) {\n        console.error(\"<Await> caught the following error during render\", error, errorInfo);\n    }\n    render() {\n        let { children, errorElement, resolve } = this.props;\n        let promise = null;\n        let status = AwaitRenderStatus.pending;\n        if (!(resolve instanceof Promise)) {\n            // Didn't get a promise - provide as a resolved promise\n            status = AwaitRenderStatus.success;\n            promise = Promise.resolve();\n            Object.defineProperty(promise, \"_tracked\", {\n                get: ()=>true\n            });\n            Object.defineProperty(promise, \"_data\", {\n                get: ()=>resolve\n            });\n        } else if (this.state.error) {\n            // Caught a render error, provide it as a rejected promise\n            status = AwaitRenderStatus.error;\n            let renderError = this.state.error;\n            promise = Promise.reject().catch(()=>{}); // Avoid unhandled rejection warnings\n            Object.defineProperty(promise, \"_tracked\", {\n                get: ()=>true\n            });\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>renderError\n            });\n        } else if (resolve._tracked) {\n            // Already tracked promise - check contents\n            promise = resolve;\n            status = promise._error !== undefined ? AwaitRenderStatus.error : promise._data !== undefined ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\n        } else {\n            // Raw (untracked) promise - track it\n            status = AwaitRenderStatus.pending;\n            Object.defineProperty(resolve, \"_tracked\", {\n                get: ()=>true\n            });\n            promise = resolve.then((data)=>Object.defineProperty(resolve, \"_data\", {\n                    get: ()=>data\n                }), (error)=>Object.defineProperty(resolve, \"_error\", {\n                    get: ()=>error\n                }));\n        }\n        if (status === AwaitRenderStatus.error && promise._error instanceof _remix_run_router__WEBPACK_IMPORTED_MODULE_1__.AbortedDeferredError) {\n            // Freeze the UI by throwing a never resolved promise\n            throw neverSettledPromise;\n        }\n        if (status === AwaitRenderStatus.error && !errorElement) {\n            // No errorElement, throw to the nearest route-level error boundary\n            throw promise._error;\n        }\n        if (status === AwaitRenderStatus.error) {\n            // Render via our errorElement\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, {\n                value: promise,\n                children: errorElement\n            });\n        }\n        if (status === AwaitRenderStatus.success) {\n            // Render children with resolved value\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(AwaitContext.Provider, {\n                value: promise,\n                children: children\n            });\n        }\n        // Throw to the suspense boundary\n        throw promise;\n    }\n}\n/**\n * @private\n * Indirection to leverage useAsyncValue for a render-prop API on `<Await>`\n */ function ResolveAwait(_ref8) {\n    let { children } = _ref8;\n    let data = useAsyncValue();\n    let toRender = typeof children === \"function\" ? children(data) : children;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, toRender);\n}\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/utils/create-routes-from-children\n */ function createRoutesFromChildren(children, parentPath) {\n    if (parentPath === void 0) {\n        parentPath = [];\n    }\n    let routes = [];\n    react__WEBPACK_IMPORTED_MODULE_0__.Children.forEach(children, (element, index)=>{\n        if (!/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.isValidElement(element)) {\n            // Ignore non-elements. This allows people to more easily inline\n            // conditionals in their route config.\n            return;\n        }\n        let treePath = [\n            ...parentPath,\n            index\n        ];\n        if (element.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {\n            // Transparently support React.Fragment and its children.\n            routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\n            return;\n        }\n        !(element.type === Route) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\") : 0 : void 0;\n        !(!element.props.index || !element.props.children) ?  true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_invariant)(false, \"An index route cannot have child routes.\") : 0 : void 0;\n        let route = {\n            id: element.props.id || treePath.join(\"-\"),\n            caseSensitive: element.props.caseSensitive,\n            element: element.props.element,\n            Component: element.props.Component,\n            index: element.props.index,\n            path: element.props.path,\n            loader: element.props.loader,\n            action: element.props.action,\n            errorElement: element.props.errorElement,\n            ErrorBoundary: element.props.ErrorBoundary,\n            hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\n            shouldRevalidate: element.props.shouldRevalidate,\n            handle: element.props.handle,\n            lazy: element.props.lazy\n        };\n        if (element.props.children) {\n            route.children = createRoutesFromChildren(element.props.children, treePath);\n        }\n        routes.push(route);\n    });\n    return routes;\n}\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */ function renderMatches(matches) {\n    return _renderMatches(matches);\n}\nfunction mapRouteProperties(route) {\n    let updates = {\n        // Note: this check also occurs in createRoutesFromChildren so update\n        // there if you change this -- please and thank you!\n        hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\n    };\n    if (route.Component) {\n        if (true) {\n            if (route.element) {\n                 true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, \"You should not include both `Component` and `element` on your route - \" + \"`Component` will be used.\") : 0;\n            }\n        }\n        Object.assign(updates, {\n            element: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.Component),\n            Component: undefined\n        });\n    }\n    if (route.ErrorBoundary) {\n        if (true) {\n            if (route.errorElement) {\n                 true ? (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.UNSAFE_warning)(false, \"You should not include both `ErrorBoundary` and `errorElement` on your route - \" + \"`ErrorBoundary` will be used.\") : 0;\n            }\n        }\n        Object.assign(updates, {\n            errorElement: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(route.ErrorBoundary),\n            ErrorBoundary: undefined\n        });\n    }\n    return updates;\n}\nfunction createMemoryRouter(routes, opts) {\n    return (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: _extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0,_remix_run_router__WEBPACK_IMPORTED_MODULE_1__.createMemoryHistory)({\n            initialEntries: opts == null ? void 0 : opts.initialEntries,\n            initialIndex: opts == null ? void 0 : opts.initialIndex\n        }),\n        hydrationData: opts == null ? void 0 : opts.hydrationData,\n        routes,\n        mapRouteProperties\n    }).initialize();\n}\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztDQVNDLEdBQzhCO0FBQ3lSO0FBQzVGO0FBRTVOLFNBQVN5QjtJQUNQQSxXQUFXQyxPQUFPQyxNQUFNLEdBQUdELE9BQU9DLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFDaEUsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUN6QyxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFDekIsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUN0QixJQUFJUCxPQUFPUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixRQUFRQyxNQUFNO29CQUNyREwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtnQkFDM0I7WUFDRjtRQUNGO1FBQ0EsT0FBT0w7SUFDVDtJQUNBLE9BQU9KLFNBQVNhLEtBQUssQ0FBQyxJQUFJLEVBQUVQO0FBQzlCO0FBRUEsOEVBQThFO0FBQzlFLDJCQUEyQjtBQUMzQixNQUFNUSxvQkFBb0IsV0FBVyxHQUFFdkMsZ0RBQW1CLENBQUM7QUFDM0QsSUFBSXlDLElBQXFDLEVBQUU7SUFDekNGLGtCQUFrQkcsV0FBVyxHQUFHO0FBQ2xDO0FBQ0EsTUFBTUMseUJBQXlCLFdBQVcsR0FBRTNDLGdEQUFtQixDQUFDO0FBQ2hFLElBQUl5QyxJQUFxQyxFQUFFO0lBQ3pDRSx1QkFBdUJELFdBQVcsR0FBRztBQUN2QztBQUNBLE1BQU1FLGVBQWUsV0FBVyxHQUFFNUMsZ0RBQW1CLENBQUM7QUFDdEQsSUFBSXlDLElBQXFDLEVBQUU7SUFDekNHLGFBQWFGLFdBQVcsR0FBRztBQUM3QjtBQUVBOzs7Ozs7OztDQVFDLEdBRUQsTUFB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RjtJQUNBLE9BQU9pTTtBQUNUO0FBQ0EsU0FBU0MsbUJBQW1CdE4sTUFBTSxFQUFFb0osSUFBSTtJQUN0QyxPQUFPdFAsK0RBQVlBLENBQUM7UUFDbEJ5QyxVQUFVNk0sUUFBUSxPQUFPLEtBQUssSUFBSUEsS0FBSzdNLFFBQVE7UUFDL0NzTSxRQUFRdE8sU0FBUyxDQUFDLEdBQUc2TyxRQUFRLE9BQU8sS0FBSyxJQUFJQSxLQUFLUCxNQUFNLEVBQUU7WUFDeEQwRSxvQkFBb0I7UUFDdEI7UUFDQXZELFNBQVNwUSxzRUFBbUJBLENBQUM7WUFDM0JnUSxnQkFBZ0JSLFFBQVEsT0FBTyxLQUFLLElBQUlBLEtBQUtRLGNBQWM7WUFDM0RDLGNBQWNULFFBQVEsT0FBTyxLQUFLLElBQUlBLEtBQUtTLFlBQVk7UUFDekQ7UUFDQTJELGVBQWVwRSxRQUFRLE9BQU8sS0FBSyxJQUFJQSxLQUFLb0UsYUFBYTtRQUN6RHhOO1FBQ0FvTjtJQUNGLEdBQUdLLFVBQVU7QUFDZjtBQUV5MUIsQ0FDejFCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL21hcmluYW1rLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXJvdXRlci9kaXN0L2luZGV4LmpzPzJhMWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZWFjdCBSb3V0ZXIgdjYuMjAuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBVTlNBRkVfaW52YXJpYW50LCBqb2luUGF0aHMsIG1hdGNoUGF0aCwgVU5TQUZFX2dldFBhdGhDb250cmlidXRpbmdNYXRjaGVzLCBVTlNBRkVfd2FybmluZywgcmVzb2x2ZVRvLCBwYXJzZVBhdGgsIG1hdGNoUm91dGVzLCBBY3Rpb24sIFVOU0FGRV9jb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaCwgc3RyaXBCYXNlbmFtZSwgSURMRV9CTE9DS0VSLCBpc1JvdXRlRXJyb3JSZXNwb25zZSwgY3JlYXRlTWVtb3J5SGlzdG9yeSwgQWJvcnRlZERlZmVycmVkRXJyb3IsIGNyZWF0ZVJvdXRlciB9IGZyb20gJ0ByZW1peC1ydW4vcm91dGVyJztcbmV4cG9ydCB7IEFib3J0ZWREZWZlcnJlZEVycm9yLCBBY3Rpb24gYXMgTmF2aWdhdGlvblR5cGUsIGNyZWF0ZVBhdGgsIGRlZmVyLCBnZW5lcmF0ZVBhdGgsIGlzUm91dGVFcnJvclJlc3BvbnNlLCBqc29uLCBtYXRjaFBhdGgsIG1hdGNoUm91dGVzLCBwYXJzZVBhdGgsIHJlZGlyZWN0LCByZWRpcmVjdERvY3VtZW50LCByZXNvbHZlUGF0aCB9IGZyb20gJ0ByZW1peC1ydW4vcm91dGVyJztcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbi8vIENyZWF0ZSByZWFjdC1zcGVjaWZpYyB0eXBlcyBmcm9tIHRoZSBhZ25vc3RpYyB0eXBlcyBpbiBAcmVtaXgtcnVuL3JvdXRlciB0b1xuLy8gZXhwb3J0IGZyb20gcmVhY3Qtcm91dGVyXG5jb25zdCBEYXRhUm91dGVyQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBEYXRhUm91dGVyQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiRGF0YVJvdXRlclwiO1xufVxuY29uc3QgRGF0YVJvdXRlclN0YXRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBEYXRhUm91dGVyU3RhdGVDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJEYXRhUm91dGVyU3RhdGVcIjtcbn1cbmNvbnN0IEF3YWl0Q29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBBd2FpdENvbnRleHQuZGlzcGxheU5hbWUgPSBcIkF3YWl0XCI7XG59XG5cbi8qKlxuICogQSBOYXZpZ2F0b3IgaXMgYSBcImxvY2F0aW9uIGNoYW5nZXJcIjsgaXQncyBob3cgeW91IGdldCB0byBkaWZmZXJlbnQgbG9jYXRpb25zLlxuICpcbiAqIEV2ZXJ5IGhpc3RvcnkgaW5zdGFuY2UgY29uZm9ybXMgdG8gdGhlIE5hdmlnYXRvciBpbnRlcmZhY2UsIGJ1dCB0aGVcbiAqIGRpc3RpbmN0aW9uIGlzIHVzZWZ1bCBwcmltYXJpbHkgd2hlbiBpdCBjb21lcyB0byB0aGUgbG93LWxldmVsIGA8Um91dGVyPmAgQVBJXG4gKiB3aGVyZSBib3RoIHRoZSBsb2NhdGlvbiBhbmQgYSBuYXZpZ2F0b3IgbXVzdCBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGluIG9yZGVyXG4gKiB0byBhdm9pZCBcInRlYXJpbmdcIiB0aGF0IG1heSBvY2N1ciBpbiBhIHN1c3BlbnNlLWVuYWJsZWQgYXBwIGlmIHRoZSBhY3Rpb25cbiAqIGFuZC9vciBsb2NhdGlvbiB3ZXJlIHRvIGJlIHJlYWQgZGlyZWN0bHkgZnJvbSB0aGUgaGlzdG9yeSBpbnN0YW5jZS5cbiAqL1xuXG5jb25zdCBOYXZpZ2F0aW9uQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBOYXZpZ2F0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiTmF2aWdhdGlvblwiO1xufVxuY29uc3QgTG9jYXRpb25Db250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIExvY2F0aW9uQ29udGV4dC5kaXNwbGF5TmFtZSA9IFwiTG9jYXRpb25cIjtcbn1cbmNvbnN0IFJvdXRlQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHtcbiAgb3V0bGV0OiBudWxsLFxuICBtYXRjaGVzOiBbXSxcbiAgaXNEYXRhUm91dGU6IGZhbHNlXG59KTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgUm91dGVDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJSb3V0ZVwiO1xufVxuY29uc3QgUm91dGVFcnJvckNvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgUm91dGVFcnJvckNvbnRleHQuZGlzcGxheU5hbWUgPSBcIlJvdXRlRXJyb3JcIjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmdWxsIGhyZWYgZm9yIHRoZSBnaXZlbiBcInRvXCIgdmFsdWUuIFRoaXMgaXMgdXNlZnVsIGZvciBidWlsZGluZ1xuICogY3VzdG9tIGxpbmtzIHRoYXQgYXJlIGFsc28gYWNjZXNzaWJsZSBhbmQgcHJlc2VydmUgcmlnaHQtY2xpY2sgYmVoYXZpb3IuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtaHJlZlxuICovXG5mdW5jdGlvbiB1c2VIcmVmKHRvLCBfdGVtcCkge1xuICBsZXQge1xuICAgIHJlbGF0aXZlXG4gIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgIXVzZUluUm91dGVyQ29udGV4dCgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgXCJ1c2VIcmVmKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZSxcbiAgICBuYXZpZ2F0b3JcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQge1xuICAgIGhhc2gsXG4gICAgcGF0aG5hbWUsXG4gICAgc2VhcmNoXG4gIH0gPSB1c2VSZXNvbHZlZFBhdGgodG8sIHtcbiAgICByZWxhdGl2ZVxuICB9KTtcbiAgbGV0IGpvaW5lZFBhdGhuYW1lID0gcGF0aG5hbWU7XG5cbiAgLy8gSWYgd2UncmUgb3BlcmF0aW5nIHdpdGhpbiBhIGJhc2VuYW1lLCBwcmVwZW5kIGl0IHRvIHRoZSBwYXRobmFtZSBwcmlvclxuICAvLyB0byBjcmVhdGluZyB0aGUgaHJlZi4gIElmIHRoaXMgaXMgYSByb290IG5hdmlnYXRpb24sIHRoZW4ganVzdCB1c2UgdGhlIHJhd1xuICAvLyBiYXNlbmFtZSB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlIHByZXNlbmNlXG4gIC8vIG9mIGEgdHJhaWxpbmcgc2xhc2ggb24gcm9vdCBsaW5rc1xuICBpZiAoYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgam9pbmVkUGF0aG5hbWUgPSBwYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGhuYW1lXSk7XG4gIH1cbiAgcmV0dXJuIG5hdmlnYXRvci5jcmVhdGVIcmVmKHtcbiAgICBwYXRobmFtZTogam9pbmVkUGF0aG5hbWUsXG4gICAgc2VhcmNoLFxuICAgIGhhc2hcbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY29tcG9uZW50IGlzIGEgZGVzY2VuZGFudCBvZiBhIGA8Um91dGVyPmAuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtaW4tcm91dGVyLWNvbnRleHRcbiAqL1xuZnVuY3Rpb24gdXNlSW5Sb3V0ZXJDb250ZXh0KCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpICE9IG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBsb2NhdGlvbiBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgVVJMIGluIHdlYlxuICogYnJvd3NlcnMuXG4gKlxuICogTm90ZTogSWYgeW91J3JlIHVzaW5nIHRoaXMgaXQgbWF5IG1lYW4geW91J3JlIGRvaW5nIHNvbWUgb2YgeW91ciBvd25cbiAqIFwicm91dGluZ1wiIGluIHlvdXIgYXBwLCBhbmQgd2UnZCBsaWtlIHRvIGtub3cgd2hhdCB5b3VyIHVzZSBjYXNlIGlzLiBXZSBtYXlcbiAqIGJlIGFibGUgdG8gcHJvdmlkZSBzb21ldGhpbmcgaGlnaGVyLWxldmVsIHRvIGJldHRlciBzdWl0IHlvdXIgbmVlZHMuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtbG9jYXRpb25cbiAqL1xuZnVuY3Rpb24gdXNlTG9jYXRpb24oKSB7XG4gICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mIHRoZVxuICAvLyByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gIFwidXNlTG9jYXRpb24oKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLmxvY2F0aW9uO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgbmF2aWdhdGlvbiBhY3Rpb24gd2hpY2ggZGVzY3JpYmVzIGhvdyB0aGUgcm91dGVyIGNhbWUgdG9cbiAqIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBlaXRoZXIgYnkgYSBwb3AsIHB1c2gsIG9yIHJlcGxhY2Ugb24gdGhlIGhpc3Rvcnkgc3RhY2suXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtbmF2aWdhdGlvbi10eXBlXG4gKi9cbmZ1bmN0aW9uIHVzZU5hdmlnYXRpb25UeXBlKCkge1xuICByZXR1cm4gUmVhY3QudXNlQ29udGV4dChMb2NhdGlvbkNvbnRleHQpLm5hdmlnYXRpb25UeXBlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBQYXRoTWF0Y2ggb2JqZWN0IGlmIHRoZSBnaXZlbiBwYXR0ZXJuIG1hdGNoZXMgdGhlIGN1cnJlbnQgVVJMLlxuICogVGhpcyBpcyB1c2VmdWwgZm9yIGNvbXBvbmVudHMgdGhhdCBuZWVkIHRvIGtub3cgXCJhY3RpdmVcIiBzdGF0ZSwgZS5nLlxuICogYDxOYXZMaW5rPmAuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2UtbWF0Y2hcbiAqL1xuZnVuY3Rpb24gdXNlTWF0Y2gocGF0dGVybikge1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICBcInVzZU1hdGNoKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IHtcbiAgICBwYXRobmFtZVxuICB9ID0gdXNlTG9jYXRpb24oKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gbWF0Y2hQYXRoKHBhdHRlcm4sIHBhdGhuYW1lKSwgW3BhdGhuYW1lLCBwYXR0ZXJuXSk7XG59XG5cbi8qKlxuICogVGhlIGludGVyZmFjZSBmb3IgdGhlIG5hdmlnYXRlKCkgZnVuY3Rpb24gcmV0dXJuZWQgZnJvbSB1c2VOYXZpZ2F0ZSgpLlxuICovXG5cbmNvbnN0IG5hdmlnYXRlRWZmZWN0V2FybmluZyA9IFwiWW91IHNob3VsZCBjYWxsIG5hdmlnYXRlKCkgaW4gYSBSZWFjdC51c2VFZmZlY3QoKSwgbm90IHdoZW4gXCIgKyBcInlvdXIgY29tcG9uZW50IGlzIGZpcnN0IHJlbmRlcmVkLlwiO1xuXG4vLyBNdXRlIHdhcm5pbmdzIGZvciBjYWxscyB0byB1c2VOYXZpZ2F0ZSBpbiBTU1IgZW52aXJvbm1lbnRzXG5mdW5jdGlvbiB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGNiKSB7XG4gIGxldCBpc1N0YXRpYyA9IFJlYWN0LnVzZUNvbnRleHQoTmF2aWdhdGlvbkNvbnRleHQpLnN0YXRpYztcbiAgaWYgKCFpc1N0YXRpYykge1xuICAgIC8vIFdlIHNob3VsZCBiZSBhYmxlIHRvIGdldCByaWQgb2YgdGhpcyBvbmNlIHJlYWN0IDE4LjMgaXMgcmVsZWFzZWRcbiAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzI2Mzk1XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KGNiKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgYW4gaW1wZXJhdGl2ZSBtZXRob2QgZm9yIGNoYW5naW5nIHRoZSBsb2NhdGlvbi4gVXNlZCBieSBgPExpbms+YHMsIGJ1dFxuICogbWF5IGFsc28gYmUgdXNlZCBieSBvdGhlciBlbGVtZW50cyB0byBjaGFuZ2UgdGhlIGxvY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLW5hdmlnYXRlXG4gKi9cbmZ1bmN0aW9uIHVzZU5hdmlnYXRlKCkge1xuICBsZXQge1xuICAgIGlzRGF0YVJvdXRlXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIC8vIENvbmRpdGlvbmFsIHVzYWdlIGlzIE9LIGhlcmUgYmVjYXVzZSB0aGUgdXNhZ2Ugb2YgYSBkYXRhIHJvdXRlciBpcyBzdGF0aWNcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gIHJldHVybiBpc0RhdGFSb3V0ZSA/IHVzZU5hdmlnYXRlU3RhYmxlKCkgOiB1c2VOYXZpZ2F0ZVVuc3RhYmxlKCk7XG59XG5mdW5jdGlvbiB1c2VOYXZpZ2F0ZVVuc3RhYmxlKCkge1xuICAhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCAvLyBUT0RPOiBUaGlzIGVycm9yIGlzIHByb2JhYmx5IGJlY2F1c2UgdGhleSBzb21laG93IGhhdmUgMiB2ZXJzaW9ucyBvZiB0aGVcbiAgLy8gcm91dGVyIGxvYWRlZC4gV2UgY2FuIGhlbHAgdGhlbSB1bmRlcnN0YW5kIGhvdyB0byBhdm9pZCB0aGF0LlxuICBcInVzZU5hdmlnYXRlKCkgbWF5IGJlIHVzZWQgb25seSBpbiB0aGUgY29udGV4dCBvZiBhIDxSb3V0ZXI+IGNvbXBvbmVudC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyQ29udGV4dCk7XG4gIGxldCB7XG4gICAgYmFzZW5hbWUsXG4gICAgbmF2aWdhdG9yXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KE5hdmlnYXRpb25Db250ZXh0KTtcbiAgbGV0IHtcbiAgICBtYXRjaGVzXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCB7XG4gICAgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWVcbiAgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCByb3V0ZVBhdGhuYW1lc0pzb24gPSBKU09OLnN0cmluZ2lmeShVTlNBRkVfZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMobWF0Y2hlcykubWFwKG1hdGNoID0+IG1hdGNoLnBhdGhuYW1lQmFzZSkpO1xuICBsZXQgYWN0aXZlUmVmID0gUmVhY3QudXNlUmVmKGZhbHNlKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgYWN0aXZlUmVmLmN1cnJlbnQgPSB0cnVlO1xuICB9KTtcbiAgbGV0IG5hdmlnYXRlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHRvLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhhY3RpdmVSZWYuY3VycmVudCwgbmF2aWdhdGVFZmZlY3RXYXJuaW5nKSA6IHZvaWQgMDtcblxuICAgIC8vIFNob3J0IGNpcmN1aXQgaGVyZSBzaW5jZSBpZiB0aGlzIGhhcHBlbnMgb24gZmlyc3QgcmVuZGVyIHRoZSBuYXZpZ2F0ZVxuICAgIC8vIGlzIHVzZWxlc3MgYmVjYXVzZSB3ZSBoYXZlbid0IHdpcmVkIHVwIG91ciBoaXN0b3J5IGxpc3RlbmVyIHlldFxuICAgIGlmICghYWN0aXZlUmVmLmN1cnJlbnQpIHJldHVybjtcbiAgICBpZiAodHlwZW9mIHRvID09PSBcIm51bWJlclwiKSB7XG4gICAgICBuYXZpZ2F0b3IuZ28odG8pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgcGF0aCA9IHJlc29sdmVUbyh0bywgSlNPTi5wYXJzZShyb3V0ZVBhdGhuYW1lc0pzb24pLCBsb2NhdGlvblBhdGhuYW1lLCBvcHRpb25zLnJlbGF0aXZlID09PSBcInBhdGhcIik7XG5cbiAgICAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgd2l0aGluIGEgYmFzZW5hbWUsIHByZXBlbmQgaXQgdG8gdGhlIHBhdGhuYW1lIHByaW9yXG4gICAgLy8gdG8gaGFuZGluZyBvZmYgdG8gaGlzdG9yeSAoYnV0IG9ubHkgaWYgd2UncmUgbm90IGluIGEgZGF0YSByb3V0ZXIsXG4gICAgLy8gb3RoZXJ3aXNlIGl0J2xsIHByZXBlbmQgdGhlIGJhc2VuYW1lIGluc2lkZSBvZiB0aGUgcm91dGVyKS5cbiAgICAvLyBJZiB0aGlzIGlzIGEgcm9vdCBuYXZpZ2F0aW9uLCB0aGVuIHdlIG5hdmlnYXRlIHRvIHRoZSByYXcgYmFzZW5hbWVcbiAgICAvLyB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlIHByZXNlbmNlIG9mIGFcbiAgICAvLyB0cmFpbGluZyBzbGFzaCBvbiByb290IGxpbmtzXG4gICAgaWYgKGRhdGFSb3V0ZXJDb250ZXh0ID09IG51bGwgJiYgYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgICBwYXRoLnBhdGhuYW1lID0gcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgICB9XG4gICAgKCEhb3B0aW9ucy5yZXBsYWNlID8gbmF2aWdhdG9yLnJlcGxhY2UgOiBuYXZpZ2F0b3IucHVzaCkocGF0aCwgb3B0aW9ucy5zdGF0ZSwgb3B0aW9ucyk7XG4gIH0sIFtiYXNlbmFtZSwgbmF2aWdhdG9yLCByb3V0ZVBhdGhuYW1lc0pzb24sIGxvY2F0aW9uUGF0aG5hbWUsIGRhdGFSb3V0ZXJDb250ZXh0XSk7XG4gIHJldHVybiBuYXZpZ2F0ZTtcbn1cbmNvbnN0IE91dGxldENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjb250ZXh0IChpZiBwcm92aWRlZCkgZm9yIHRoZSBjaGlsZCByb3V0ZSBhdCB0aGlzIGxldmVsIG9mIHRoZSByb3V0ZVxuICogaGllcmFyY2h5LlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2Utb3V0bGV0LWNvbnRleHRcbiAqL1xuZnVuY3Rpb24gdXNlT3V0bGV0Q29udGV4dCgpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZUNvbnRleHQoT3V0bGV0Q29udGV4dCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBmb3IgdGhlIGNoaWxkIHJvdXRlIGF0IHRoaXMgbGV2ZWwgb2YgdGhlIHJvdXRlXG4gKiBoaWVyYXJjaHkuIFVzZWQgaW50ZXJuYWxseSBieSBgPE91dGxldD5gIHRvIHJlbmRlciBjaGlsZCByb3V0ZXMuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9ob29rcy91c2Utb3V0bGV0XG4gKi9cbmZ1bmN0aW9uIHVzZU91dGxldChjb250ZXh0KSB7XG4gIGxldCBvdXRsZXQgPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCkub3V0bGV0O1xuICBpZiAob3V0bGV0KSB7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE91dGxldENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiBjb250ZXh0XG4gICAgfSwgb3V0bGV0KTtcbiAgfVxuICByZXR1cm4gb3V0bGV0O1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IG9mIGtleS92YWx1ZSBwYWlycyBvZiB0aGUgZHluYW1pYyBwYXJhbXMgZnJvbSB0aGUgY3VycmVudFxuICogVVJMIHRoYXQgd2VyZSBtYXRjaGVkIGJ5IHRoZSByb3V0ZSBwYXRoLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLXBhcmFtc1xuICovXG5mdW5jdGlvbiB1c2VQYXJhbXMoKSB7XG4gIGxldCB7XG4gICAgbWF0Y2hlc1xuICB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVNYXRjaCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhcmFtcyA6IHt9O1xufVxuXG4vKipcbiAqIFJlc29sdmVzIHRoZSBwYXRobmFtZSBvZiB0aGUgZ2l2ZW4gYHRvYCB2YWx1ZSBhZ2FpbnN0IHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vaG9va3MvdXNlLXJlc29sdmVkLXBhdGhcbiAqL1xuZnVuY3Rpb24gdXNlUmVzb2x2ZWRQYXRoKHRvLCBfdGVtcDIpIHtcbiAgbGV0IHtcbiAgICByZWxhdGl2ZVxuICB9ID0gX3RlbXAyID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMjtcbiAgbGV0IHtcbiAgICBtYXRjaGVzXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gIGxldCB7XG4gICAgcGF0aG5hbWU6IGxvY2F0aW9uUGF0aG5hbWVcbiAgfSA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCByb3V0ZVBhdGhuYW1lc0pzb24gPSBKU09OLnN0cmluZ2lmeShVTlNBRkVfZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMobWF0Y2hlcykubWFwKG1hdGNoID0+IG1hdGNoLnBhdGhuYW1lQmFzZSkpO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiByZXNvbHZlVG8odG8sIEpTT04ucGFyc2Uocm91dGVQYXRobmFtZXNKc29uKSwgbG9jYXRpb25QYXRobmFtZSwgcmVsYXRpdmUgPT09IFwicGF0aFwiKSwgW3RvLCByb3V0ZVBhdGhuYW1lc0pzb24sIGxvY2F0aW9uUGF0aG5hbWUsIHJlbGF0aXZlXSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBvZiB0aGUgcm91dGUgdGhhdCBtYXRjaGVkIHRoZSBjdXJyZW50IGxvY2F0aW9uLCBwcmVwYXJlZFxuICogd2l0aCB0aGUgY29ycmVjdCBjb250ZXh0IHRvIHJlbmRlciB0aGUgcmVtYWluZGVyIG9mIHRoZSByb3V0ZSB0cmVlLiBSb3V0ZVxuICogZWxlbWVudHMgaW4gdGhlIHRyZWUgbXVzdCByZW5kZXIgYW4gYDxPdXRsZXQ+YCB0byByZW5kZXIgdGhlaXIgY2hpbGQgcm91dGUnc1xuICogZWxlbWVudC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL2hvb2tzL3VzZS1yb3V0ZXNcbiAqL1xuZnVuY3Rpb24gdXNlUm91dGVzKHJvdXRlcywgbG9jYXRpb25BcmcpIHtcbiAgcmV0dXJuIHVzZVJvdXRlc0ltcGwocm91dGVzLCBsb2NhdGlvbkFyZyk7XG59XG5cbi8vIEludGVybmFsIGltcGxlbWVudGF0aW9uIHdpdGggYWNjZXB0IG9wdGlvbmFsIHBhcmFtIGZvciBSb3V0ZXJQcm92aWRlciB1c2FnZVxuZnVuY3Rpb24gdXNlUm91dGVzSW1wbChyb3V0ZXMsIGxvY2F0aW9uQXJnLCBkYXRhUm91dGVyU3RhdGUpIHtcbiAgIXVzZUluUm91dGVyQ29udGV4dCgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgLy8gVE9ETzogVGhpcyBlcnJvciBpcyBwcm9iYWJseSBiZWNhdXNlIHRoZXkgc29tZWhvdyBoYXZlIDIgdmVyc2lvbnMgb2YgdGhlXG4gIC8vIHJvdXRlciBsb2FkZWQuIFdlIGNhbiBoZWxwIHRoZW0gdW5kZXJzdGFuZCBob3cgdG8gYXZvaWQgdGhhdC5cbiAgXCJ1c2VSb3V0ZXMoKSBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBsZXQge1xuICAgIG5hdmlnYXRvclxuICB9ID0gUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCB7XG4gICAgbWF0Y2hlczogcGFyZW50TWF0Y2hlc1xuICB9ID0gUmVhY3QudXNlQ29udGV4dChSb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVNYXRjaCA9IHBhcmVudE1hdGNoZXNbcGFyZW50TWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgbGV0IHBhcmVudFBhcmFtcyA9IHJvdXRlTWF0Y2ggPyByb3V0ZU1hdGNoLnBhcmFtcyA6IHt9O1xuICBsZXQgcGFyZW50UGF0aG5hbWUgPSByb3V0ZU1hdGNoID8gcm91dGVNYXRjaC5wYXRobmFtZSA6IFwiL1wiO1xuICBsZXQgcGFyZW50UGF0aG5hbWVCYXNlID0gcm91dGVNYXRjaCA/IHJvdXRlTWF0Y2gucGF0aG5hbWVCYXNlIDogXCIvXCI7XG4gIGxldCBwYXJlbnRSb3V0ZSA9IHJvdXRlTWF0Y2ggJiYgcm91dGVNYXRjaC5yb3V0ZTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIC8vIFlvdSB3b24ndCBnZXQgYSB3YXJuaW5nIGFib3V0IDIgZGlmZmVyZW50IDxSb3V0ZXM+IHVuZGVyIGEgPFJvdXRlPlxuICAgIC8vIHdpdGhvdXQgYSB0cmFpbGluZyAqLCBidXQgdGhpcyBpcyBhIGJlc3QtZWZmb3J0IHdhcm5pbmcgYW55d2F5IHNpbmNlIHdlXG4gICAgLy8gY2Fubm90IGV2ZW4gZ2l2ZSB0aGUgd2FybmluZyB1bmxlc3MgdGhleSBsYW5kIGF0IHRoZSBwYXJlbnQgcm91dGUuXG4gICAgLy9cbiAgICAvLyBFeGFtcGxlOlxuICAgIC8vXG4gICAgLy8gPFJvdXRlcz5cbiAgICAvLyAgIHsvKiBUaGlzIHJvdXRlIHBhdGggTVVTVCBlbmQgd2l0aCAvKiBiZWNhdXNlIG90aGVyd2lzZVxuICAgIC8vICAgICAgIGl0IHdpbGwgbmV2ZXIgbWF0Y2ggL2Jsb2cvcG9zdC8xMjMgKi99XG4gICAgLy8gICA8Um91dGUgcGF0aD1cImJsb2dcIiBlbGVtZW50PXs8QmxvZyAvPn0gLz5cbiAgICAvLyAgIDxSb3V0ZSBwYXRoPVwiYmxvZy9mZWVkXCIgZWxlbWVudD17PEJsb2dGZWVkIC8+fSAvPlxuICAgIC8vIDwvUm91dGVzPlxuICAgIC8vXG4gICAgLy8gZnVuY3Rpb24gQmxvZygpIHtcbiAgICAvLyAgIHJldHVybiAoXG4gICAgLy8gICAgIDxSb3V0ZXM+XG4gICAgLy8gICAgICAgPFJvdXRlIHBhdGg9XCJwb3N0LzppZFwiIGVsZW1lbnQ9ezxQb3N0IC8+fSAvPlxuICAgIC8vICAgICA8L1JvdXRlcz5cbiAgICAvLyAgICk7XG4gICAgLy8gfVxuICAgIGxldCBwYXJlbnRQYXRoID0gcGFyZW50Um91dGUgJiYgcGFyZW50Um91dGUucGF0aCB8fCBcIlwiO1xuICAgIHdhcm5pbmdPbmNlKHBhcmVudFBhdGhuYW1lLCAhcGFyZW50Um91dGUgfHwgcGFyZW50UGF0aC5lbmRzV2l0aChcIipcIiksIFwiWW91IHJlbmRlcmVkIGRlc2NlbmRhbnQgPFJvdXRlcz4gKG9yIGNhbGxlZCBgdXNlUm91dGVzKClgKSBhdCBcIiArIChcIlxcXCJcIiArIHBhcmVudFBhdGhuYW1lICsgXCJcXFwiICh1bmRlciA8Um91dGUgcGF0aD1cXFwiXCIgKyBwYXJlbnRQYXRoICsgXCJcXFwiPikgYnV0IHRoZSBcIikgKyBcInBhcmVudCByb3V0ZSBwYXRoIGhhcyBubyB0cmFpbGluZyBcXFwiKlxcXCIuIFRoaXMgbWVhbnMgaWYgeW91IG5hdmlnYXRlIFwiICsgXCJkZWVwZXIsIHRoZSBwYXJlbnQgd29uJ3QgbWF0Y2ggYW55bW9yZSBhbmQgdGhlcmVmb3JlIHRoZSBjaGlsZCBcIiArIFwicm91dGVzIHdpbGwgbmV2ZXIgcmVuZGVyLlxcblxcblwiICsgKFwiUGxlYXNlIGNoYW5nZSB0aGUgcGFyZW50IDxSb3V0ZSBwYXRoPVxcXCJcIiArIHBhcmVudFBhdGggKyBcIlxcXCI+IHRvIDxSb3V0ZSBcIikgKyAoXCJwYXRoPVxcXCJcIiArIChwYXJlbnRQYXRoID09PSBcIi9cIiA/IFwiKlwiIDogcGFyZW50UGF0aCArIFwiLypcIikgKyBcIlxcXCI+LlwiKSk7XG4gIH1cbiAgbGV0IGxvY2F0aW9uRnJvbUNvbnRleHQgPSB1c2VMb2NhdGlvbigpO1xuICBsZXQgbG9jYXRpb247XG4gIGlmIChsb2NhdGlvbkFyZykge1xuICAgIHZhciBfcGFyc2VkTG9jYXRpb25BcmckcGE7XG4gICAgbGV0IHBhcnNlZExvY2F0aW9uQXJnID0gdHlwZW9mIGxvY2F0aW9uQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuICAgICEocGFyZW50UGF0aG5hbWVCYXNlID09PSBcIi9cIiB8fCAoKF9wYXJzZWRMb2NhdGlvbkFyZyRwYSA9IHBhcnNlZExvY2F0aW9uQXJnLnBhdGhuYW1lKSA9PSBudWxsID8gdm9pZCAwIDogX3BhcnNlZExvY2F0aW9uQXJnJHBhLnN0YXJ0c1dpdGgocGFyZW50UGF0aG5hbWVCYXNlKSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJXaGVuIG92ZXJyaWRpbmcgdGhlIGxvY2F0aW9uIHVzaW5nIGA8Um91dGVzIGxvY2F0aW9uPmAgb3IgYHVzZVJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uKWAsIFwiICsgXCJ0aGUgbG9jYXRpb24gcGF0aG5hbWUgbXVzdCBiZWdpbiB3aXRoIHRoZSBwb3J0aW9uIG9mIHRoZSBVUkwgcGF0aG5hbWUgdGhhdCB3YXMgXCIgKyAoXCJtYXRjaGVkIGJ5IGFsbCBwYXJlbnQgcm91dGVzLiBUaGUgY3VycmVudCBwYXRobmFtZSBiYXNlIGlzIFxcXCJcIiArIHBhcmVudFBhdGhuYW1lQmFzZSArIFwiXFxcIiBcIikgKyAoXCJidXQgcGF0aG5hbWUgXFxcIlwiICsgcGFyc2VkTG9jYXRpb25BcmcucGF0aG5hbWUgKyBcIlxcXCIgd2FzIGdpdmVuIGluIHRoZSBgbG9jYXRpb25gIHByb3AuXCIpKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAgIGxvY2F0aW9uID0gcGFyc2VkTG9jYXRpb25Bcmc7XG4gIH0gZWxzZSB7XG4gICAgbG9jYXRpb24gPSBsb2NhdGlvbkZyb21Db250ZXh0O1xuICB9XG4gIGxldCBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lIHx8IFwiL1wiO1xuICBsZXQgcmVtYWluaW5nUGF0aG5hbWUgPSBwYXJlbnRQYXRobmFtZUJhc2UgPT09IFwiL1wiID8gcGF0aG5hbWUgOiBwYXRobmFtZS5zbGljZShwYXJlbnRQYXRobmFtZUJhc2UubGVuZ3RoKSB8fCBcIi9cIjtcbiAgbGV0IG1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXMsIHtcbiAgICBwYXRobmFtZTogcmVtYWluaW5nUGF0aG5hbWVcbiAgfSk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhwYXJlbnRSb3V0ZSB8fCBtYXRjaGVzICE9IG51bGwsIFwiTm8gcm91dGVzIG1hdGNoZWQgbG9jYXRpb24gXFxcIlwiICsgbG9jYXRpb24ucGF0aG5hbWUgKyBsb2NhdGlvbi5zZWFyY2ggKyBsb2NhdGlvbi5oYXNoICsgXCJcXFwiIFwiKSA6IHZvaWQgMDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhtYXRjaGVzID09IG51bGwgfHwgbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmVsZW1lbnQgIT09IHVuZGVmaW5lZCB8fCBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucm91dGUuQ29tcG9uZW50ICE9PSB1bmRlZmluZWQsIFwiTWF0Y2hlZCBsZWFmIHJvdXRlIGF0IGxvY2F0aW9uIFxcXCJcIiArIGxvY2F0aW9uLnBhdGhuYW1lICsgbG9jYXRpb24uc2VhcmNoICsgbG9jYXRpb24uaGFzaCArIFwiXFxcIiBcIiArIFwiZG9lcyBub3QgaGF2ZSBhbiBlbGVtZW50IG9yIENvbXBvbmVudC4gVGhpcyBtZWFucyBpdCB3aWxsIHJlbmRlciBhbiA8T3V0bGV0IC8+IHdpdGggYSBcIiArIFwibnVsbCB2YWx1ZSBieSBkZWZhdWx0IHJlc3VsdGluZyBpbiBhbiBcXFwiZW1wdHlcXFwiIHBhZ2UuXCIpIDogdm9pZCAwO1xuICB9XG4gIGxldCByZW5kZXJlZE1hdGNoZXMgPSBfcmVuZGVyTWF0Y2hlcyhtYXRjaGVzICYmIG1hdGNoZXMubWFwKG1hdGNoID0+IE9iamVjdC5hc3NpZ24oe30sIG1hdGNoLCB7XG4gICAgcGFyYW1zOiBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnRQYXJhbXMsIG1hdGNoLnBhcmFtcyksXG4gICAgcGF0aG5hbWU6IGpvaW5QYXRocyhbcGFyZW50UGF0aG5hbWVCYXNlLFxuICAgIC8vIFJlLWVuY29kZSBwYXRobmFtZXMgdGhhdCB3ZXJlIGRlY29kZWQgaW5zaWRlIG1hdGNoUm91dGVzXG4gICAgbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uID8gbmF2aWdhdG9yLmVuY29kZUxvY2F0aW9uKG1hdGNoLnBhdGhuYW1lKS5wYXRobmFtZSA6IG1hdGNoLnBhdGhuYW1lXSksXG4gICAgcGF0aG5hbWVCYXNlOiBtYXRjaC5wYXRobmFtZUJhc2UgPT09IFwiL1wiID8gcGFyZW50UGF0aG5hbWVCYXNlIDogam9pblBhdGhzKFtwYXJlbnRQYXRobmFtZUJhc2UsXG4gICAgLy8gUmUtZW5jb2RlIHBhdGhuYW1lcyB0aGF0IHdlcmUgZGVjb2RlZCBpbnNpZGUgbWF0Y2hSb3V0ZXNcbiAgICBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24gPyBuYXZpZ2F0b3IuZW5jb2RlTG9jYXRpb24obWF0Y2gucGF0aG5hbWVCYXNlKS5wYXRobmFtZSA6IG1hdGNoLnBhdGhuYW1lQmFzZV0pXG4gIH0pKSwgcGFyZW50TWF0Y2hlcywgZGF0YVJvdXRlclN0YXRlKTtcblxuICAvLyBXaGVuIGEgdXNlciBwYXNzZXMgaW4gYSBgbG9jYXRpb25BcmdgLCB0aGUgYXNzb2NpYXRlZCByb3V0ZXMgbmVlZCB0b1xuICAvLyBiZSB3cmFwcGVkIGluIGEgbmV3IGBMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXJgIGluIG9yZGVyIGZvciBgdXNlTG9jYXRpb25gXG4gIC8vIHRvIHVzZSB0aGUgc2NvcGVkIGxvY2F0aW9uIGluc3RlYWQgb2YgdGhlIGdsb2JhbCBsb2NhdGlvbi5cbiAgaWYgKGxvY2F0aW9uQXJnICYmIHJlbmRlcmVkTWF0Y2hlcykge1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChMb2NhdGlvbkNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIGxvY2F0aW9uOiBfZXh0ZW5kcyh7XG4gICAgICAgICAgcGF0aG5hbWU6IFwiL1wiLFxuICAgICAgICAgIHNlYXJjaDogXCJcIixcbiAgICAgICAgICBoYXNoOiBcIlwiLFxuICAgICAgICAgIHN0YXRlOiBudWxsLFxuICAgICAgICAgIGtleTogXCJkZWZhdWx0XCJcbiAgICAgICAgfSwgbG9jYXRpb24pLFxuICAgICAgICBuYXZpZ2F0aW9uVHlwZTogQWN0aW9uLlBvcFxuICAgICAgfVxuICAgIH0sIHJlbmRlcmVkTWF0Y2hlcyk7XG4gIH1cbiAgcmV0dXJuIHJlbmRlcmVkTWF0Y2hlcztcbn1cbmZ1bmN0aW9uIERlZmF1bHRFcnJvckNvbXBvbmVudCgpIHtcbiAgbGV0IGVycm9yID0gdXNlUm91dGVFcnJvcigpO1xuICBsZXQgbWVzc2FnZSA9IGlzUm91dGVFcnJvclJlc3BvbnNlKGVycm9yKSA/IGVycm9yLnN0YXR1cyArIFwiIFwiICsgZXJyb3Iuc3RhdHVzVGV4dCA6IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogSlNPTi5zdHJpbmdpZnkoZXJyb3IpO1xuICBsZXQgc3RhY2sgPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3Iuc3RhY2sgOiBudWxsO1xuICBsZXQgbGlnaHRncmV5ID0gXCJyZ2JhKDIwMCwyMDAsMjAwLCAwLjUpXCI7XG4gIGxldCBwcmVTdHlsZXMgPSB7XG4gICAgcGFkZGluZzogXCIwLjVyZW1cIixcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGxpZ2h0Z3JleVxuICB9O1xuICBsZXQgY29kZVN0eWxlcyA9IHtcbiAgICBwYWRkaW5nOiBcIjJweCA0cHhcIixcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IGxpZ2h0Z3JleVxuICB9O1xuICBsZXQgZGV2SW5mbyA9IG51bGw7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaGFuZGxlZCBieSBSZWFjdCBSb3V0ZXIgZGVmYXVsdCBFcnJvckJvdW5kYXJ5OlwiLCBlcnJvcik7XG4gICAgZGV2SW5mbyA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBcIiwgbnVsbCwgXCJcXHVEODNEXFx1RENCRiBIZXkgZGV2ZWxvcGVyIFxcdUQ4M0RcXHVEQzRCXCIpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInBcIiwgbnVsbCwgXCJZb3UgY2FuIHByb3ZpZGUgYSB3YXkgYmV0dGVyIFVYIHRoYW4gdGhpcyB3aGVuIHlvdXIgYXBwIHRocm93cyBlcnJvcnMgYnkgcHJvdmlkaW5nIHlvdXIgb3duIFwiLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImNvZGVcIiwge1xuICAgICAgc3R5bGU6IGNvZGVTdHlsZXNcbiAgICB9LCBcIkVycm9yQm91bmRhcnlcIiksIFwiIG9yXCIsIFwiIFwiLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImNvZGVcIiwge1xuICAgICAgc3R5bGU6IGNvZGVTdHlsZXNcbiAgICB9LCBcImVycm9yRWxlbWVudFwiKSwgXCIgcHJvcCBvbiB5b3VyIHJvdXRlLlwiKSk7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImgyXCIsIG51bGwsIFwiVW5leHBlY3RlZCBBcHBsaWNhdGlvbiBFcnJvciFcIiksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiaDNcIiwge1xuICAgIHN0eWxlOiB7XG4gICAgICBmb250U3R5bGU6IFwiaXRhbGljXCJcbiAgICB9XG4gIH0sIG1lc3NhZ2UpLCBzdGFjayA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicHJlXCIsIHtcbiAgICBzdHlsZTogcHJlU3R5bGVzXG4gIH0sIHN0YWNrKSA6IG51bGwsIGRldkluZm8pO1xufVxuY29uc3QgZGVmYXVsdEVycm9yRWxlbWVudCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KERlZmF1bHRFcnJvckNvbXBvbmVudCwgbnVsbCk7XG5jbGFzcyBSZW5kZXJFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGxvY2F0aW9uOiBwcm9wcy5sb2NhdGlvbixcbiAgICAgIHJldmFsaWRhdGlvbjogcHJvcHMucmV2YWxpZGF0aW9uLFxuICAgICAgZXJyb3I6IHByb3BzLmVycm9yXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBlcnJvclxuICAgIH07XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgc3RhdGUpIHtcbiAgICAvLyBXaGVuIHdlIGdldCBpbnRvIGFuIGVycm9yIHN0YXRlLCB0aGUgdXNlciB3aWxsIGxpa2VseSBjbGljayBcImJhY2tcIiB0byB0aGVcbiAgICAvLyBwcmV2aW91cyBwYWdlIHRoYXQgZGlkbid0IGhhdmUgYW4gZXJyb3IuIEJlY2F1c2UgdGhpcyB3cmFwcyB0aGUgZW50aXJlXG4gICAgLy8gYXBwbGljYXRpb24sIHRoYXQgd2lsbCBoYXZlIG5vIGVmZmVjdC0tdGhlIGVycm9yIHBhZ2UgY29udGludWVzIHRvIGRpc3BsYXkuXG4gICAgLy8gVGhpcyBnaXZlcyB1cyBhIG1lY2hhbmlzbSB0byByZWNvdmVyIGZyb20gdGhlIGVycm9yIHdoZW4gdGhlIGxvY2F0aW9uIGNoYW5nZXMuXG4gICAgLy9cbiAgICAvLyBXaGV0aGVyIHdlJ3JlIGluIGFuIGVycm9yIHN0YXRlIG9yIG5vdCwgd2UgdXBkYXRlIHRoZSBsb2NhdGlvbiBpbiBzdGF0ZVxuICAgIC8vIHNvIHRoYXQgd2hlbiB3ZSBhcmUgaW4gYW4gZXJyb3Igc3RhdGUsIGl0IGdldHMgcmVzZXQgd2hlbiBhIG5ldyBsb2NhdGlvblxuICAgIC8vIGNvbWVzIGluIGFuZCB0aGUgdXNlciByZWNvdmVycyBmcm9tIHRoZSBlcnJvci5cbiAgICBpZiAoc3RhdGUubG9jYXRpb24gIT09IHByb3BzLmxvY2F0aW9uIHx8IHN0YXRlLnJldmFsaWRhdGlvbiAhPT0gXCJpZGxlXCIgJiYgcHJvcHMucmV2YWxpZGF0aW9uID09PSBcImlkbGVcIikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXJyb3I6IHByb3BzLmVycm9yLFxuICAgICAgICBsb2NhdGlvbjogcHJvcHMubG9jYXRpb24sXG4gICAgICAgIHJldmFsaWRhdGlvbjogcHJvcHMucmV2YWxpZGF0aW9uXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIG5vdCBjaGFuZ2luZyBsb2NhdGlvbnMsIHByZXNlcnZlIHRoZSBsb2NhdGlvbiBidXQgc3RpbGwgc3VyZmFjZVxuICAgIC8vIGFueSBuZXcgZXJyb3JzIHRoYXQgbWF5IGNvbWUgdGhyb3VnaC4gV2UgcmV0YWluIHRoZSBleGlzdGluZyBlcnJvciwgd2UgZG9cbiAgICAvLyB0aGlzIGJlY2F1c2UgdGhlIGVycm9yIHByb3ZpZGVkIGZyb20gdGhlIGFwcCBzdGF0ZSBtYXkgYmUgY2xlYXJlZCB3aXRob3V0XG4gICAgLy8gdGhlIGxvY2F0aW9uIGNoYW5naW5nLlxuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogcHJvcHMuZXJyb3IgfHwgc3RhdGUuZXJyb3IsXG4gICAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICByZXZhbGlkYXRpb246IHByb3BzLnJldmFsaWRhdGlvbiB8fCBzdGF0ZS5yZXZhbGlkYXRpb25cbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8pIHtcbiAgICBjb25zb2xlLmVycm9yKFwiUmVhY3QgUm91dGVyIGNhdWdodCB0aGUgZm9sbG93aW5nIGVycm9yIGR1cmluZyByZW5kZXJcIiwgZXJyb3IsIGVycm9ySW5mbyk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmVycm9yID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICB2YWx1ZTogdGhpcy5wcm9wcy5yb3V0ZUNvbnRleHRcbiAgICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZUVycm9yQ29udGV4dC5Qcm92aWRlciwge1xuICAgICAgdmFsdWU6IHRoaXMuc3RhdGUuZXJyb3IsXG4gICAgICBjaGlsZHJlbjogdGhpcy5wcm9wcy5jb21wb25lbnRcbiAgICB9KSkgOiB0aGlzLnByb3BzLmNoaWxkcmVuO1xuICB9XG59XG5mdW5jdGlvbiBSZW5kZXJlZFJvdXRlKF9yZWYpIHtcbiAgbGV0IHtcbiAgICByb3V0ZUNvbnRleHQsXG4gICAgbWF0Y2gsXG4gICAgY2hpbGRyZW5cbiAgfSA9IF9yZWY7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuXG4gIC8vIFRyYWNrIGhvdyBkZWVwIHdlIGdvdCBpbiBvdXIgcmVuZGVyIHBhc3MgdG8gZW11bGF0ZSBTU1IgY29tcG9uZW50RGlkQ2F0Y2hcbiAgLy8gaW4gYSBEYXRhU3RhdGljUm91dGVyXG4gIGlmIChkYXRhUm91dGVyQ29udGV4dCAmJiBkYXRhUm91dGVyQ29udGV4dC5zdGF0aWMgJiYgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljQ29udGV4dCAmJiAobWF0Y2gucm91dGUuZXJyb3JFbGVtZW50IHx8IG1hdGNoLnJvdXRlLkVycm9yQm91bmRhcnkpKSB7XG4gICAgZGF0YVJvdXRlckNvbnRleHQuc3RhdGljQ29udGV4dC5fZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCA9IG1hdGNoLnJvdXRlLmlkO1xuICB9XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogcm91dGVDb250ZXh0XG4gIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIF9yZW5kZXJNYXRjaGVzKG1hdGNoZXMsIHBhcmVudE1hdGNoZXMsIGRhdGFSb3V0ZXJTdGF0ZSkge1xuICB2YXIgX2RhdGFSb3V0ZXJTdGF0ZTI7XG4gIGlmIChwYXJlbnRNYXRjaGVzID09PSB2b2lkIDApIHtcbiAgICBwYXJlbnRNYXRjaGVzID0gW107XG4gIH1cbiAgaWYgKGRhdGFSb3V0ZXJTdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgZGF0YVJvdXRlclN0YXRlID0gbnVsbDtcbiAgfVxuICBpZiAobWF0Y2hlcyA9PSBudWxsKSB7XG4gICAgdmFyIF9kYXRhUm91dGVyU3RhdGU7XG4gICAgaWYgKChfZGF0YVJvdXRlclN0YXRlID0gZGF0YVJvdXRlclN0YXRlKSAhPSBudWxsICYmIF9kYXRhUm91dGVyU3RhdGUuZXJyb3JzKSB7XG4gICAgICAvLyBEb24ndCBiYWlsIGlmIHdlIGhhdmUgZGF0YSByb3V0ZXIgZXJyb3JzIHNvIHdlIGNhbiByZW5kZXIgdGhlbSBpbiB0aGVcbiAgICAgIC8vIGJvdW5kYXJ5LiAgVXNlIHRoZSBwcmUtbWF0Y2hlZCAob3Igc2hpbW1lZCkgbWF0Y2hlc1xuICAgICAgbWF0Y2hlcyA9IGRhdGFSb3V0ZXJTdGF0ZS5tYXRjaGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgbGV0IHJlbmRlcmVkTWF0Y2hlcyA9IG1hdGNoZXM7XG5cbiAgLy8gSWYgd2UgaGF2ZSBkYXRhIGVycm9ycywgdHJpbSBtYXRjaGVzIHRvIHRoZSBoaWdoZXN0IGVycm9yIGJvdW5kYXJ5XG4gIGxldCBlcnJvcnMgPSAoX2RhdGFSb3V0ZXJTdGF0ZTIgPSBkYXRhUm91dGVyU3RhdGUpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YVJvdXRlclN0YXRlMi5lcnJvcnM7XG4gIGlmIChlcnJvcnMgIT0gbnVsbCkge1xuICAgIGxldCBlcnJvckluZGV4ID0gcmVuZGVyZWRNYXRjaGVzLmZpbmRJbmRleChtID0+IG0ucm91dGUuaWQgJiYgKGVycm9ycyA9PSBudWxsID8gdm9pZCAwIDogZXJyb3JzW20ucm91dGUuaWRdKSk7XG4gICAgIShlcnJvckluZGV4ID49IDApID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJDb3VsZCBub3QgZmluZCBhIG1hdGNoaW5nIHJvdXRlIGZvciBlcnJvcnMgb24gcm91dGUgSURzOiBcIiArIE9iamVjdC5rZXlzKGVycm9ycykuam9pbihcIixcIikpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcmVuZGVyZWRNYXRjaGVzID0gcmVuZGVyZWRNYXRjaGVzLnNsaWNlKDAsIE1hdGgubWluKHJlbmRlcmVkTWF0Y2hlcy5sZW5ndGgsIGVycm9ySW5kZXggKyAxKSk7XG4gIH1cbiAgcmV0dXJuIHJlbmRlcmVkTWF0Y2hlcy5yZWR1Y2VSaWdodCgob3V0bGV0LCBtYXRjaCwgaW5kZXgpID0+IHtcbiAgICBsZXQgZXJyb3IgPSBtYXRjaC5yb3V0ZS5pZCA/IGVycm9ycyA9PSBudWxsID8gdm9pZCAwIDogZXJyb3JzW21hdGNoLnJvdXRlLmlkXSA6IG51bGw7XG4gICAgLy8gT25seSBkYXRhIHJvdXRlcnMgaGFuZGxlIGVycm9yc1xuICAgIGxldCBlcnJvckVsZW1lbnQgPSBudWxsO1xuICAgIGlmIChkYXRhUm91dGVyU3RhdGUpIHtcbiAgICAgIGVycm9yRWxlbWVudCA9IG1hdGNoLnJvdXRlLmVycm9yRWxlbWVudCB8fCBkZWZhdWx0RXJyb3JFbGVtZW50O1xuICAgIH1cbiAgICBsZXQgbWF0Y2hlcyA9IHBhcmVudE1hdGNoZXMuY29uY2F0KHJlbmRlcmVkTWF0Y2hlcy5zbGljZSgwLCBpbmRleCArIDEpKTtcbiAgICBsZXQgZ2V0Q2hpbGRyZW4gPSAoKSA9PiB7XG4gICAgICBsZXQgY2hpbGRyZW47XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBlcnJvckVsZW1lbnQ7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoLnJvdXRlLkNvbXBvbmVudCkge1xuICAgICAgICAvLyBOb3RlOiBUaGlzIGlzIGEgZGUtb3B0aW1pemVkIHBhdGggc2luY2UgUmVhY3Qgd29uJ3QgcmUtdXNlIHRoZVxuICAgICAgICAvLyBSZWFjdEVsZW1lbnQgc2luY2UgaXQncyBpZGVudGl0eSBjaGFuZ2VzIHdpdGggZWFjaCBuZXdcbiAgICAgICAgLy8gUmVhY3QuY3JlYXRlRWxlbWVudCBjYWxsLiAgV2Uga2VlcCB0aGlzIHNvIGZvbGtzIGNhbiB1c2VcbiAgICAgICAgLy8gYDxSb3V0ZSBDb21wb25lbnQ9ey4uLn0+YCBpbiBgPFJvdXRlcz5gIGJ1dCBnZW5lcmFsbHkgYENvbXBvbmVudGBcbiAgICAgICAgLy8gdXNhZ2UgaXMgb25seSBhZHZpc2VkIGluIGBSb3V0ZXJQcm92aWRlcmAgd2hlbiB3ZSBjYW4gY29udmVydCBpdCB0b1xuICAgICAgICAvLyBgZWxlbWVudGAgYWhlYWQgb2YgdGltZS5cbiAgICAgICAgY2hpbGRyZW4gPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChtYXRjaC5yb3V0ZS5Db21wb25lbnQsIG51bGwpO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaC5yb3V0ZS5lbGVtZW50KSB7XG4gICAgICAgIGNoaWxkcmVuID0gbWF0Y2gucm91dGUuZWxlbWVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkcmVuID0gb3V0bGV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlbmRlcmVkUm91dGUsIHtcbiAgICAgICAgbWF0Y2g6IG1hdGNoLFxuICAgICAgICByb3V0ZUNvbnRleHQ6IHtcbiAgICAgICAgICBvdXRsZXQsXG4gICAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgICBpc0RhdGFSb3V0ZTogZGF0YVJvdXRlclN0YXRlICE9IG51bGxcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8vIE9ubHkgd3JhcCBpbiBhbiBlcnJvciBib3VuZGFyeSB3aXRoaW4gZGF0YSByb3V0ZXIgdXNhZ2VzIHdoZW4gd2UgaGF2ZSBhblxuICAgIC8vIEVycm9yQm91bmRhcnkvZXJyb3JFbGVtZW50IG9uIHRoaXMgcm91dGUuICBPdGhlcndpc2UgbGV0IGl0IGJ1YmJsZSB1cCB0b1xuICAgIC8vIGFuIGFuY2VzdG9yIEVycm9yQm91bmRhcnkvZXJyb3JFbGVtZW50XG4gICAgcmV0dXJuIGRhdGFSb3V0ZXJTdGF0ZSAmJiAobWF0Y2gucm91dGUuRXJyb3JCb3VuZGFyeSB8fCBtYXRjaC5yb3V0ZS5lcnJvckVsZW1lbnQgfHwgaW5kZXggPT09IDApID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVuZGVyRXJyb3JCb3VuZGFyeSwge1xuICAgICAgbG9jYXRpb246IGRhdGFSb3V0ZXJTdGF0ZS5sb2NhdGlvbixcbiAgICAgIHJldmFsaWRhdGlvbjogZGF0YVJvdXRlclN0YXRlLnJldmFsaWRhdGlvbixcbiAgICAgIGNvbXBvbmVudDogZXJyb3JFbGVtZW50LFxuICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgY2hpbGRyZW46IGdldENoaWxkcmVuKCksXG4gICAgICByb3V0ZUNvbnRleHQ6IHtcbiAgICAgICAgb3V0bGV0OiBudWxsLFxuICAgICAgICBtYXRjaGVzLFxuICAgICAgICBpc0RhdGFSb3V0ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pIDogZ2V0Q2hpbGRyZW4oKTtcbiAgfSwgbnVsbCk7XG59XG52YXIgRGF0YVJvdXRlckhvb2sgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKERhdGFSb3V0ZXJIb29rKSB7XG4gIERhdGFSb3V0ZXJIb29rW1wiVXNlQmxvY2tlclwiXSA9IFwidXNlQmxvY2tlclwiO1xuICBEYXRhUm91dGVySG9va1tcIlVzZVJldmFsaWRhdG9yXCJdID0gXCJ1c2VSZXZhbGlkYXRvclwiO1xuICBEYXRhUm91dGVySG9va1tcIlVzZU5hdmlnYXRlU3RhYmxlXCJdID0gXCJ1c2VOYXZpZ2F0ZVwiO1xuICByZXR1cm4gRGF0YVJvdXRlckhvb2s7XG59KERhdGFSb3V0ZXJIb29rIHx8IHt9KTtcbnZhciBEYXRhUm91dGVyU3RhdGVIb29rID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChEYXRhUm91dGVyU3RhdGVIb29rKSB7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VCbG9ja2VyXCJdID0gXCJ1c2VCbG9ja2VyXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VMb2FkZXJEYXRhXCJdID0gXCJ1c2VMb2FkZXJEYXRhXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VBY3Rpb25EYXRhXCJdID0gXCJ1c2VBY3Rpb25EYXRhXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VSb3V0ZUVycm9yXCJdID0gXCJ1c2VSb3V0ZUVycm9yXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VOYXZpZ2F0aW9uXCJdID0gXCJ1c2VOYXZpZ2F0aW9uXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VSb3V0ZUxvYWRlckRhdGFcIl0gPSBcInVzZVJvdXRlTG9hZGVyRGF0YVwiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlTWF0Y2hlc1wiXSA9IFwidXNlTWF0Y2hlc1wiO1xuICBEYXRhUm91dGVyU3RhdGVIb29rW1wiVXNlUmV2YWxpZGF0b3JcIl0gPSBcInVzZVJldmFsaWRhdG9yXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VOYXZpZ2F0ZVN0YWJsZVwiXSA9IFwidXNlTmF2aWdhdGVcIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZVJvdXRlSWRcIl0gPSBcInVzZVJvdXRlSWRcIjtcbiAgcmV0dXJuIERhdGFSb3V0ZXJTdGF0ZUhvb2s7XG59KERhdGFSb3V0ZXJTdGF0ZUhvb2sgfHwge30pO1xuZnVuY3Rpb24gZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkge1xuICByZXR1cm4gaG9va05hbWUgKyBcIiBtdXN0IGJlIHVzZWQgd2l0aGluIGEgZGF0YSByb3V0ZXIuICBTZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vcm91dGVycy9waWNraW5nLWEtcm91dGVyLlwiO1xufVxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlckNvbnRleHQoaG9va05hbWUpIHtcbiAgbGV0IGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoRGF0YVJvdXRlckNvbnRleHQpO1xuICAhY3R4ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBjdHg7XG59XG5mdW5jdGlvbiB1c2VEYXRhUm91dGVyU3RhdGUoaG9va05hbWUpIHtcbiAgbGV0IHN0YXRlID0gUmVhY3QudXNlQ29udGV4dChEYXRhUm91dGVyU3RhdGVDb250ZXh0KTtcbiAgIXN0YXRlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHVzZVJvdXRlQ29udGV4dChob29rTmFtZSkge1xuICBsZXQgcm91dGUgPSBSZWFjdC51c2VDb250ZXh0KFJvdXRlQ29udGV4dCk7XG4gICFyb3V0ZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gcm91dGU7XG59XG5cbi8vIEludGVybmFsIHZlcnNpb24gd2l0aCBob29rTmFtZS1hd2FyZSBkZWJ1Z2dpbmdcbmZ1bmN0aW9uIHVzZUN1cnJlbnRSb3V0ZUlkKGhvb2tOYW1lKSB7XG4gIGxldCByb3V0ZSA9IHVzZVJvdXRlQ29udGV4dChob29rTmFtZSk7XG4gIGxldCB0aGlzUm91dGUgPSByb3V0ZS5tYXRjaGVzW3JvdXRlLm1hdGNoZXMubGVuZ3RoIC0gMV07XG4gICF0aGlzUm91dGUucm91dGUuaWQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBob29rTmFtZSArIFwiIGNhbiBvbmx5IGJlIHVzZWQgb24gcm91dGVzIHRoYXQgY29udGFpbiBhIHVuaXF1ZSBcXFwiaWRcXFwiXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIHJldHVybiB0aGlzUm91dGUucm91dGUuaWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgSUQgZm9yIHRoZSBuZWFyZXN0IGNvbnRleHR1YWwgcm91dGVcbiAqL1xuZnVuY3Rpb24gdXNlUm91dGVJZCgpIHtcbiAgcmV0dXJuIHVzZUN1cnJlbnRSb3V0ZUlkKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUm91dGVJZCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBuYXZpZ2F0aW9uLCBkZWZhdWx0aW5nIHRvIGFuIFwiaWRsZVwiIG5hdmlnYXRpb24gd2hlblxuICogbm8gbmF2aWdhdGlvbiBpcyBpbiBwcm9ncmVzc1xuICovXG5mdW5jdGlvbiB1c2VOYXZpZ2F0aW9uKCkge1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VOYXZpZ2F0aW9uKTtcbiAgcmV0dXJuIHN0YXRlLm5hdmlnYXRpb247XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJldmFsaWRhdGUgZnVuY3Rpb24gZm9yIG1hbnVhbGx5IHRyaWdnZXJpbmcgcmV2YWxpZGF0aW9uLCBhcyB3ZWxsXG4gKiBhcyB0aGUgY3VycmVudCBzdGF0ZSBvZiBhbnkgbWFudWFsIHJldmFsaWRhdGlvbnNcbiAqL1xuZnVuY3Rpb24gdXNlUmV2YWxpZGF0b3IoKSB7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZVJldmFsaWRhdG9yKTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlUmV2YWxpZGF0b3IpO1xuICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJldmFsaWRhdGU6IGRhdGFSb3V0ZXJDb250ZXh0LnJvdXRlci5yZXZhbGlkYXRlLFxuICAgIHN0YXRlOiBzdGF0ZS5yZXZhbGlkYXRpb25cbiAgfSksIFtkYXRhUm91dGVyQ29udGV4dC5yb3V0ZXIucmV2YWxpZGF0ZSwgc3RhdGUucmV2YWxpZGF0aW9uXSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYWN0aXZlIHJvdXRlIG1hdGNoZXMsIHVzZWZ1bCBmb3IgYWNjZXNzaW5nIGxvYWRlckRhdGEgZm9yXG4gKiBwYXJlbnQvY2hpbGQgcm91dGVzIG9yIHRoZSByb3V0ZSBcImhhbmRsZVwiIHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIHVzZU1hdGNoZXMoKSB7XG4gIGxldCB7XG4gICAgbWF0Y2hlcyxcbiAgICBsb2FkZXJEYXRhXG4gIH0gPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VNYXRjaGVzKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gbWF0Y2hlcy5tYXAobSA9PiBVTlNBRkVfY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gobSwgbG9hZGVyRGF0YSkpLCBbbWF0Y2hlcywgbG9hZGVyRGF0YV0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGxvYWRlciBkYXRhIGZvciB0aGUgbmVhcmVzdCBhbmNlc3RvciBSb3V0ZSBsb2FkZXJcbiAqL1xuZnVuY3Rpb24gdXNlTG9hZGVyRGF0YSgpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlTG9hZGVyRGF0YSk7XG4gIGxldCByb3V0ZUlkID0gdXNlQ3VycmVudFJvdXRlSWQoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VMb2FkZXJEYXRhKTtcbiAgaWYgKHN0YXRlLmVycm9ycyAmJiBzdGF0ZS5lcnJvcnNbcm91dGVJZF0gIT0gbnVsbCkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJZb3UgY2Fubm90IGB1c2VMb2FkZXJEYXRhYCBpbiBhbiBlcnJvckVsZW1lbnQgKHJvdXRlSWQ6IFwiICsgcm91dGVJZCArIFwiKVwiKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sb2FkZXJEYXRhW3JvdXRlSWRdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGxvYWRlckRhdGEgZm9yIHRoZSBnaXZlbiByb3V0ZUlkXG4gKi9cbmZ1bmN0aW9uIHVzZVJvdXRlTG9hZGVyRGF0YShyb3V0ZUlkKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZVJvdXRlTG9hZGVyRGF0YSk7XG4gIHJldHVybiBzdGF0ZS5sb2FkZXJEYXRhW3JvdXRlSWRdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGFjdGlvbiBkYXRhIGZvciB0aGUgbmVhcmVzdCBhbmNlc3RvciBSb3V0ZSBhY3Rpb25cbiAqL1xuZnVuY3Rpb24gdXNlQWN0aW9uRGF0YSgpIHtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlQWN0aW9uRGF0YSk7XG4gIGxldCByb3V0ZUlkID0gdXNlQ3VycmVudFJvdXRlSWQoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VMb2FkZXJEYXRhKTtcbiAgcmV0dXJuIHN0YXRlLmFjdGlvbkRhdGEgPyBzdGF0ZS5hY3Rpb25EYXRhW3JvdXRlSWRdIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG5lYXJlc3QgYW5jZXN0b3IgUm91dGUgZXJyb3IsIHdoaWNoIGNvdWxkIGJlIGEgbG9hZGVyL2FjdGlvblxuICogZXJyb3Igb3IgYSByZW5kZXIgZXJyb3IuICBUaGlzIGlzIGludGVuZGVkIHRvIGJlIGNhbGxlZCBmcm9tIHlvdXJcbiAqIEVycm9yQm91bmRhcnkvZXJyb3JFbGVtZW50IHRvIGRpc3BsYXkgYSBwcm9wZXIgZXJyb3IgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gdXNlUm91dGVFcnJvcigpIHtcbiAgdmFyIF9zdGF0ZSRlcnJvcnM7XG4gIGxldCBlcnJvciA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVFcnJvckNvbnRleHQpO1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VSb3V0ZUVycm9yKTtcbiAgbGV0IHJvdXRlSWQgPSB1c2VDdXJyZW50Um91dGVJZChEYXRhUm91dGVyU3RhdGVIb29rLlVzZVJvdXRlRXJyb3IpO1xuXG4gIC8vIElmIHRoaXMgd2FzIGEgcmVuZGVyIGVycm9yLCB3ZSBwdXQgaXQgaW4gYSBSb3V0ZUVycm9yIGNvbnRleHQgaW5zaWRlXG4gIC8vIG9mIFJlbmRlckVycm9yQm91bmRhcnlcbiAgaWYgKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlIGxvb2sgZm9yIGVycm9ycyBmcm9tIG91ciBkYXRhIHJvdXRlciBzdGF0ZVxuICByZXR1cm4gKF9zdGF0ZSRlcnJvcnMgPSBzdGF0ZS5lcnJvcnMpID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZXJyb3JzW3JvdXRlSWRdO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGhhcHB5LXBhdGggZGF0YSBmcm9tIHRoZSBuZWFyZXN0IGFuY2VzdG9yIGA8QXdhaXQgLz5gIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHVzZUFzeW5jVmFsdWUoKSB7XG4gIGxldCB2YWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoQXdhaXRDb250ZXh0KTtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZS5fZGF0YTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBlcnJvciBmcm9tIHRoZSBuZWFyZXN0IGFuY2VzdG9yIGA8QXdhaXQgLz5gIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHVzZUFzeW5jRXJyb3IoKSB7XG4gIGxldCB2YWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoQXdhaXRDb250ZXh0KTtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyB2b2lkIDAgOiB2YWx1ZS5fZXJyb3I7XG59XG5sZXQgYmxvY2tlcklkID0gMDtcblxuLyoqXG4gKiBBbGxvdyB0aGUgYXBwbGljYXRpb24gdG8gYmxvY2sgbmF2aWdhdGlvbnMgd2l0aGluIHRoZSBTUEEgYW5kIHByZXNlbnQgdGhlXG4gKiB1c2VyIGEgY29uZmlybWF0aW9uIGRpYWxvZyB0byBjb25maXJtIHRoZSBuYXZpZ2F0aW9uLiAgTW9zdGx5IHVzZWQgdG8gYXZvaWRcbiAqIHVzaW5nIGhhbGYtZmlsbGVkIGZvcm0gZGF0YS4gIFRoaXMgZG9lcyBub3QgaGFuZGxlIGhhcmQtcmVsb2FkcyBvclxuICogY3Jvc3Mtb3JpZ2luIG5hdmlnYXRpb25zLlxuICovXG5mdW5jdGlvbiB1c2VCbG9ja2VyKHNob3VsZEJsb2NrKSB7XG4gIGxldCB7XG4gICAgcm91dGVyLFxuICAgIGJhc2VuYW1lXG4gIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VCbG9ja2VyKTtcbiAgbGV0IHN0YXRlID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlQmxvY2tlcik7XG4gIGxldCBbYmxvY2tlcktleSwgc2V0QmxvY2tlcktleV0gPSBSZWFjdC51c2VTdGF0ZShcIlwiKTtcbiAgbGV0IGJsb2NrZXJGdW5jdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGFyZyA9PiB7XG4gICAgaWYgKHR5cGVvZiBzaG91bGRCbG9jayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gISFzaG91bGRCbG9jaztcbiAgICB9XG4gICAgaWYgKGJhc2VuYW1lID09PSBcIi9cIikge1xuICAgICAgcmV0dXJuIHNob3VsZEJsb2NrKGFyZyk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhleSBwcm92aWRlZCB1cyBhIGZ1bmN0aW9uIGFuZCB3ZSd2ZSBnb3QgYW4gYWN0aXZlIGJhc2VuYW1lLCBzdHJpcFxuICAgIC8vIGl0IGZyb20gdGhlIGxvY2F0aW9ucyB3ZSBleHBvc2UgdG8gdGhlIHVzZXIgdG8gbWF0Y2ggdGhlIGJlaGF2aW9yIG9mXG4gICAgLy8gdXNlTG9jYXRpb25cbiAgICBsZXQge1xuICAgICAgY3VycmVudExvY2F0aW9uLFxuICAgICAgbmV4dExvY2F0aW9uLFxuICAgICAgaGlzdG9yeUFjdGlvblxuICAgIH0gPSBhcmc7XG4gICAgcmV0dXJuIHNob3VsZEJsb2NrKHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbjogX2V4dGVuZHMoe30sIGN1cnJlbnRMb2NhdGlvbiwge1xuICAgICAgICBwYXRobmFtZTogc3RyaXBCYXNlbmFtZShjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUsIGJhc2VuYW1lKSB8fCBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWVcbiAgICAgIH0pLFxuICAgICAgbmV4dExvY2F0aW9uOiBfZXh0ZW5kcyh7fSwgbmV4dExvY2F0aW9uLCB7XG4gICAgICAgIHBhdGhuYW1lOiBzdHJpcEJhc2VuYW1lKG5leHRMb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IG5leHRMb2NhdGlvbi5wYXRobmFtZVxuICAgICAgfSksXG4gICAgICBoaXN0b3J5QWN0aW9uXG4gICAgfSk7XG4gIH0sIFtiYXNlbmFtZSwgc2hvdWxkQmxvY2tdKTtcblxuICAvLyBUaGlzIGVmZmVjdCBpcyBpbiBjaGFyZ2Ugb2YgYmxvY2tlciBrZXkgYXNzaWdubWVudCBhbmQgZGVsZXRpb24gKHdoaWNoIGlzXG4gIC8vIHRpZ2h0bHkgY291cGxlZCB0byB0aGUga2V5KVxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBrZXkgPSBTdHJpbmcoKytibG9ja2VySWQpO1xuICAgIHNldEJsb2NrZXJLZXkoa2V5KTtcbiAgICByZXR1cm4gKCkgPT4gcm91dGVyLmRlbGV0ZUJsb2NrZXIoa2V5KTtcbiAgfSwgW3JvdXRlcl0pO1xuXG4gIC8vIFRoaXMgZWZmZWN0IGhhbmRsZXMgYXNzaWduaW5nIHRoZSBibG9ja2VyRnVuY3Rpb24uICBUaGlzIGlzIHRvIGhhbmRsZVxuICAvLyB1bnN0YWJsZSBibG9ja2VyIGZ1bmN0aW9uIGlkZW50aXRpZXMsIGFuZCBoYXBwZW5zIG9ubHkgYWZ0ZXIgdGhlIHByaW9yXG4gIC8vIGVmZmVjdCBzbyB3ZSBkb24ndCBnZXQgYW4gb3JwaGFuZWQgYmxvY2tlckZ1bmN0aW9uIGluIHRoZSByb3V0ZXIgd2l0aCBhXG4gIC8vIGtleSBvZiBcIlwiLiAgVW50aWwgdGhlbiB3ZSBqdXN0IGhhdmUgdGhlIElETEVfQkxPQ0tFUi5cbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYmxvY2tlcktleSAhPT0gXCJcIikge1xuICAgICAgcm91dGVyLmdldEJsb2NrZXIoYmxvY2tlcktleSwgYmxvY2tlckZ1bmN0aW9uKTtcbiAgICB9XG4gIH0sIFtyb3V0ZXIsIGJsb2NrZXJLZXksIGJsb2NrZXJGdW5jdGlvbl0pO1xuXG4gIC8vIFByZWZlciB0aGUgYmxvY2tlciBmcm9tIGBzdGF0ZWAgbm90IGByb3V0ZXIuc3RhdGVgIHNpbmNlIERhdGFSb3V0ZXJDb250ZXh0XG4gIC8vIGlzIG1lbW9pemVkIHNvIHRoaXMgZW5zdXJlcyB3ZSB1cGRhdGUgb24gYmxvY2tlciBzdGF0ZSB1cGRhdGVzXG4gIHJldHVybiBibG9ja2VyS2V5ICYmIHN0YXRlLmJsb2NrZXJzLmhhcyhibG9ja2VyS2V5KSA/IHN0YXRlLmJsb2NrZXJzLmdldChibG9ja2VyS2V5KSA6IElETEVfQkxPQ0tFUjtcbn1cblxuLyoqXG4gKiBTdGFibGUgdmVyc2lvbiBvZiB1c2VOYXZpZ2F0ZSB0aGF0IGlzIHVzZWQgd2hlbiB3ZSBhcmUgaW4gdGhlIGNvbnRleHQgb2ZcbiAqIGEgUm91dGVyUHJvdmlkZXIuXG4gKi9cbmZ1bmN0aW9uIHVzZU5hdmlnYXRlU3RhYmxlKCkge1xuICBsZXQge1xuICAgIHJvdXRlclxuICB9ID0gdXNlRGF0YVJvdXRlckNvbnRleHQoRGF0YVJvdXRlckhvb2suVXNlTmF2aWdhdGVTdGFibGUpO1xuICBsZXQgaWQgPSB1c2VDdXJyZW50Um91dGVJZChEYXRhUm91dGVyU3RhdGVIb29rLlVzZU5hdmlnYXRlU3RhYmxlKTtcbiAgbGV0IGFjdGl2ZVJlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGFjdGl2ZVJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgfSk7XG4gIGxldCBuYXZpZ2F0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh0bywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoYWN0aXZlUmVmLmN1cnJlbnQsIG5hdmlnYXRlRWZmZWN0V2FybmluZykgOiB2b2lkIDA7XG5cbiAgICAvLyBTaG9ydCBjaXJjdWl0IGhlcmUgc2luY2UgaWYgdGhpcyBoYXBwZW5zIG9uIGZpcnN0IHJlbmRlciB0aGUgbmF2aWdhdGVcbiAgICAvLyBpcyB1c2VsZXNzIGJlY2F1c2Ugd2UgaGF2ZW4ndCB3aXJlZCB1cCBvdXIgcm91dGVyIHN1YnNjcmliZXIgeWV0XG4gICAgaWYgKCFhY3RpdmVSZWYuY3VycmVudCkgcmV0dXJuO1xuICAgIGlmICh0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHJvdXRlci5uYXZpZ2F0ZSh0byk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvdXRlci5uYXZpZ2F0ZSh0bywgX2V4dGVuZHMoe1xuICAgICAgICBmcm9tUm91dGVJZDogaWRcbiAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICB9XG4gIH0sIFtyb3V0ZXIsIGlkXSk7XG4gIHJldHVybiBuYXZpZ2F0ZTtcbn1cbmNvbnN0IGFscmVhZHlXYXJuZWQgPSB7fTtcbmZ1bmN0aW9uIHdhcm5pbmdPbmNlKGtleSwgY29uZCwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmQgJiYgIWFscmVhZHlXYXJuZWRba2V5XSkge1xuICAgIGFscmVhZHlXYXJuZWRba2V5XSA9IHRydWU7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcoZmFsc2UsIG1lc3NhZ2UpIDogdm9pZCAwO1xuICB9XG59XG5cbi8qKlxuICBXZWJwYWNrICsgUmVhY3QgMTcgZmFpbHMgdG8gY29tcGlsZSBvbiBhbnkgb2YgdGhlIGZvbGxvd2luZyBiZWNhdXNlIHdlYnBhY2tcbiAgY29tcGxhaW5zIHRoYXQgYHN0YXJ0VHJhbnNpdGlvbmAgZG9lc24ndCBleGlzdCBpbiBgUmVhY3RgOlxuICAqIGltcG9ydCB7IHN0YXJ0VHJhbnNpdGlvbiB9IGZyb20gXCJyZWFjdFwiXG4gICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcbiAgICBcInN0YXJ0VHJhbnNpdGlvblwiIGluIFJlYWN0ID8gUmVhY3Quc3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxuICAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gZnJvbSBcInJlYWN0XCI7XG4gICAgXCJzdGFydFRyYW5zaXRpb25cIiBpbiBSZWFjdCA/IFJlYWN0W1wic3RhcnRUcmFuc2l0aW9uXCJdKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxuXG4gIE1vdmluZyBpdCB0byBhIGNvbnN0YW50IHN1Y2ggYXMgdGhlIGZvbGxvd2luZyBzb2x2ZXMgdGhlIFdlYnBhY2svUmVhY3QgMTcgaXNzdWU6XG4gICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBmcm9tIFwicmVhY3RcIjtcbiAgICBjb25zdCBTVEFSVF9UUkFOU0lUSU9OID0gXCJzdGFydFRyYW5zaXRpb25cIjtcbiAgICBTVEFSVF9UUkFOU0lUSU9OIGluIFJlYWN0ID8gUmVhY3RbU1RBUlRfVFJBTlNJVElPTl0oKCkgPT4gc2V0U3RhdGUoKSkgOiBzZXRTdGF0ZSgpXG5cbiAgSG93ZXZlciwgdGhhdCBpbnRyb2R1Y2VzIHdlYnBhY2svdGVyc2VyIG1pbmlmaWNhdGlvbiBpc3N1ZXMgaW4gcHJvZHVjdGlvbiBidWlsZHNcbiAgaW4gUmVhY3QgMTggd2hlcmUgbWluaWZpY2F0aW9uL29iZnVzY2F0aW9uIGVuZHMgdXAgcmVtb3ZpbmcgdGhlIGNhbGwgb2ZcbiAgUmVhY3Quc3RhcnRUcmFuc2l0aW9uIGVudGlyZWx5IGZyb20gdGhlIGZpcnN0IGhhbGYgb2YgdGhlIHRlcm5hcnkuICBHcmFiYmluZ1xuICB0aGlzIGV4cG9ydGVkIHJlZmVyZW5jZSBvbmNlIHVwIGZyb250IHJlc29sdmVzIHRoYXQgaXNzdWUuXG5cbiAgU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vcmVhY3Qtcm91dGVyL2lzc3Vlcy8xMDU3OVxuKi9cbmNvbnN0IFNUQVJUX1RSQU5TSVRJT04gPSBcInN0YXJ0VHJhbnNpdGlvblwiO1xuY29uc3Qgc3RhcnRUcmFuc2l0aW9uSW1wbCA9IFJlYWN0W1NUQVJUX1RSQU5TSVRJT05dO1xuXG4vKipcbiAqIEdpdmVuIGEgUmVtaXggUm91dGVyIGluc3RhbmNlLCByZW5kZXIgdGhlIGFwcHJvcHJpYXRlIFVJXG4gKi9cbmZ1bmN0aW9uIFJvdXRlclByb3ZpZGVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBmYWxsYmFja0VsZW1lbnQsXG4gICAgcm91dGVyLFxuICAgIGZ1dHVyZVxuICB9ID0gX3JlZjtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0LnVzZVN0YXRlKHJvdXRlci5zdGF0ZSk7XG4gIGxldCB7XG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uXG4gIH0gPSBmdXR1cmUgfHwge307XG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5ld1N0YXRlID0+IHtcbiAgICBpZiAodjdfc3RhcnRUcmFuc2l0aW9uICYmIHN0YXJ0VHJhbnNpdGlvbkltcGwpIHtcbiAgICAgIHN0YXJ0VHJhbnNpdGlvbkltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFN0YXRlSW1wbChuZXdTdGF0ZSk7XG4gICAgfVxuICB9LCBbc2V0U3RhdGVJbXBsLCB2N19zdGFydFRyYW5zaXRpb25dKTtcblxuICAvLyBOZWVkIHRvIHVzZSBhIGxheW91dCBlZmZlY3QgaGVyZSBzbyB3ZSBhcmUgc3Vic2NyaWJlZCBlYXJseSBlbm91Z2ggdG9cbiAgLy8gcGljayB1cCBvbiBhbnkgcmVuZGVyLWRyaXZlbiByZWRpcmVjdHMvbmF2aWdhdGlvbnMgKHVzZUVmZmVjdC88TmF2aWdhdGU+KVxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gcm91dGVyLnN1YnNjcmliZShzZXRTdGF0ZSksIFtyb3V0ZXIsIHNldFN0YXRlXSk7XG4gIGxldCBuYXZpZ2F0b3IgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgY3JlYXRlSHJlZjogcm91dGVyLmNyZWF0ZUhyZWYsXG4gICAgICBlbmNvZGVMb2NhdGlvbjogcm91dGVyLmVuY29kZUxvY2F0aW9uLFxuICAgICAgZ286IG4gPT4gcm91dGVyLm5hdmlnYXRlKG4pLFxuICAgICAgcHVzaDogKHRvLCBzdGF0ZSwgb3B0cykgPT4gcm91dGVyLm5hdmlnYXRlKHRvLCB7XG4gICAgICAgIHN0YXRlLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucHJldmVudFNjcm9sbFJlc2V0XG4gICAgICB9KSxcbiAgICAgIHJlcGxhY2U6ICh0bywgc3RhdGUsIG9wdHMpID0+IHJvdXRlci5uYXZpZ2F0ZSh0bywge1xuICAgICAgICByZXBsYWNlOiB0cnVlLFxuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgfSlcbiAgICB9O1xuICB9LCBbcm91dGVyXSk7XG4gIGxldCBiYXNlbmFtZSA9IHJvdXRlci5iYXNlbmFtZSB8fCBcIi9cIjtcbiAgbGV0IGRhdGFSb3V0ZXJDb250ZXh0ID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIHJvdXRlcixcbiAgICBuYXZpZ2F0b3IsXG4gICAgc3RhdGljOiBmYWxzZSxcbiAgICBiYXNlbmFtZVxuICB9KSwgW3JvdXRlciwgbmF2aWdhdG9yLCBiYXNlbmFtZV0pO1xuXG4gIC8vIFRoZSBmcmFnbWVudCBhbmQge251bGx9IGhlcmUgYXJlIGltcG9ydGFudCEgIFdlIG5lZWQgdGhlbSB0byBrZWVwIFJlYWN0IDE4J3NcbiAgLy8gdXNlSWQgaGFwcHkgd2hlbiB3ZSBhcmUgc2VydmVyLXJlbmRlcmluZyBzaW5jZSB3ZSBtYXkgaGF2ZSBhIDxzY3JpcHQ+IGhlcmVcbiAgLy8gY29udGFpbmluZyB0aGUgaHlkcmF0ZWQgc2VydmVyLXNpZGUgc3RhdGljQ29udGV4dCAoZnJvbSBTdGF0aWNSb3V0ZXJQcm92aWRlcikuXG4gIC8vIHVzZUlkIHJlbGllcyBvbiB0aGUgY29tcG9uZW50IHRyZWUgc3RydWN0dXJlIHRvIGdlbmVyYXRlIGRldGVybWluaXN0aWMgaWQnc1xuICAvLyBzbyB3ZSBuZWVkIHRvIGVuc3VyZSBpdCByZW1haW5zIHRoZSBzYW1lIG9uIHRoZSBjbGllbnQgZXZlbiB0aG91Z2hcbiAgLy8gd2UgZG9uJ3QgbmVlZCB0aGUgPHNjcmlwdD4gdGFnXG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZGF0YVJvdXRlckNvbnRleHRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlclN0YXRlQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBzdGF0ZVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICBiYXNlbmFtZTogYmFzZW5hbWUsXG4gICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5oaXN0b3J5QWN0aW9uLFxuICAgIG5hdmlnYXRvcjogbmF2aWdhdG9yXG4gIH0sIHN0YXRlLmluaXRpYWxpemVkID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlcywge1xuICAgIHJvdXRlczogcm91dGVyLnJvdXRlcyxcbiAgICBzdGF0ZTogc3RhdGVcbiAgfSkgOiBmYWxsYmFja0VsZW1lbnQpKSksIG51bGwpO1xufVxuZnVuY3Rpb24gRGF0YVJvdXRlcyhfcmVmMikge1xuICBsZXQge1xuICAgIHJvdXRlcyxcbiAgICBzdGF0ZVxuICB9ID0gX3JlZjI7XG4gIHJldHVybiB1c2VSb3V0ZXNJbXBsKHJvdXRlcywgdW5kZWZpbmVkLCBzdGF0ZSk7XG59XG4vKipcbiAqIEEgYDxSb3V0ZXI+YCB0aGF0IHN0b3JlcyBhbGwgZW50cmllcyBpbiBtZW1vcnkuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9yb3V0ZXItY29tcG9uZW50cy9tZW1vcnktcm91dGVyXG4gKi9cbmZ1bmN0aW9uIE1lbW9yeVJvdXRlcihfcmVmMykge1xuICBsZXQge1xuICAgIGJhc2VuYW1lLFxuICAgIGNoaWxkcmVuLFxuICAgIGluaXRpYWxFbnRyaWVzLFxuICAgIGluaXRpYWxJbmRleCxcbiAgICBmdXR1cmVcbiAgfSA9IF9yZWYzO1xuICBsZXQgaGlzdG9yeVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBpZiAoaGlzdG9yeVJlZi5jdXJyZW50ID09IG51bGwpIHtcbiAgICBoaXN0b3J5UmVmLmN1cnJlbnQgPSBjcmVhdGVNZW1vcnlIaXN0b3J5KHtcbiAgICAgIGluaXRpYWxFbnRyaWVzLFxuICAgICAgaW5pdGlhbEluZGV4LFxuICAgICAgdjVDb21wYXQ6IHRydWVcbiAgICB9KTtcbiAgfVxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuICBsZXQge1xuICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxuICB9ID0gZnV0dXJlIHx8IHt9O1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhuZXdTdGF0ZSA9PiB7XG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uICYmIHN0YXJ0VHJhbnNpdGlvbkltcGwgPyBzdGFydFRyYW5zaXRpb25JbXBsKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpIDogc2V0U3RhdGVJbXBsKG5ld1N0YXRlKTtcbiAgfSwgW3NldFN0YXRlSW1wbCwgdjdfc3RhcnRUcmFuc2l0aW9uXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5LCBzZXRTdGF0ZV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XG4gICAgYmFzZW5hbWU6IGJhc2VuYW1lLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmFjdGlvbixcbiAgICBuYXZpZ2F0b3I6IGhpc3RvcnlcbiAgfSk7XG59XG4vKipcbiAqIENoYW5nZXMgdGhlIGN1cnJlbnQgbG9jYXRpb24uXG4gKlxuICogTm90ZTogVGhpcyBBUEkgaXMgbW9zdGx5IHVzZWZ1bCBpbiBSZWFjdC5Db21wb25lbnQgc3ViY2xhc3NlcyB0aGF0IGFyZSBub3RcbiAqIGFibGUgdG8gdXNlIGhvb2tzLiBJbiBmdW5jdGlvbmFsIGNvbXBvbmVudHMsIHdlIHJlY29tbWVuZCB5b3UgdXNlIHRoZVxuICogYHVzZU5hdmlnYXRlYCBob29rIGluc3RlYWQuXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS9jb21wb25lbnRzL25hdmlnYXRlXG4gKi9cbmZ1bmN0aW9uIE5hdmlnYXRlKF9yZWY0KSB7XG4gIGxldCB7XG4gICAgdG8sXG4gICAgcmVwbGFjZSxcbiAgICBzdGF0ZSxcbiAgICByZWxhdGl2ZVxuICB9ID0gX3JlZjQ7XG4gICF1c2VJblJvdXRlckNvbnRleHQoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIC8vIFRPRE86IFRoaXMgZXJyb3IgaXMgcHJvYmFibHkgYmVjYXVzZSB0aGV5IHNvbWVob3cgaGF2ZSAyIHZlcnNpb25zIG9mXG4gIC8vIHRoZSByb3V0ZXIgbG9hZGVkLiBXZSBjYW4gaGVscCB0aGVtIHVuZGVyc3RhbmQgaG93IHRvIGF2b2lkIHRoYXQuXG4gIFwiPE5hdmlnYXRlPiBtYXkgYmUgdXNlZCBvbmx5IGluIHRoZSBjb250ZXh0IG9mIGEgPFJvdXRlcj4gY29tcG9uZW50LlwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyghUmVhY3QudXNlQ29udGV4dChOYXZpZ2F0aW9uQ29udGV4dCkuc3RhdGljLCBcIjxOYXZpZ2F0ZT4gbXVzdCBub3QgYmUgdXNlZCBvbiB0aGUgaW5pdGlhbCByZW5kZXIgaW4gYSA8U3RhdGljUm91dGVyPi4gXCIgKyBcIlRoaXMgaXMgYSBuby1vcCwgYnV0IHlvdSBzaG91bGQgbW9kaWZ5IHlvdXIgY29kZSBzbyB0aGUgPE5hdmlnYXRlPiBpcyBcIiArIFwib25seSBldmVyIHJlbmRlcmVkIGluIHJlc3BvbnNlIHRvIHNvbWUgdXNlciBpbnRlcmFjdGlvbiBvciBzdGF0ZSBjaGFuZ2UuXCIpIDogdm9pZCAwO1xuICBsZXQge1xuICAgIG1hdGNoZXNcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoUm91dGVDb250ZXh0KTtcbiAgbGV0IHtcbiAgICBwYXRobmFtZTogbG9jYXRpb25QYXRobmFtZVxuICB9ID0gdXNlTG9jYXRpb24oKTtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcblxuICAvLyBSZXNvbHZlIHRoZSBwYXRoIG91dHNpZGUgb2YgdGhlIGVmZmVjdCBzbyB0aGF0IHdoZW4gZWZmZWN0cyBydW4gdHdpY2UgaW5cbiAgLy8gU3RyaWN0TW9kZSB0aGV5IG5hdmlnYXRlIHRvIHRoZSBzYW1lIHBsYWNlXG4gIGxldCBwYXRoID0gcmVzb2x2ZVRvKHRvLCBVTlNBRkVfZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMobWF0Y2hlcykubWFwKG1hdGNoID0+IG1hdGNoLnBhdGhuYW1lQmFzZSksIGxvY2F0aW9uUGF0aG5hbWUsIHJlbGF0aXZlID09PSBcInBhdGhcIik7XG4gIGxldCBqc29uUGF0aCA9IEpTT04uc3RyaW5naWZ5KHBhdGgpO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4gbmF2aWdhdGUoSlNPTi5wYXJzZShqc29uUGF0aCksIHtcbiAgICByZXBsYWNlLFxuICAgIHN0YXRlLFxuICAgIHJlbGF0aXZlXG4gIH0pLCBbbmF2aWdhdGUsIGpzb25QYXRoLCByZWxhdGl2ZSwgcmVwbGFjZSwgc3RhdGVdKTtcbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIFJlbmRlcnMgdGhlIGNoaWxkIHJvdXRlJ3MgZWxlbWVudCwgaWYgdGhlcmUgaXMgb25lLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vY29tcG9uZW50cy9vdXRsZXRcbiAqL1xuZnVuY3Rpb24gT3V0bGV0KHByb3BzKSB7XG4gIHJldHVybiB1c2VPdXRsZXQocHJvcHMuY29udGV4dCk7XG59XG4vKipcbiAqIERlY2xhcmVzIGFuIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgcmVuZGVyZWQgYXQgYSBjZXJ0YWluIFVSTCBwYXRoLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vY29tcG9uZW50cy9yb3V0ZVxuICovXG5mdW5jdGlvbiBSb3V0ZShfcHJvcHMpIHtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJBIDxSb3V0ZT4gaXMgb25seSBldmVyIHRvIGJlIHVzZWQgYXMgdGhlIGNoaWxkIG9mIDxSb3V0ZXM+IGVsZW1lbnQsIFwiICsgXCJuZXZlciByZW5kZXJlZCBkaXJlY3RseS4gUGxlYXNlIHdyYXAgeW91ciA8Um91dGU+IGluIGEgPFJvdXRlcz4uXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgO1xufVxuLyoqXG4gKiBQcm92aWRlcyBsb2NhdGlvbiBjb250ZXh0IGZvciB0aGUgcmVzdCBvZiB0aGUgYXBwLlxuICpcbiAqIE5vdGU6IFlvdSB1c3VhbGx5IHdvbid0IHJlbmRlciBhIGA8Um91dGVyPmAgZGlyZWN0bHkuIEluc3RlYWQsIHlvdSdsbCByZW5kZXIgYVxuICogcm91dGVyIHRoYXQgaXMgbW9yZSBzcGVjaWZpYyB0byB5b3VyIGVudmlyb25tZW50IHN1Y2ggYXMgYSBgPEJyb3dzZXJSb3V0ZXI+YFxuICogaW4gd2ViIGJyb3dzZXJzIG9yIGEgYDxTdGF0aWNSb3V0ZXI+YCBmb3Igc2VydmVyIHJlbmRlcmluZy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3JvdXRlci1jb21wb25lbnRzL3JvdXRlclxuICovXG5mdW5jdGlvbiBSb3V0ZXIoX3JlZjUpIHtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZTogYmFzZW5hbWVQcm9wID0gXCIvXCIsXG4gICAgY2hpbGRyZW4gPSBudWxsLFxuICAgIGxvY2F0aW9uOiBsb2NhdGlvblByb3AsXG4gICAgbmF2aWdhdGlvblR5cGUgPSBBY3Rpb24uUG9wLFxuICAgIG5hdmlnYXRvcixcbiAgICBzdGF0aWM6IHN0YXRpY1Byb3AgPSBmYWxzZVxuICB9ID0gX3JlZjU7XG4gICEhdXNlSW5Sb3V0ZXJDb250ZXh0KCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIllvdSBjYW5ub3QgcmVuZGVyIGEgPFJvdXRlcj4gaW5zaWRlIGFub3RoZXIgPFJvdXRlcj4uXCIgKyBcIiBZb3Ugc2hvdWxkIG5ldmVyIGhhdmUgbW9yZSB0aGFuIG9uZSBpbiB5b3VyIGFwcC5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcblxuICAvLyBQcmVzZXJ2ZSB0cmFpbGluZyBzbGFzaGVzIG9uIGJhc2VuYW1lLCBzbyB3ZSBjYW4gbGV0IHRoZSB1c2VyIGNvbnRyb2xcbiAgLy8gdGhlIGVuZm9yY2VtZW50IG9mIHRyYWlsaW5nIHNsYXNoZXMgdGhyb3VnaG91dCB0aGUgYXBwXG4gIGxldCBiYXNlbmFtZSA9IGJhc2VuYW1lUHJvcC5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKTtcbiAgbGV0IG5hdmlnYXRpb25Db250ZXh0ID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgIGJhc2VuYW1lLFxuICAgIG5hdmlnYXRvcixcbiAgICBzdGF0aWM6IHN0YXRpY1Byb3BcbiAgfSksIFtiYXNlbmFtZSwgbmF2aWdhdG9yLCBzdGF0aWNQcm9wXSk7XG4gIGlmICh0eXBlb2YgbG9jYXRpb25Qcm9wID09PSBcInN0cmluZ1wiKSB7XG4gICAgbG9jYXRpb25Qcm9wID0gcGFyc2VQYXRoKGxvY2F0aW9uUHJvcCk7XG4gIH1cbiAgbGV0IHtcbiAgICBwYXRobmFtZSA9IFwiL1wiLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCIsXG4gICAgc3RhdGUgPSBudWxsLFxuICAgIGtleSA9IFwiZGVmYXVsdFwiXG4gIH0gPSBsb2NhdGlvblByb3A7XG4gIGxldCBsb2NhdGlvbkNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgdHJhaWxpbmdQYXRobmFtZSA9IHN0cmlwQmFzZW5hbWUocGF0aG5hbWUsIGJhc2VuYW1lKTtcbiAgICBpZiAodHJhaWxpbmdQYXRobmFtZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvY2F0aW9uOiB7XG4gICAgICAgIHBhdGhuYW1lOiB0cmFpbGluZ1BhdGhuYW1lLFxuICAgICAgICBzZWFyY2gsXG4gICAgICAgIGhhc2gsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBrZXlcbiAgICAgIH0sXG4gICAgICBuYXZpZ2F0aW9uVHlwZVxuICAgIH07XG4gIH0sIFtiYXNlbmFtZSwgcGF0aG5hbWUsIHNlYXJjaCwgaGFzaCwgc3RhdGUsIGtleSwgbmF2aWdhdGlvblR5cGVdKTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX3dhcm5pbmcobG9jYXRpb25Db250ZXh0ICE9IG51bGwsIFwiPFJvdXRlciBiYXNlbmFtZT1cXFwiXCIgKyBiYXNlbmFtZSArIFwiXFxcIj4gaXMgbm90IGFibGUgdG8gbWF0Y2ggdGhlIFVSTCBcIiArIChcIlxcXCJcIiArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaCArIFwiXFxcIiBiZWNhdXNlIGl0IGRvZXMgbm90IHN0YXJ0IHdpdGggdGhlIFwiKSArIFwiYmFzZW5hbWUsIHNvIHRoZSA8Um91dGVyPiB3b24ndCByZW5kZXIgYW55dGhpbmcuXCIpIDogdm9pZCAwO1xuICBpZiAobG9jYXRpb25Db250ZXh0ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTmF2aWdhdGlvbkNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogbmF2aWdhdGlvbkNvbnRleHRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTG9jYXRpb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIHZhbHVlOiBsb2NhdGlvbkNvbnRleHRcbiAgfSkpO1xufVxuLyoqXG4gKiBBIGNvbnRhaW5lciBmb3IgYSBuZXN0ZWQgdHJlZSBvZiBgPFJvdXRlPmAgZWxlbWVudHMgdGhhdCByZW5kZXJzIHRoZSBicmFuY2hcbiAqIHRoYXQgYmVzdCBtYXRjaGVzIHRoZSBjdXJyZW50IGxvY2F0aW9uLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vY29tcG9uZW50cy9yb3V0ZXNcbiAqL1xuZnVuY3Rpb24gUm91dGVzKF9yZWY2KSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW4sXG4gICAgbG9jYXRpb25cbiAgfSA9IF9yZWY2O1xuICByZXR1cm4gdXNlUm91dGVzKGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihjaGlsZHJlbiksIGxvY2F0aW9uKTtcbn1cbi8qKlxuICogQ29tcG9uZW50IHRvIHVzZSBmb3IgcmVuZGVyaW5nIGxhemlseSBsb2FkZWQgZGF0YSBmcm9tIHJldHVybmluZyBkZWZlcigpXG4gKiBpbiBhIGxvYWRlciBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBBd2FpdChfcmVmNykge1xuICBsZXQge1xuICAgIGNoaWxkcmVuLFxuICAgIGVycm9yRWxlbWVudCxcbiAgICByZXNvbHZlXG4gIH0gPSBfcmVmNztcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEF3YWl0RXJyb3JCb3VuZGFyeSwge1xuICAgIHJlc29sdmU6IHJlc29sdmUsXG4gICAgZXJyb3JFbGVtZW50OiBlcnJvckVsZW1lbnRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVzb2x2ZUF3YWl0LCBudWxsLCBjaGlsZHJlbikpO1xufVxudmFyIEF3YWl0UmVuZGVyU3RhdHVzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChBd2FpdFJlbmRlclN0YXR1cykge1xuICBBd2FpdFJlbmRlclN0YXR1c1tBd2FpdFJlbmRlclN0YXR1c1tcInBlbmRpbmdcIl0gPSAwXSA9IFwicGVuZGluZ1wiO1xuICBBd2FpdFJlbmRlclN0YXR1c1tBd2FpdFJlbmRlclN0YXR1c1tcInN1Y2Nlc3NcIl0gPSAxXSA9IFwic3VjY2Vzc1wiO1xuICBBd2FpdFJlbmRlclN0YXR1c1tBd2FpdFJlbmRlclN0YXR1c1tcImVycm9yXCJdID0gMl0gPSBcImVycm9yXCI7XG4gIHJldHVybiBBd2FpdFJlbmRlclN0YXR1cztcbn0oQXdhaXRSZW5kZXJTdGF0dXMgfHwge30pO1xuY29uc3QgbmV2ZXJTZXR0bGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKCgpID0+IHt9KTtcbmNsYXNzIEF3YWl0RXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBlcnJvcjogbnVsbFxuICAgIH07XG4gIH1cbiAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBlcnJvclxuICAgIH07XG4gIH1cbiAgY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGVycm9ySW5mbykge1xuICAgIGNvbnNvbGUuZXJyb3IoXCI8QXdhaXQ+IGNhdWdodCB0aGUgZm9sbG93aW5nIGVycm9yIGR1cmluZyByZW5kZXJcIiwgZXJyb3IsIGVycm9ySW5mbyk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGxldCB7XG4gICAgICBjaGlsZHJlbixcbiAgICAgIGVycm9yRWxlbWVudCxcbiAgICAgIHJlc29sdmVcbiAgICB9ID0gdGhpcy5wcm9wcztcbiAgICBsZXQgcHJvbWlzZSA9IG51bGw7XG4gICAgbGV0IHN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLnBlbmRpbmc7XG4gICAgaWYgKCEocmVzb2x2ZSBpbnN0YW5jZW9mIFByb21pc2UpKSB7XG4gICAgICAvLyBEaWRuJ3QgZ2V0IGEgcHJvbWlzZSAtIHByb3ZpZGUgYXMgYSByZXNvbHZlZCBwcm9taXNlXG4gICAgICBzdGF0dXMgPSBBd2FpdFJlbmRlclN0YXR1cy5zdWNjZXNzO1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX3RyYWNrZWRcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IHRydWVcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2RhdGFcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IHJlc29sdmVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZS5lcnJvcikge1xuICAgICAgLy8gQ2F1Z2h0IGEgcmVuZGVyIGVycm9yLCBwcm92aWRlIGl0IGFzIGEgcmVqZWN0ZWQgcHJvbWlzZVxuICAgICAgc3RhdHVzID0gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3I7XG4gICAgICBsZXQgcmVuZGVyRXJyb3IgPSB0aGlzLnN0YXRlLmVycm9yO1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVqZWN0KCkuY2F0Y2goKCkgPT4ge30pOyAvLyBBdm9pZCB1bmhhbmRsZWQgcmVqZWN0aW9uIHdhcm5pbmdzXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfdHJhY2tlZFwiLCB7XG4gICAgICAgIGdldDogKCkgPT4gdHJ1ZVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IHJlbmRlckVycm9yXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHJlc29sdmUuX3RyYWNrZWQpIHtcbiAgICAgIC8vIEFscmVhZHkgdHJhY2tlZCBwcm9taXNlIC0gY2hlY2sgY29udGVudHNcbiAgICAgIHByb21pc2UgPSByZXNvbHZlO1xuICAgICAgc3RhdHVzID0gcHJvbWlzZS5fZXJyb3IgIT09IHVuZGVmaW5lZCA/IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yIDogcHJvbWlzZS5fZGF0YSAhPT0gdW5kZWZpbmVkID8gQXdhaXRSZW5kZXJTdGF0dXMuc3VjY2VzcyA6IEF3YWl0UmVuZGVyU3RhdHVzLnBlbmRpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJhdyAodW50cmFja2VkKSBwcm9taXNlIC0gdHJhY2sgaXRcbiAgICAgIHN0YXR1cyA9IEF3YWl0UmVuZGVyU3RhdHVzLnBlbmRpbmc7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfdHJhY2tlZFwiLCB7XG4gICAgICAgIGdldDogKCkgPT4gdHJ1ZVxuICAgICAgfSk7XG4gICAgICBwcm9taXNlID0gcmVzb2x2ZS50aGVuKGRhdGEgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc29sdmUsIFwiX2RhdGFcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IGRhdGFcbiAgICAgIH0pLCBlcnJvciA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZSwgXCJfZXJyb3JcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IGVycm9yXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IEF3YWl0UmVuZGVyU3RhdHVzLmVycm9yICYmIHByb21pc2UuX2Vycm9yIGluc3RhbmNlb2YgQWJvcnRlZERlZmVycmVkRXJyb3IpIHtcbiAgICAgIC8vIEZyZWV6ZSB0aGUgVUkgYnkgdGhyb3dpbmcgYSBuZXZlciByZXNvbHZlZCBwcm9taXNlXG4gICAgICB0aHJvdyBuZXZlclNldHRsZWRQcm9taXNlO1xuICAgIH1cbiAgICBpZiAoc3RhdHVzID09PSBBd2FpdFJlbmRlclN0YXR1cy5lcnJvciAmJiAhZXJyb3JFbGVtZW50KSB7XG4gICAgICAvLyBObyBlcnJvckVsZW1lbnQsIHRocm93IHRvIHRoZSBuZWFyZXN0IHJvdXRlLWxldmVsIGVycm9yIGJvdW5kYXJ5XG4gICAgICB0aHJvdyBwcm9taXNlLl9lcnJvcjtcbiAgICB9XG4gICAgaWYgKHN0YXR1cyA9PT0gQXdhaXRSZW5kZXJTdGF0dXMuZXJyb3IpIHtcbiAgICAgIC8vIFJlbmRlciB2aWEgb3VyIGVycm9yRWxlbWVudFxuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEF3YWl0Q29udGV4dC5Qcm92aWRlciwge1xuICAgICAgICB2YWx1ZTogcHJvbWlzZSxcbiAgICAgICAgY2hpbGRyZW46IGVycm9yRWxlbWVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGF0dXMgPT09IEF3YWl0UmVuZGVyU3RhdHVzLnN1Y2Nlc3MpIHtcbiAgICAgIC8vIFJlbmRlciBjaGlsZHJlbiB3aXRoIHJlc29sdmVkIHZhbHVlXG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQXdhaXRDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiBwcm9taXNlLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFRocm93IHRvIHRoZSBzdXNwZW5zZSBib3VuZGFyeVxuICAgIHRocm93IHByb21pc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogSW5kaXJlY3Rpb24gdG8gbGV2ZXJhZ2UgdXNlQXN5bmNWYWx1ZSBmb3IgYSByZW5kZXItcHJvcCBBUEkgb24gYDxBd2FpdD5gXG4gKi9cbmZ1bmN0aW9uIFJlc29sdmVBd2FpdChfcmVmOCkge1xuICBsZXQge1xuICAgIGNoaWxkcmVuXG4gIH0gPSBfcmVmODtcbiAgbGV0IGRhdGEgPSB1c2VBc3luY1ZhbHVlKCk7XG4gIGxldCB0b1JlbmRlciA9IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJmdW5jdGlvblwiID8gY2hpbGRyZW4oZGF0YSkgOiBjaGlsZHJlbjtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCB0b1JlbmRlcik7XG59XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFVUSUxTXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbi8qKlxuICogQ3JlYXRlcyBhIHJvdXRlIGNvbmZpZyBmcm9tIGEgUmVhY3QgXCJjaGlsZHJlblwiIG9iamVjdCwgd2hpY2ggaXMgdXN1YWxseVxuICogZWl0aGVyIGEgYDxSb3V0ZT5gIGVsZW1lbnQgb3IgYW4gYXJyYXkgb2YgdGhlbS4gVXNlZCBpbnRlcm5hbGx5IGJ5XG4gKiBgPFJvdXRlcz5gIHRvIGNyZWF0ZSBhIHJvdXRlIGNvbmZpZyBmcm9tIGl0cyBjaGlsZHJlbi5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL2NyZWF0ZS1yb3V0ZXMtZnJvbS1jaGlsZHJlblxuICovXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oY2hpbGRyZW4sIHBhcmVudFBhdGgpIHtcbiAgaWYgKHBhcmVudFBhdGggPT09IHZvaWQgMCkge1xuICAgIHBhcmVudFBhdGggPSBbXTtcbiAgfVxuICBsZXQgcm91dGVzID0gW107XG4gIFJlYWN0LkNoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIChlbGVtZW50LCBpbmRleCkgPT4ge1xuICAgIGlmICghIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgLy8gSWdub3JlIG5vbi1lbGVtZW50cy4gVGhpcyBhbGxvd3MgcGVvcGxlIHRvIG1vcmUgZWFzaWx5IGlubGluZVxuICAgICAgLy8gY29uZGl0aW9uYWxzIGluIHRoZWlyIHJvdXRlIGNvbmZpZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHRyZWVQYXRoID0gWy4uLnBhcmVudFBhdGgsIGluZGV4XTtcbiAgICBpZiAoZWxlbWVudC50eXBlID09PSBSZWFjdC5GcmFnbWVudCkge1xuICAgICAgLy8gVHJhbnNwYXJlbnRseSBzdXBwb3J0IFJlYWN0LkZyYWdtZW50IGFuZCBpdHMgY2hpbGRyZW4uXG4gICAgICByb3V0ZXMucHVzaC5hcHBseShyb3V0ZXMsIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbihlbGVtZW50LnByb3BzLmNoaWxkcmVuLCB0cmVlUGF0aCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAhKGVsZW1lbnQudHlwZSA9PT0gUm91dGUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJbXCIgKyAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gXCJzdHJpbmdcIiA/IGVsZW1lbnQudHlwZSA6IGVsZW1lbnQudHlwZS5uYW1lKSArIFwiXSBpcyBub3QgYSA8Um91dGU+IGNvbXBvbmVudC4gQWxsIGNvbXBvbmVudCBjaGlsZHJlbiBvZiA8Um91dGVzPiBtdXN0IGJlIGEgPFJvdXRlPiBvciA8UmVhY3QuRnJhZ21lbnQ+XCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgISghZWxlbWVudC5wcm9wcy5pbmRleCB8fCAhZWxlbWVudC5wcm9wcy5jaGlsZHJlbikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcIkFuIGluZGV4IHJvdXRlIGNhbm5vdCBoYXZlIGNoaWxkIHJvdXRlcy5cIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgICBsZXQgcm91dGUgPSB7XG4gICAgICBpZDogZWxlbWVudC5wcm9wcy5pZCB8fCB0cmVlUGF0aC5qb2luKFwiLVwiKSxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IGVsZW1lbnQucHJvcHMuY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQucHJvcHMuZWxlbWVudCxcbiAgICAgIENvbXBvbmVudDogZWxlbWVudC5wcm9wcy5Db21wb25lbnQsXG4gICAgICBpbmRleDogZWxlbWVudC5wcm9wcy5pbmRleCxcbiAgICAgIHBhdGg6IGVsZW1lbnQucHJvcHMucGF0aCxcbiAgICAgIGxvYWRlcjogZWxlbWVudC5wcm9wcy5sb2FkZXIsXG4gICAgICBhY3Rpb246IGVsZW1lbnQucHJvcHMuYWN0aW9uLFxuICAgICAgZXJyb3JFbGVtZW50OiBlbGVtZW50LnByb3BzLmVycm9yRWxlbWVudCxcbiAgICAgIEVycm9yQm91bmRhcnk6IGVsZW1lbnQucHJvcHMuRXJyb3JCb3VuZGFyeSxcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IGVsZW1lbnQucHJvcHMuRXJyb3JCb3VuZGFyeSAhPSBudWxsIHx8IGVsZW1lbnQucHJvcHMuZXJyb3JFbGVtZW50ICE9IG51bGwsXG4gICAgICBzaG91bGRSZXZhbGlkYXRlOiBlbGVtZW50LnByb3BzLnNob3VsZFJldmFsaWRhdGUsXG4gICAgICBoYW5kbGU6IGVsZW1lbnQucHJvcHMuaGFuZGxlLFxuICAgICAgbGF6eTogZWxlbWVudC5wcm9wcy5sYXp5XG4gICAgfTtcbiAgICBpZiAoZWxlbWVudC5wcm9wcy5jaGlsZHJlbikge1xuICAgICAgcm91dGUuY2hpbGRyZW4gPSBjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4oZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgdHJlZVBhdGgpO1xuICAgIH1cbiAgICByb3V0ZXMucHVzaChyb3V0ZSk7XG4gIH0pO1xuICByZXR1cm4gcm91dGVzO1xufVxuXG4vKipcbiAqIFJlbmRlcnMgdGhlIHJlc3VsdCBvZiBgbWF0Y2hSb3V0ZXMoKWAgaW50byBhIFJlYWN0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlck1hdGNoZXMobWF0Y2hlcykge1xuICByZXR1cm4gX3JlbmRlck1hdGNoZXMobWF0Y2hlcyk7XG59XG5cbmZ1bmN0aW9uIG1hcFJvdXRlUHJvcGVydGllcyhyb3V0ZSkge1xuICBsZXQgdXBkYXRlcyA9IHtcbiAgICAvLyBOb3RlOiB0aGlzIGNoZWNrIGFsc28gb2NjdXJzIGluIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiBzbyB1cGRhdGVcbiAgICAvLyB0aGVyZSBpZiB5b3UgY2hhbmdlIHRoaXMgLS0gcGxlYXNlIGFuZCB0aGFuayB5b3UhXG4gICAgaGFzRXJyb3JCb3VuZGFyeTogcm91dGUuRXJyb3JCb3VuZGFyeSAhPSBudWxsIHx8IHJvdXRlLmVycm9yRWxlbWVudCAhPSBudWxsXG4gIH07XG4gIGlmIChyb3V0ZS5Db21wb25lbnQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAocm91dGUuZWxlbWVudCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhmYWxzZSwgXCJZb3Ugc2hvdWxkIG5vdCBpbmNsdWRlIGJvdGggYENvbXBvbmVudGAgYW5kIGBlbGVtZW50YCBvbiB5b3VyIHJvdXRlIC0gXCIgKyBcImBDb21wb25lbnRgIHdpbGwgYmUgdXNlZC5cIikgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odXBkYXRlcywge1xuICAgICAgZWxlbWVudDogLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQocm91dGUuQ29tcG9uZW50KSxcbiAgICAgIENvbXBvbmVudDogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH1cbiAgaWYgKHJvdXRlLkVycm9yQm91bmRhcnkpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBpZiAocm91dGUuZXJyb3JFbGVtZW50KSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGZhbHNlLCBcIllvdSBzaG91bGQgbm90IGluY2x1ZGUgYm90aCBgRXJyb3JCb3VuZGFyeWAgYW5kIGBlcnJvckVsZW1lbnRgIG9uIHlvdXIgcm91dGUgLSBcIiArIFwiYEVycm9yQm91bmRhcnlgIHdpbGwgYmUgdXNlZC5cIikgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24odXBkYXRlcywge1xuICAgICAgZXJyb3JFbGVtZW50OiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChyb3V0ZS5FcnJvckJvdW5kYXJ5KSxcbiAgICAgIEVycm9yQm91bmRhcnk6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB1cGRhdGVzO1xufVxuZnVuY3Rpb24gY3JlYXRlTWVtb3J5Um91dGVyKHJvdXRlcywgb3B0cykge1xuICByZXR1cm4gY3JlYXRlUm91dGVyKHtcbiAgICBiYXNlbmFtZTogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5iYXNlbmFtZSxcbiAgICBmdXR1cmU6IF9leHRlbmRzKHt9LCBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmZ1dHVyZSwge1xuICAgICAgdjdfcHJlcGVuZEJhc2VuYW1lOiB0cnVlXG4gICAgfSksXG4gICAgaGlzdG9yeTogY3JlYXRlTWVtb3J5SGlzdG9yeSh7XG4gICAgICBpbml0aWFsRW50cmllczogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5pbml0aWFsRW50cmllcyxcbiAgICAgIGluaXRpYWxJbmRleDogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5pbml0aWFsSW5kZXhcbiAgICB9KSxcbiAgICBoeWRyYXRpb25EYXRhOiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmh5ZHJhdGlvbkRhdGEsXG4gICAgcm91dGVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllc1xuICB9KS5pbml0aWFsaXplKCk7XG59XG5cbmV4cG9ydCB7IEF3YWl0LCBNZW1vcnlSb3V0ZXIsIE5hdmlnYXRlLCBPdXRsZXQsIFJvdXRlLCBSb3V0ZXIsIFJvdXRlclByb3ZpZGVyLCBSb3V0ZXMsIERhdGFSb3V0ZXJDb250ZXh0IGFzIFVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCwgRGF0YVJvdXRlclN0YXRlQ29udGV4dCBhcyBVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCwgTG9jYXRpb25Db250ZXh0IGFzIFVOU0FGRV9Mb2NhdGlvbkNvbnRleHQsIE5hdmlnYXRpb25Db250ZXh0IGFzIFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCwgUm91dGVDb250ZXh0IGFzIFVOU0FGRV9Sb3V0ZUNvbnRleHQsIG1hcFJvdXRlUHJvcGVydGllcyBhcyBVTlNBRkVfbWFwUm91dGVQcm9wZXJ0aWVzLCB1c2VSb3V0ZUlkIGFzIFVOU0FGRV91c2VSb3V0ZUlkLCB1c2VSb3V0ZXNJbXBsIGFzIFVOU0FGRV91c2VSb3V0ZXNJbXBsLCBjcmVhdGVNZW1vcnlSb3V0ZXIsIGNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiwgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuIGFzIGNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cywgcmVuZGVyTWF0Y2hlcywgdXNlQWN0aW9uRGF0YSwgdXNlQXN5bmNFcnJvciwgdXNlQXN5bmNWYWx1ZSwgdXNlQmxvY2tlciwgdXNlSHJlZiwgdXNlSW5Sb3V0ZXJDb250ZXh0LCB1c2VMb2FkZXJEYXRhLCB1c2VMb2NhdGlvbiwgdXNlTWF0Y2gsIHVzZU1hdGNoZXMsIHVzZU5hdmlnYXRlLCB1c2VOYXZpZ2F0aW9uLCB1c2VOYXZpZ2F0aW9uVHlwZSwgdXNlT3V0bGV0LCB1c2VPdXRsZXRDb250ZXh0LCB1c2VQYXJhbXMsIHVzZVJlc29sdmVkUGF0aCwgdXNlUmV2YWxpZGF0b3IsIHVzZVJvdXRlRXJyb3IsIHVzZVJvdXRlTG9hZGVyRGF0YSwgdXNlUm91dGVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIlVOU0FGRV9pbnZhcmlhbnQiLCJqb2luUGF0aHMiLCJtYXRjaFBhdGgiLCJVTlNBRkVfZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMiLCJVTlNBRkVfd2FybmluZyIsInJlc29sdmVUbyIsInBhcnNlUGF0aCIsIm1hdGNoUm91dGVzIiwiQWN0aW9uIiwiVU5TQUZFX2NvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoIiwic3RyaXBCYXNlbmFtZSIsIklETEVfQkxPQ0tFUiIsImlzUm91dGVFcnJvclJlc3BvbnNlIiwiY3JlYXRlTWVtb3J5SGlzdG9yeSIsIkFib3J0ZWREZWZlcnJlZEVycm9yIiwiY3JlYXRlUm91dGVyIiwiTmF2aWdhdGlvblR5cGUiLCJjcmVhdGVQYXRoIiwiZGVmZXIiLCJnZW5lcmF0ZVBhdGgiLCJqc29uIiwicmVkaXJlY3QiLCJyZWRpcmVjdERvY3VtZW50IiwicmVzb2x2ZVBhdGgiLCJfZXh0ZW5kcyIsIk9iamVjdCIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJEYXRhUm91dGVyQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiLCJEYXRhUm91dGVyU3RhdGVDb250ZXh0IiwiQXdhaXRDb250ZXh0IiwiTmF2aWdhdGlvbkNvbnRleHQiLCJMb2NhdGlvbkNvbnRleHQiLCJSb3V0ZUNvbnRleHQiLCJvdXRsZXQiLCJtYXRjaGVzIiwiaXNEYXRhUm91dGUiLCJSb3V0ZUVycm9yQ29udGV4dCIsInVzZUhyZWYiLCJ0byIsIl90ZW1wIiwicmVsYXRpdmUiLCJ1c2VJblJvdXRlckNvbnRleHQiLCJiYXNlbmFtZSIsIm5hdmlnYXRvciIsInVzZUNvbnRleHQiLCJoYXNoIiwicGF0aG5hbWUiLCJzZWFyY2giLCJ1c2VSZXNvbHZlZFBhdGgiLCJqb2luZWRQYXRobmFtZSIsImNyZWF0ZUhyZWYiLCJ1c2VMb2NhdGlvbiIsImxvY2F0aW9uIiwidXNlTmF2aWdhdGlvblR5cGUiLCJuYXZpZ2F0aW9uVHlwZSIsInVzZU1hdGNoIiwicGF0dGVybiIsInVzZU1lbW8iLCJuYXZpZ2F0ZUVmZmVjdFdhcm5pbmciLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiY2IiLCJpc1N0YXRpYyIsInN0YXRpYyIsInVzZUxheW91dEVmZmVjdCIsInVzZU5hdmlnYXRlIiwidXNlTmF2aWdhdGVTdGFibGUiLCJ1c2VOYXZpZ2F0ZVVuc3RhYmxlIiwiZGF0YVJvdXRlckNvbnRleHQiLCJsb2NhdGlvblBhdGhuYW1lIiwicm91dGVQYXRobmFtZXNKc29uIiwiSlNPTiIsInN0cmluZ2lmeSIsIm1hcCIsIm1hdGNoIiwicGF0aG5hbWVCYXNlIiwiYWN0aXZlUmVmIiwidXNlUmVmIiwiY3VycmVudCIsIm5hdmlnYXRlIiwidXNlQ2FsbGJhY2siLCJvcHRpb25zIiwiZ28iLCJwYXRoIiwicGFyc2UiLCJyZXBsYWNlIiwicHVzaCIsInN0YXRlIiwiT3V0bGV0Q29udGV4dCIsInVzZU91dGxldENvbnRleHQiLCJ1c2VPdXRsZXQiLCJjb250ZXh0IiwiY3JlYXRlRWxlbWVudCIsIlByb3ZpZGVyIiwidmFsdWUiLCJ1c2VQYXJhbXMiLCJyb3V0ZU1hdGNoIiwicGFyYW1zIiwiX3RlbXAyIiwidXNlUm91dGVzIiwicm91dGVzIiwibG9jYXRpb25BcmciLCJ1c2VSb3V0ZXNJbXBsIiwiZGF0YVJvdXRlclN0YXRlIiwicGFyZW50TWF0Y2hlcyIsInBhcmVudFBhcmFtcyIsInBhcmVudFBhdGhuYW1lIiwicGFyZW50UGF0aG5hbWVCYXNlIiwicGFyZW50Um91dGUiLCJyb3V0ZSIsInBhcmVudFBhdGgiLCJ3YXJuaW5nT25jZSIsImVuZHNXaXRoIiwibG9jYXRpb25Gcm9tQ29udGV4dCIsIl9wYXJzZWRMb2NhdGlvbkFyZyRwYSIsInBhcnNlZExvY2F0aW9uQXJnIiwic3RhcnRzV2l0aCIsInJlbWFpbmluZ1BhdGhuYW1lIiwic2xpY2UiLCJlbGVtZW50IiwidW5kZWZpbmVkIiwiQ29tcG9uZW50IiwicmVuZGVyZWRNYXRjaGVzIiwiX3JlbmRlck1hdGNoZXMiLCJlbmNvZGVMb2NhdGlvbiIsIlBvcCIsIkRlZmF1bHRFcnJvckNvbXBvbmVudCIsImVycm9yIiwidXNlUm91dGVFcnJvciIsIm1lc3NhZ2UiLCJzdGF0dXMiLCJzdGF0dXNUZXh0IiwiRXJyb3IiLCJzdGFjayIsImxpZ2h0Z3JleSIsInByZVN0eWxlcyIsInBhZGRpbmciLCJiYWNrZ3JvdW5kQ29sb3IiLCJjb2RlU3R5bGVzIiwiZGV2SW5mbyIsImNvbnNvbGUiLCJGcmFnbWVudCIsInN0eWxlIiwiZm9udFN0eWxlIiwiZGVmYXVsdEVycm9yRWxlbWVudCIsIlJlbmRlckVycm9yQm91bmRhcnkiLCJjb25zdHJ1Y3RvciIsInByb3BzIiwicmV2YWxpZGF0aW9uIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJlcnJvckluZm8iLCJyZW5kZXIiLCJyb3V0ZUNvbnRleHQiLCJjaGlsZHJlbiIsImNvbXBvbmVudCIsIlJlbmRlcmVkUm91dGUiLCJfcmVmIiwic3RhdGljQ29udGV4dCIsImVycm9yRWxlbWVudCIsIkVycm9yQm91bmRhcnkiLCJfZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCIsImlkIiwiX2RhdGFSb3V0ZXJTdGF0ZTIiLCJfZGF0YVJvdXRlclN0YXRlIiwiZXJyb3JzIiwiZXJyb3JJbmRleCIsImZpbmRJbmRleCIsIm0iLCJrZXlzIiwiam9pbiIsIk1hdGgiLCJtaW4iLCJyZWR1Y2VSaWdodCIsImluZGV4IiwiY29uY2F0IiwiZ2V0Q2hpbGRyZW4iLCJEYXRhUm91dGVySG9vayIsIkRhdGFSb3V0ZXJTdGF0ZUhvb2siLCJnZXREYXRhUm91dGVyQ29uc29sZUVycm9yIiwiaG9va05hbWUiLCJ1c2VEYXRhUm91dGVyQ29udGV4dCIsImN0eCIsInVzZURhdGFSb3V0ZXJTdGF0ZSIsInVzZVJvdXRlQ29udGV4dCIsInVzZUN1cnJlbnRSb3V0ZUlkIiwidGhpc1JvdXRlIiwidXNlUm91dGVJZCIsIlVzZVJvdXRlSWQiLCJ1c2VOYXZpZ2F0aW9uIiwiVXNlTmF2aWdhdGlvbiIsIm5hdmlnYXRpb24iLCJ1c2VSZXZhbGlkYXRvciIsIlVzZVJldmFsaWRhdG9yIiwicmV2YWxpZGF0ZSIsInJvdXRlciIsInVzZU1hdGNoZXMiLCJsb2FkZXJEYXRhIiwiVXNlTWF0Y2hlcyIsInVzZUxvYWRlckRhdGEiLCJVc2VMb2FkZXJEYXRhIiwicm91dGVJZCIsInVzZVJvdXRlTG9hZGVyRGF0YSIsIlVzZVJvdXRlTG9hZGVyRGF0YSIsInVzZUFjdGlvbkRhdGEiLCJVc2VBY3Rpb25EYXRhIiwiYWN0aW9uRGF0YSIsIl9zdGF0ZSRlcnJvcnMiLCJVc2VSb3V0ZUVycm9yIiwidXNlQXN5bmNWYWx1ZSIsIl9kYXRhIiwidXNlQXN5bmNFcnJvciIsIl9lcnJvciIsImJsb2NrZXJJZCIsInVzZUJsb2NrZXIiLCJzaG91bGRCbG9jayIsIlVzZUJsb2NrZXIiLCJibG9ja2VyS2V5Iiwic2V0QmxvY2tlcktleSIsInVzZVN0YXRlIiwiYmxvY2tlckZ1bmN0aW9uIiwiYXJnIiwiY3VycmVudExvY2F0aW9uIiwibmV4dExvY2F0aW9uIiwiaGlzdG9yeUFjdGlvbiIsInVzZUVmZmVjdCIsIlN0cmluZyIsImRlbGV0ZUJsb2NrZXIiLCJnZXRCbG9ja2VyIiwiYmxvY2tlcnMiLCJoYXMiLCJnZXQiLCJVc2VOYXZpZ2F0ZVN0YWJsZSIsImZyb21Sb3V0ZUlkIiwiYWxyZWFkeVdhcm5lZCIsImNvbmQiLCJTVEFSVF9UUkFOU0lUSU9OIiwic3RhcnRUcmFuc2l0aW9uSW1wbCIsIlJvdXRlclByb3ZpZGVyIiwiZmFsbGJhY2tFbGVtZW50IiwiZnV0dXJlIiwic2V0U3RhdGVJbXBsIiwidjdfc3RhcnRUcmFuc2l0aW9uIiwic2V0U3RhdGUiLCJuZXdTdGF0ZSIsInN1YnNjcmliZSIsIm4iLCJvcHRzIiwicHJldmVudFNjcm9sbFJlc2V0IiwiUm91dGVyIiwiaW5pdGlhbGl6ZWQiLCJEYXRhUm91dGVzIiwiX3JlZjIiLCJNZW1vcnlSb3V0ZXIiLCJfcmVmMyIsImluaXRpYWxFbnRyaWVzIiwiaW5pdGlhbEluZGV4IiwiaGlzdG9yeVJlZiIsInY1Q29tcGF0IiwiaGlzdG9yeSIsImFjdGlvbiIsImxpc3RlbiIsIk5hdmlnYXRlIiwiX3JlZjQiLCJqc29uUGF0aCIsIk91dGxldCIsIlJvdXRlIiwiX3Byb3BzIiwiX3JlZjUiLCJiYXNlbmFtZVByb3AiLCJsb2NhdGlvblByb3AiLCJzdGF0aWNQcm9wIiwibmF2aWdhdGlvbkNvbnRleHQiLCJsb2NhdGlvbkNvbnRleHQiLCJ0cmFpbGluZ1BhdGhuYW1lIiwiUm91dGVzIiwiX3JlZjYiLCJjcmVhdGVSb3V0ZXNGcm9tQ2hpbGRyZW4iLCJBd2FpdCIsIl9yZWY3IiwicmVzb2x2ZSIsIkF3YWl0RXJyb3JCb3VuZGFyeSIsIlJlc29sdmVBd2FpdCIsIkF3YWl0UmVuZGVyU3RhdHVzIiwibmV2ZXJTZXR0bGVkUHJvbWlzZSIsIlByb21pc2UiLCJwcm9taXNlIiwicGVuZGluZyIsInN1Y2Nlc3MiLCJkZWZpbmVQcm9wZXJ0eSIsInJlbmRlckVycm9yIiwicmVqZWN0IiwiY2F0Y2giLCJfdHJhY2tlZCIsInRoZW4iLCJkYXRhIiwiX3JlZjgiLCJ0b1JlbmRlciIsIkNoaWxkcmVuIiwiZm9yRWFjaCIsImlzVmFsaWRFbGVtZW50IiwidHJlZVBhdGgiLCJ0eXBlIiwibmFtZSIsImNhc2VTZW5zaXRpdmUiLCJsb2FkZXIiLCJoYXNFcnJvckJvdW5kYXJ5Iiwic2hvdWxkUmV2YWxpZGF0ZSIsImhhbmRsZSIsImxhenkiLCJyZW5kZXJNYXRjaGVzIiwibWFwUm91dGVQcm9wZXJ0aWVzIiwidXBkYXRlcyIsImNyZWF0ZU1lbW9yeVJvdXRlciIsInY3X3ByZXBlbmRCYXNlbmFtZSIsImh5ZHJhdGlvbkRhdGEiLCJpbml0aWFsaXplIiwiVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0IiwiVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQiLCJVTlNBRkVfTG9jYXRpb25Db250ZXh0IiwiVU5TQUZFX05hdmlnYXRpb25Db250ZXh0IiwiVU5TQUZFX1JvdXRlQ29udGV4dCIsIlVOU0FGRV9tYXBSb3V0ZVByb3BlcnRpZXMiLCJVTlNBRkVfdXNlUm91dGVJZCIsIlVOU0FGRV91c2VSb3V0ZXNJbXBsIiwiY3JlYXRlUm91dGVzRnJvbUVsZW1lbnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-router/dist/index.js\n");

/***/ })

};
;