"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-router-dom";
exports.ids = ["vendor-chunks/react-router-dom"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-router-dom/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/react-router-dom/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.AbortedDeferredError),\n/* harmony export */   Await: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Await),\n/* harmony export */   BrowserRouter: () => (/* binding */ BrowserRouter),\n/* harmony export */   Form: () => (/* binding */ Form),\n/* harmony export */   HashRouter: () => (/* binding */ HashRouter),\n/* harmony export */   Link: () => (/* binding */ Link),\n/* harmony export */   MemoryRouter: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.MemoryRouter),\n/* harmony export */   NavLink: () => (/* binding */ NavLink),\n/* harmony export */   Navigate: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Navigate),\n/* harmony export */   NavigationType: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.Action),\n/* harmony export */   Outlet: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Outlet),\n/* harmony export */   Route: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Route),\n/* harmony export */   Router: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Router),\n/* harmony export */   RouterProvider: () => (/* binding */ RouterProvider),\n/* harmony export */   Routes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.Routes),\n/* harmony export */   ScrollRestoration: () => (/* binding */ ScrollRestoration),\n/* harmony export */   UNSAFE_DataRouterContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterContext),\n/* harmony export */   UNSAFE_DataRouterStateContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterStateContext),\n/* harmony export */   UNSAFE_FetchersContext: () => (/* binding */ FetchersContext),\n/* harmony export */   UNSAFE_LocationContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_LocationContext),\n/* harmony export */   UNSAFE_NavigationContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext),\n/* harmony export */   UNSAFE_RouteContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_RouteContext),\n/* harmony export */   UNSAFE_ViewTransitionContext: () => (/* binding */ ViewTransitionContext),\n/* harmony export */   UNSAFE_useRouteId: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_useRouteId),\n/* harmony export */   UNSAFE_useScrollRestoration: () => (/* binding */ useScrollRestoration),\n/* harmony export */   createBrowserRouter: () => (/* binding */ createBrowserRouter),\n/* harmony export */   createHashRouter: () => (/* binding */ createHashRouter),\n/* harmony export */   createMemoryRouter: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.createMemoryRouter),\n/* harmony export */   createPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.createPath),\n/* harmony export */   createRoutesFromChildren: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.createRoutesFromChildren),\n/* harmony export */   createRoutesFromElements: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.createRoutesFromElements),\n/* harmony export */   createSearchParams: () => (/* binding */ createSearchParams),\n/* harmony export */   defer: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.defer),\n/* harmony export */   generatePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.generatePath),\n/* harmony export */   isRouteErrorResponse: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.isRouteErrorResponse),\n/* harmony export */   json: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.json),\n/* harmony export */   matchPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.matchPath),\n/* harmony export */   matchRoutes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.matchRoutes),\n/* harmony export */   parsePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.parsePath),\n/* harmony export */   redirect: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.redirect),\n/* harmony export */   redirectDocument: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.redirectDocument),\n/* harmony export */   renderMatches: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.renderMatches),\n/* harmony export */   resolvePath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_2__.resolvePath),\n/* harmony export */   unstable_HistoryRouter: () => (/* binding */ HistoryRouter),\n/* harmony export */   unstable_usePrompt: () => (/* binding */ usePrompt),\n/* harmony export */   unstable_useViewTransitionState: () => (/* binding */ useViewTransitionState),\n/* harmony export */   useActionData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useActionData),\n/* harmony export */   useAsyncError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useAsyncError),\n/* harmony export */   useAsyncValue: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useAsyncValue),\n/* harmony export */   useBeforeUnload: () => (/* binding */ useBeforeUnload),\n/* harmony export */   useBlocker: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useBlocker),\n/* harmony export */   useFetcher: () => (/* binding */ useFetcher),\n/* harmony export */   useFetchers: () => (/* binding */ useFetchers),\n/* harmony export */   useFormAction: () => (/* binding */ useFormAction),\n/* harmony export */   useHref: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useHref),\n/* harmony export */   useInRouterContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useInRouterContext),\n/* harmony export */   useLinkClickHandler: () => (/* binding */ useLinkClickHandler),\n/* harmony export */   useLoaderData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useLoaderData),\n/* harmony export */   useLocation: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation),\n/* harmony export */   useMatch: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useMatch),\n/* harmony export */   useMatches: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useMatches),\n/* harmony export */   useNavigate: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigate),\n/* harmony export */   useNavigation: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigation),\n/* harmony export */   useNavigationType: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigationType),\n/* harmony export */   useOutlet: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useOutlet),\n/* harmony export */   useOutletContext: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useOutletContext),\n/* harmony export */   useParams: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useParams),\n/* harmony export */   useResolvedPath: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath),\n/* harmony export */   useRevalidator: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useRevalidator),\n/* harmony export */   useRouteError: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useRouteError),\n/* harmony export */   useRouteLoaderData: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useRouteLoaderData),\n/* harmony export */   useRoutes: () => (/* reexport safe */ react_router__WEBPACK_IMPORTED_MODULE_3__.useRoutes),\n/* harmony export */   useSearchParams: () => (/* binding */ useSearchParams),\n/* harmony export */   useSubmit: () => (/* binding */ useSubmit)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-router */ \"(ssr)/./node_modules/react-router/dist/index.js\");\n/* harmony import */ var react_router__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @remix-run/router */ \"(ssr)/./node_modules/@remix-run/router/dist/router.js\");\n/**\n * React Router DOM v6.20.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ \n\n\n\n\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nconst defaultMethod = \"get\";\nconst defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n    return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n    return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n    return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n    return event.button === 0 && // Ignore everything but left clicks\n    (!target || target === \"_self\") && // Let browser handle \"target=_blank\" etc.\n    !isModifiedEvent(event) // Ignore clicks with modifier keys\n    ;\n}\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */ function createSearchParams(init) {\n    if (init === void 0) {\n        init = \"\";\n    }\n    return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key)=>{\n        let value = init[key];\n        return memo.concat(Array.isArray(value) ? value.map((v)=>[\n                key,\n                v\n            ]) : [\n            [\n                key,\n                value\n            ]\n        ]);\n    }, []));\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n    let searchParams = createSearchParams(locationSearch);\n    if (defaultSearchParams) {\n        // Use `defaultSearchParams.forEach(...)` here instead of iterating of\n        // `defaultSearchParams.keys()` to work-around a bug in Firefox related to\n        // web extensions. Relevant Bugzilla tickets:\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1414602\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1023984\n        defaultSearchParams.forEach((_, key)=>{\n            if (!searchParams.has(key)) {\n                defaultSearchParams.getAll(key).forEach((value)=>{\n                    searchParams.append(key, value);\n                });\n            }\n        });\n    }\n    return searchParams;\n}\n// One-time check for submitter support\nlet _formDataSupportsSubmitter = null;\nfunction isFormDataSubmitterSupported() {\n    if (_formDataSupportsSubmitter === null) {\n        try {\n            new FormData(document.createElement(\"form\"), // @ts-expect-error if FormData supports the submitter parameter, this will throw\n            0);\n            _formDataSupportsSubmitter = false;\n        } catch (e) {\n            _formDataSupportsSubmitter = true;\n        }\n    }\n    return _formDataSupportsSubmitter;\n}\nconst supportedFormEncTypes = new Set([\n    \"application/x-www-form-urlencoded\",\n    \"multipart/form-data\",\n    \"text/plain\"\n]);\nfunction getFormEncType(encType) {\n    if (encType != null && !supportedFormEncTypes.has(encType)) {\n         true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(false, '\"' + encType + '\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to \"' + defaultEncType + '\"')) : 0;\n        return null;\n    }\n    return encType;\n}\nfunction getFormSubmissionInfo(target, basename) {\n    let method;\n    let action;\n    let encType;\n    let formData;\n    let body;\n    if (isFormElement(target)) {\n        // When grabbing the action from the element, it will have had the basename\n        // prefixed to ensure non-JS scenarios work, so strip it since we'll\n        // re-prefix in the router\n        let attr = target.getAttribute(\"action\");\n        action = attr ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(attr, basename) : null;\n        method = target.getAttribute(\"method\") || defaultMethod;\n        encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n        formData = new FormData(target);\n    } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n        let form = target.form;\n        if (form == null) {\n            throw new Error('Cannot submit a <button> or <input type=\"submit\"> without a <form>');\n        }\n        // <button>/<input type=\"submit\"> may override attributes of <form>\n        // When grabbing the action from the element, it will have had the basename\n        // prefixed to ensure non-JS scenarios work, so strip it since we'll\n        // re-prefix in the router\n        let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n        action = attr ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(attr, basename) : null;\n        method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n        encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\n        // Build a FormData object populated from a form and submitter\n        formData = new FormData(form, target);\n        // If this browser doesn't support the `FormData(el, submitter)` format,\n        // then tack on the submitter value at the end.  This is a lightweight\n        // solution that is not 100% spec compliant.  For complete support in older\n        // browsers, consider using the `formdata-submitter-polyfill` package\n        if (!isFormDataSubmitterSupported()) {\n            let { name, type, value } = target;\n            if (type === \"image\") {\n                let prefix = name ? name + \".\" : \"\";\n                formData.append(prefix + \"x\", \"0\");\n                formData.append(prefix + \"y\", \"0\");\n            } else if (name) {\n                formData.append(name, value);\n            }\n        }\n    } else if (isHtmlElement(target)) {\n        throw new Error(\"Cannot submit element that is not <form>, <button>, or \" + '<input type=\"submit|image\">');\n    } else {\n        method = defaultMethod;\n        action = null;\n        encType = defaultEncType;\n        body = target;\n    }\n    // Send body for <Form encType=\"text/plain\" so we encode it into text\n    if (formData && encType === \"text/plain\") {\n        body = formData;\n        formData = undefined;\n    }\n    return {\n        action,\n        method: method.toLowerCase(),\n        encType,\n        formData,\n        body\n    };\n}\nconst _excluded = [\n    \"onClick\",\n    \"relative\",\n    \"reloadDocument\",\n    \"replace\",\n    \"state\",\n    \"target\",\n    \"to\",\n    \"preventScrollReset\",\n    \"unstable_viewTransition\"\n], _excluded2 = [\n    \"aria-current\",\n    \"caseSensitive\",\n    \"className\",\n    \"end\",\n    \"style\",\n    \"to\",\n    \"unstable_viewTransition\",\n    \"children\"\n], _excluded3 = [\n    \"fetcherKey\",\n    \"navigate\",\n    \"reloadDocument\",\n    \"replace\",\n    \"state\",\n    \"method\",\n    \"action\",\n    \"onSubmit\",\n    \"relative\",\n    \"preventScrollReset\",\n    \"unstable_viewTransition\"\n];\nfunction createBrowserRouter(routes, opts) {\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: _extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createBrowserHistory)({\n            window: opts == null ? void 0 : opts.window\n        }),\n        hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n        routes,\n        mapRouteProperties: react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_mapRouteProperties,\n        window: opts == null ? void 0 : opts.window\n    }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createRouter)({\n        basename: opts == null ? void 0 : opts.basename,\n        future: _extends({}, opts == null ? void 0 : opts.future, {\n            v7_prependBasename: true\n        }),\n        history: (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createHashHistory)({\n            window: opts == null ? void 0 : opts.window\n        }),\n        hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n        routes,\n        mapRouteProperties: react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_mapRouteProperties,\n        window: opts == null ? void 0 : opts.window\n    }).initialize();\n}\nfunction parseHydrationData() {\n    var _window;\n    let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\n    if (state && state.errors) {\n        state = _extends({}, state, {\n            errors: deserializeErrors(state.errors)\n        });\n    }\n    return state;\n}\nfunction deserializeErrors(errors) {\n    if (!errors) return null;\n    let entries = Object.entries(errors);\n    let serialized = {};\n    for (let [key, val] of entries){\n        // Hey you!  If you change this, please change the corresponding logic in\n        // serializeErrors in react-router-dom/server.tsx :)\n        if (val && val.__type === \"RouteErrorResponse\") {\n            serialized[key] = new react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n        } else if (val && val.__type === \"Error\") {\n            // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\n            if (val.__subType) {\n                let ErrorConstructor = window[val.__subType];\n                if (typeof ErrorConstructor === \"function\") {\n                    try {\n                        // @ts-expect-error\n                        let error = new ErrorConstructor(val.message);\n                        // Wipe away the client-side stack trace.  Nothing to fill it in with\n                        // because we don't serialize SSR stack traces for security reasons\n                        error.stack = \"\";\n                        serialized[key] = error;\n                    } catch (e) {\n                    // no-op - fall through and create a normal Error\n                    }\n                }\n            }\n            if (serialized[key] == null) {\n                let error = new Error(val.message);\n                // Wipe away the client-side stack trace.  Nothing to fill it in with\n                // because we don't serialize SSR stack traces for security reasons\n                error.stack = \"\";\n                serialized[key] = error;\n            }\n        } else {\n            serialized[key] = val;\n        }\n    }\n    return serialized;\n}\nconst ViewTransitionContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    isTransitioning: false\n});\nif (true) {\n    ViewTransitionContext.displayName = \"ViewTransition\";\n}\nconst FetchersContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(new Map());\nif (true) {\n    FetchersContext.displayName = \"Fetchers\";\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Components\n////////////////////////////////////////////////////////////////////////////////\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/ const START_TRANSITION = \"startTransition\";\nconst startTransitionImpl = react__WEBPACK_IMPORTED_MODULE_0__[START_TRANSITION];\nconst FLUSH_SYNC = \"flushSync\";\nconst flushSyncImpl = react_dom__WEBPACK_IMPORTED_MODULE_1__[FLUSH_SYNC];\nfunction startTransitionSafe(cb) {\n    if (startTransitionImpl) {\n        startTransitionImpl(cb);\n    } else {\n        cb();\n    }\n}\nfunction flushSyncSafe(cb) {\n    if (flushSyncImpl) {\n        flushSyncImpl(cb);\n    } else {\n        cb();\n    }\n}\nclass Deferred {\n    constructor(){\n        this.status = \"pending\";\n        this.promise = new Promise((resolve, reject)=>{\n            this.resolve = (value)=>{\n                if (this.status === \"pending\") {\n                    this.status = \"resolved\";\n                    resolve(value);\n                }\n            };\n            this.reject = (reason)=>{\n                if (this.status === \"pending\") {\n                    this.status = \"rejected\";\n                    reject(reason);\n                }\n            };\n        });\n    }\n}\n/**\n * Given a Remix Router instance, render the appropriate UI\n */ function RouterProvider(_ref) {\n    let { fallbackElement, router, future } = _ref;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState(router.state);\n    let [pendingState, setPendingState] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    let [vtContext, setVtContext] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        isTransitioning: false\n    });\n    let [renderDfd, setRenderDfd] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    let [transition, setTransition] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    let [interruption, setInterruption] = react__WEBPACK_IMPORTED_MODULE_0__.useState();\n    let fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new Map());\n    let { v7_startTransition } = future || {};\n    let optInStartTransition = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((cb)=>{\n        if (v7_startTransition) {\n            startTransitionSafe(cb);\n        } else {\n            cb();\n        }\n    }, [\n        v7_startTransition\n    ]);\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState, _ref2)=>{\n        let { deletedFetchers, unstable_flushSync: flushSync, unstable_viewTransitionOpts: viewTransitionOpts } = _ref2;\n        deletedFetchers.forEach((key)=>fetcherData.current.delete(key));\n        newState.fetchers.forEach((fetcher, key)=>{\n            if (fetcher.data !== undefined) {\n                fetcherData.current.set(key, fetcher.data);\n            }\n        });\n        let isViewTransitionUnavailable = router.window == null || typeof router.window.document.startViewTransition !== \"function\";\n        // If this isn't a view transition or it's not available in this browser,\n        // just update and be done with it\n        if (!viewTransitionOpts || isViewTransitionUnavailable) {\n            if (flushSync) {\n                flushSyncSafe(()=>setStateImpl(newState));\n            } else {\n                optInStartTransition(()=>setStateImpl(newState));\n            }\n            return;\n        }\n        // flushSync + startViewTransition\n        if (flushSync) {\n            // Flush through the context to mark DOM elements as transition=ing\n            flushSyncSafe(()=>{\n                // Cancel any pending transitions\n                if (transition) {\n                    renderDfd && renderDfd.resolve();\n                    transition.skipTransition();\n                }\n                setVtContext({\n                    isTransitioning: true,\n                    flushSync: true,\n                    currentLocation: viewTransitionOpts.currentLocation,\n                    nextLocation: viewTransitionOpts.nextLocation\n                });\n            });\n            // Update the DOM\n            let t = router.window.document.startViewTransition(()=>{\n                flushSyncSafe(()=>setStateImpl(newState));\n            });\n            // Clean up after the animation completes\n            t.finished.finally(()=>{\n                flushSyncSafe(()=>{\n                    setRenderDfd(undefined);\n                    setTransition(undefined);\n                    setPendingState(undefined);\n                    setVtContext({\n                        isTransitioning: false\n                    });\n                });\n            });\n            flushSyncSafe(()=>setTransition(t));\n            return;\n        }\n        // startTransition + startViewTransition\n        if (transition) {\n            // Interrupting an in-progress transition, cancel and let everything flush\n            // out, and then kick off a new transition from the interruption state\n            renderDfd && renderDfd.resolve();\n            transition.skipTransition();\n            setInterruption({\n                state: newState,\n                currentLocation: viewTransitionOpts.currentLocation,\n                nextLocation: viewTransitionOpts.nextLocation\n            });\n        } else {\n            // Completed navigation update with opted-in view transitions, let 'er rip\n            setPendingState(newState);\n            setVtContext({\n                isTransitioning: true,\n                flushSync: false,\n                currentLocation: viewTransitionOpts.currentLocation,\n                nextLocation: viewTransitionOpts.nextLocation\n            });\n        }\n    }, [\n        router.window,\n        transition,\n        renderDfd,\n        fetcherData,\n        optInStartTransition\n    ]);\n    // Need to use a layout effect here so we are subscribed early enough to\n    // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>router.subscribe(setState), [\n        router,\n        setState\n    ]);\n    // When we start a view transition, create a Deferred we can use for the\n    // eventual \"completed\" render\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (vtContext.isTransitioning && !vtContext.flushSync) {\n            setRenderDfd(new Deferred());\n        }\n    }, [\n        vtContext\n    ]);\n    // Once the deferred is created, kick off startViewTransition() to update the\n    // DOM and then wait on the Deferred to resolve (indicating the DOM update has\n    // happened)\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (renderDfd && pendingState && router.window) {\n            let newState = pendingState;\n            let renderPromise = renderDfd.promise;\n            let transition = router.window.document.startViewTransition(async ()=>{\n                optInStartTransition(()=>setStateImpl(newState));\n                await renderPromise;\n            });\n            transition.finished.finally(()=>{\n                setRenderDfd(undefined);\n                setTransition(undefined);\n                setPendingState(undefined);\n                setVtContext({\n                    isTransitioning: false\n                });\n            });\n            setTransition(transition);\n        }\n    }, [\n        optInStartTransition,\n        pendingState,\n        renderDfd,\n        router.window\n    ]);\n    // When the new location finally renders and is committed to the DOM, this\n    // effect will run to resolve the transition\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\n            renderDfd.resolve();\n        }\n    }, [\n        renderDfd,\n        transition,\n        state.location,\n        pendingState\n    ]);\n    // If we get interrupted with a new navigation during a transition, we skip\n    // the active transition, let it cleanup, then kick it off again here\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!vtContext.isTransitioning && interruption) {\n            setPendingState(interruption.state);\n            setVtContext({\n                isTransitioning: true,\n                flushSync: false,\n                currentLocation: interruption.currentLocation,\n                nextLocation: interruption.nextLocation\n            });\n            setInterruption(undefined);\n        }\n    }, [\n        vtContext.isTransitioning,\n        interruption\n    ]);\n    let navigator = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        return {\n            createHref: router.createHref,\n            encodeLocation: router.encodeLocation,\n            go: (n)=>router.navigate(n),\n            push: (to, state, opts)=>router.navigate(to, {\n                    state,\n                    preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n                }),\n            replace: (to, state, opts)=>router.navigate(to, {\n                    replace: true,\n                    state,\n                    preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n                })\n        };\n    }, [\n        router\n    ]);\n    let basename = router.basename || \"/\";\n    let dataRouterContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            router,\n            navigator,\n            static: false,\n            basename\n        }), [\n        router,\n        navigator,\n        basename\n    ]);\n    // The fragment and {null} here are important!  We need them to keep React 18's\n    // useId happy when we are server-rendering since we may have a <script> here\n    // containing the hydrated server-side staticContext (from StaticRouterProvider).\n    // useId relies on the component tree structure to generate deterministic id's\n    // so we need to ensure it remains the same on the client even though\n    // we don't need the <script> tag\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterContext.Provider, {\n        value: dataRouterContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterStateContext.Provider, {\n        value: state\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(FetchersContext.Provider, {\n        value: fetcherData.current\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ViewTransitionContext.Provider, {\n        value: vtContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.Router, {\n        basename: basename,\n        location: state.location,\n        navigationType: state.historyAction,\n        navigator: navigator\n    }, state.initialized ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(DataRoutes, {\n        routes: router.routes,\n        state: state\n    }) : fallbackElement))))), null);\n}\nfunction DataRoutes(_ref3) {\n    let { routes, state } = _ref3;\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_useRoutesImpl)(routes, undefined, state);\n}\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */ function BrowserRouter(_ref4) {\n    let { basename, children, future, window: window1 } = _ref4;\n    let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createBrowserHistory)({\n            window: window1,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    let { v7_startTransition } = future || {};\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState)=>{\n        v7_startTransition && startTransitionImpl ? startTransitionImpl(()=>setStateImpl(newState)) : setStateImpl(newState);\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */ function HashRouter(_ref5) {\n    let { basename, children, future, window: window1 } = _ref5;\n    let historyRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    if (historyRef.current == null) {\n        historyRef.current = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createHashHistory)({\n            window: window1,\n            v5Compat: true\n        });\n    }\n    let history = historyRef.current;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    let { v7_startTransition } = future || {};\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState)=>{\n        v7_startTransition && startTransitionImpl ? startTransitionImpl(()=>setStateImpl(newState)) : setStateImpl(newState);\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */ function HistoryRouter(_ref6) {\n    let { basename, children, future, history } = _ref6;\n    let [state, setStateImpl] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        action: history.action,\n        location: history.location\n    });\n    let { v7_startTransition } = future || {};\n    let setState = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((newState)=>{\n        v7_startTransition && startTransitionImpl ? startTransitionImpl(()=>setStateImpl(newState)) : setStateImpl(newState);\n    }, [\n        setStateImpl,\n        v7_startTransition\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>history.listen(setState), [\n        history,\n        setState\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react_router__WEBPACK_IMPORTED_MODULE_3__.Router, {\n        basename: basename,\n        children: children,\n        location: state.location,\n        navigationType: state.action,\n        navigator: history\n    });\n}\nif (true) {\n    HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\nconst isBrowser =  false && 0;\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n/**\n * The public API for rendering a history-aware `<a>`.\n */ const Link = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function LinkWithRef(_ref7, ref) {\n    let { onClick, relative, reloadDocument, replace, state, target, to, preventScrollReset, unstable_viewTransition } = _ref7, rest = _objectWithoutPropertiesLoose(_ref7, _excluded);\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n    // Rendered into <a href> for absolute URLs\n    let absoluteHref;\n    let isExternal = false;\n    if (typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to)) {\n        // Render the absolute href server- and client-side\n        absoluteHref = to;\n        // Only check for external origins client-side\n        if (isBrowser) {\n            try {\n                let currentUrl = new URL(window.location.href);\n                let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n                let path = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(targetUrl.pathname, basename);\n                if (targetUrl.origin === currentUrl.origin && path != null) {\n                    // Strip the protocol/origin/basename for same-origin absolute URLs\n                    to = path + targetUrl.search + targetUrl.hash;\n                } else {\n                    isExternal = true;\n                }\n            } catch (e) {\n                // We can't do external URL detection without a valid URL\n                 true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(false, '<Link to=\"' + to + '\"> contains an invalid URL which will probably break ' + \"when clicked - please update to a valid URL path.\") : 0;\n            }\n        }\n    }\n    // Rendered into <a href> for relative URLs\n    let href = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useHref)(to, {\n        relative\n    });\n    let internalOnClick = useLinkClickHandler(to, {\n        replace,\n        state,\n        target,\n        preventScrollReset,\n        relative,\n        unstable_viewTransition\n    });\n    function handleClick(event) {\n        if (onClick) onClick(event);\n        if (!event.defaultPrevented) {\n            internalOnClick(event);\n        }\n    }\n    return(/*#__PURE__*/ // eslint-disable-next-line jsx-a11y/anchor-has-content\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"a\", _extends({}, rest, {\n        href: absoluteHref || href,\n        onClick: isExternal || reloadDocument ? onClick : handleClick,\n        ref: ref,\n        target: target\n    })));\n});\nif (true) {\n    Link.displayName = \"Link\";\n}\n/**\n * A `<Link>` wrapper that knows if it's \"active\" or not.\n */ const NavLink = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function NavLinkWithRef(_ref8, ref) {\n    let { \"aria-current\": ariaCurrentProp = \"page\", caseSensitive = false, className: classNameProp = \"\", end = false, style: styleProp, to, unstable_viewTransition, children } = _ref8, rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);\n    let path = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath)(to, {\n        relative: rest.relative\n    });\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n    let routerState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterStateContext);\n    let { navigator } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n    let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useViewTransitionState(path) && unstable_viewTransition === true;\n    let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n    let locationPathname = location.pathname;\n    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n    if (!caseSensitive) {\n        locationPathname = locationPathname.toLowerCase();\n        nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n        toPathname = toPathname.toLowerCase();\n    }\n    // If the `to` has a trailing slash, look at that exact spot.  Otherwise,\n    // we're looking for a slash _after_ what's in `to`.  For example:\n    //\n    // <NavLink to=\"/users\"> and <NavLink to=\"/users/\">\n    // both want to look for a / at index 6 to match URL `/users/matt`\n    const endSlashPosition = toPathname !== \"/\" && toPathname.endsWith(\"/\") ? toPathname.length - 1 : toPathname.length;\n    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === \"/\";\n    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n    let renderProps = {\n        isActive,\n        isPending,\n        isTransitioning\n    };\n    let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n    let className;\n    if (typeof classNameProp === \"function\") {\n        className = classNameProp(renderProps);\n    } else {\n        // If the className prop is not a function, we use a default `active`\n        // class for <NavLink />s that are active. In v5 `active` was the default\n        // value for `activeClassName`, but we are removing that API and can still\n        // use the old default behavior for a cleaner upgrade path and keep the\n        // simple styling rules working as they currently do.\n        className = [\n            classNameProp,\n            isActive ? \"active\" : null,\n            isPending ? \"pending\" : null,\n            isTransitioning ? \"transitioning\" : null\n        ].filter(Boolean).join(\" \");\n    }\n    let style = typeof styleProp === \"function\" ? styleProp(renderProps) : styleProp;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Link, _extends({}, rest, {\n        \"aria-current\": ariaCurrent,\n        className: className,\n        ref: ref,\n        style: style,\n        to: to,\n        unstable_viewTransition: unstable_viewTransition\n    }), typeof children === \"function\" ? children(renderProps) : children);\n});\nif (true) {\n    NavLink.displayName = \"NavLink\";\n}\n/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */ const Form = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((_ref9, forwardedRef)=>{\n    let { fetcherKey, navigate, reloadDocument, replace, state, method = defaultMethod, action, onSubmit, relative, preventScrollReset, unstable_viewTransition } = _ref9, props = _objectWithoutPropertiesLoose(_ref9, _excluded3);\n    let submit = useSubmit();\n    let formAction = useFormAction(action, {\n        relative\n    });\n    let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n    let submitHandler = (event)=>{\n        onSubmit && onSubmit(event);\n        if (event.defaultPrevented) return;\n        event.preventDefault();\n        let submitter = event.nativeEvent.submitter;\n        let submitMethod = (submitter == null ? void 0 : submitter.getAttribute(\"formmethod\")) || method;\n        submit(submitter || event.currentTarget, {\n            fetcherKey,\n            method: submitMethod,\n            navigate,\n            replace,\n            state,\n            relative,\n            preventScrollReset,\n            unstable_viewTransition\n        });\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"form\", _extends({\n        ref: forwardedRef,\n        method: formMethod,\n        action: formAction,\n        onSubmit: reloadDocument ? onSubmit : submitHandler\n    }, props));\n});\nif (true) {\n    Form.displayName = \"Form\";\n}\n/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n */ function ScrollRestoration(_ref10) {\n    let { getKey, storageKey } = _ref10;\n    useScrollRestoration({\n        getKey,\n        storageKey\n    });\n    return null;\n}\nif (true) {\n    ScrollRestoration.displayName = \"ScrollRestoration\";\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\nvar DataRouterHook;\n(function(DataRouterHook) {\n    DataRouterHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n    DataRouterHook[\"UseSubmit\"] = \"useSubmit\";\n    DataRouterHook[\"UseSubmitFetcher\"] = \"useSubmitFetcher\";\n    DataRouterHook[\"UseFetcher\"] = \"useFetcher\";\n    DataRouterHook[\"useViewTransitionState\"] = \"useViewTransitionState\";\n})(DataRouterHook || (DataRouterHook = {}));\nvar DataRouterStateHook;\n(function(DataRouterStateHook) {\n    DataRouterStateHook[\"UseFetcher\"] = \"useFetcher\";\n    DataRouterStateHook[\"UseFetchers\"] = \"useFetchers\";\n    DataRouterStateHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n})(DataRouterStateHook || (DataRouterStateHook = {}));\n// Internal hooks\nfunction getDataRouterConsoleError(hookName) {\n    return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n    let ctx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterContext);\n    !ctx ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return ctx;\n}\nfunction useDataRouterState(hookName) {\n    let state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_DataRouterStateContext);\n    !state ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, getDataRouterConsoleError(hookName)) : 0 : void 0;\n    return state;\n}\n// External hooks\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */ function useLinkClickHandler(to, _temp) {\n    let { target, replace: replaceProp, state, preventScrollReset, relative, unstable_viewTransition } = _temp === void 0 ? {} : _temp;\n    let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigate)();\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n    let path = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath)(to, {\n        relative\n    });\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event)=>{\n        if (shouldProcessLinkClick(event, target)) {\n            event.preventDefault();\n            // If the URL hasn't changed, a regular <a> will do a replace instead of\n            // a push, so do the same here unless the replace prop is explicitly set\n            let replace = replaceProp !== undefined ? replaceProp : (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createPath)(location) === (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createPath)(path);\n            navigate(to, {\n                replace,\n                state,\n                preventScrollReset,\n                relative,\n                unstable_viewTransition\n            });\n        }\n    }, [\n        location,\n        navigate,\n        path,\n        replaceProp,\n        state,\n        target,\n        to,\n        preventScrollReset,\n        relative,\n        unstable_viewTransition\n    ]);\n}\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */ function useSearchParams(defaultInit) {\n     true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not \" + \"support the URLSearchParams API. If you need to support Internet \" + \"Explorer 11, we recommend you load a polyfill such as \" + \"https://github.com/ungap/url-search-params\\n\\n\" + \"If you're unsure how to load polyfills, we recommend you check out \" + \"https://polyfill.io/v3/ which provides some recommendations about how \" + \"to load polyfills only for users that need them, instead of for every \" + \"user.\") : 0;\n    let defaultSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(createSearchParams(defaultInit));\n    let hasSetSearchParamsRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n    let searchParams = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>// Only merge in the defaults if we haven't yet called setSearchParams.\n        // Once we call that we want those to take precedence, otherwise you can't\n        // remove a param with setSearchParams({}) if it has an initial value\n        getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [\n        location.search\n    ]);\n    let navigate = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigate)();\n    let setSearchParams = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((nextInit, navigateOptions)=>{\n        const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n        hasSetSearchParamsRef.current = true;\n        navigate(\"?\" + newSearchParams, navigateOptions);\n    }, [\n        navigate,\n        searchParams\n    ]);\n    return [\n        searchParams,\n        setSearchParams\n    ];\n}\nfunction validateClientSideSubmission() {\n    if (typeof document === \"undefined\") {\n        throw new Error(\"You are calling submit during the server render. \" + \"Try calling submit within a `useEffect` or callback instead.\");\n    }\n}\nlet fetcherId = 0;\nlet getUniqueFetcherId = ()=>\"__\" + String(++fetcherId) + \"__\";\n/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */ function useSubmit() {\n    let { router } = useDataRouterContext(DataRouterHook.UseSubmit);\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n    let currentRouteId = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_useRouteId)();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function(target, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        validateClientSideSubmission();\n        let { action, method, encType, formData, body } = getFormSubmissionInfo(target, basename);\n        if (options.navigate === false) {\n            let key = options.fetcherKey || getUniqueFetcherId();\n            router.fetch(key, currentRouteId, options.action || action, {\n                preventScrollReset: options.preventScrollReset,\n                formData,\n                body,\n                formMethod: options.method || method,\n                formEncType: options.encType || encType,\n                unstable_flushSync: options.unstable_flushSync\n            });\n        } else {\n            router.navigate(options.action || action, {\n                preventScrollReset: options.preventScrollReset,\n                formData,\n                body,\n                formMethod: options.method || method,\n                formEncType: options.encType || encType,\n                replace: options.replace,\n                state: options.state,\n                fromRouteId: currentRouteId,\n                unstable_flushSync: options.unstable_flushSync,\n                unstable_viewTransition: options.unstable_viewTransition\n            });\n        }\n    }, [\n        router,\n        basename,\n        currentRouteId\n    ]);\n}\n// v7: Eventually we should deprecate this entirely in favor of using the\n// router method directly?\nfunction useFormAction(action, _temp2) {\n    let { relative } = _temp2 === void 0 ? {} : _temp2;\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n    let routeContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_RouteContext);\n    !routeContext ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"useFormAction must be used inside a RouteContext\") : 0 : void 0;\n    let [match] = routeContext.matches.slice(-1);\n    // Shallow clone path so we can modify it below, otherwise we modify the\n    // object referenced by useMemo inside useResolvedPath\n    let path = _extends({}, (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath)(action ? action : \".\", {\n        relative\n    }));\n    // Previously we set the default action to \".\". The problem with this is that\n    // `useResolvedPath(\".\")` excludes search params of the resolved URL. This is\n    // the intended behavior of when \".\" is specifically provided as\n    // the form action, but inconsistent w/ browsers when the action is omitted.\n    // https://github.com/remix-run/remix/issues/927\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n    if (action == null) {\n        // Safe to write to this directly here since if action was undefined, we\n        // would have called useResolvedPath(\".\") which will never include a search\n        path.search = location.search;\n        // When grabbing search params from the URL, remove any included ?index param\n        // since it might not apply to our contextual route.  We add it back based\n        // on match.route.index below\n        let params = new URLSearchParams(path.search);\n        if (params.has(\"index\") && params.get(\"index\") === \"\") {\n            params.delete(\"index\");\n            path.search = params.toString() ? \"?\" + params.toString() : \"\";\n        }\n    }\n    if ((!action || action === \".\") && match.route.index) {\n        path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    }\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to creating the form action.  If this is a root navigation, then just use\n    // the raw basename which allows the basename to have full control over the\n    // presence of a trailing slash on root actions\n    if (basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : (0,react_router__WEBPACK_IMPORTED_MODULE_2__.joinPaths)([\n            basename,\n            path.pathname\n        ]);\n    }\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_2__.createPath)(path);\n}\n// TODO: (v7) Change the useFetcher generic default from `any` to `unknown`\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */ function useFetcher(_temp3) {\n    var _route$matches;\n    let { key } = _temp3 === void 0 ? {} : _temp3;\n    let { router } = useDataRouterContext(DataRouterHook.UseFetcher);\n    let state = useDataRouterState(DataRouterStateHook.UseFetcher);\n    let fetcherData = react__WEBPACK_IMPORTED_MODULE_0__.useContext(FetchersContext);\n    let route = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_RouteContext);\n    let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n    !fetcherData ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"useFetcher must be used inside a FetchersContext\") : 0 : void 0;\n    !route ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"useFetcher must be used inside a RouteContext\") : 0 : void 0;\n    !(routeId != null) ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, 'useFetcher can only be used on routes that contain a unique \"id\"') : 0 : void 0;\n    // Fetcher key handling\n    let [fetcherKey, setFetcherKey] = react__WEBPACK_IMPORTED_MODULE_0__.useState(key || \"\");\n    if (key && key !== fetcherKey) {\n        setFetcherKey(key);\n    } else if (!fetcherKey) {\n        setFetcherKey(getUniqueFetcherId());\n    }\n    // Registration/cleanup\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        router.getFetcher(fetcherKey);\n        return ()=>{\n            // Tell the router we've unmounted - if v7_fetcherPersist is enabled this\n            // will not delete immediately but instead queue up a delete after the\n            // fetcher returns to an `idle` state\n            router.deleteFetcher(fetcherKey);\n        };\n    }, [\n        router,\n        fetcherKey\n    ]);\n    // Fetcher additions\n    let load = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((href, opts)=>{\n        !routeId ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"No routeId available for fetcher.load()\") : 0 : void 0;\n        router.fetch(fetcherKey, routeId, href, opts);\n    }, [\n        fetcherKey,\n        routeId,\n        router\n    ]);\n    let submitImpl = useSubmit();\n    let submit = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((target, opts)=>{\n        submitImpl(target, _extends({}, opts, {\n            navigate: false,\n            fetcherKey\n        }));\n    }, [\n        fetcherKey,\n        submitImpl\n    ]);\n    let FetcherForm = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        let FetcherForm = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref)=>{\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Form, _extends({}, props, {\n                navigate: false,\n                fetcherKey: fetcherKey,\n                ref: ref\n            }));\n        });\n        if (true) {\n            FetcherForm.displayName = \"fetcher.Form\";\n        }\n        return FetcherForm;\n    }, [\n        fetcherKey\n    ]);\n    // Exposed FetcherWithComponents\n    let fetcher = state.fetchers.get(fetcherKey) || react_router__WEBPACK_IMPORTED_MODULE_2__.IDLE_FETCHER;\n    let data = fetcherData.get(fetcherKey);\n    let fetcherWithComponents = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>_extends({\n            Form: FetcherForm,\n            submit,\n            load\n        }, fetcher, {\n            data\n        }), [\n        FetcherForm,\n        submit,\n        load,\n        fetcher,\n        data\n    ]);\n    return fetcherWithComponents;\n}\n/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */ function useFetchers() {\n    let state = useDataRouterState(DataRouterStateHook.UseFetchers);\n    return Array.from(state.fetchers.entries()).map((_ref11)=>{\n        let [key, fetcher] = _ref11;\n        return _extends({}, fetcher, {\n            key\n        });\n    });\n}\nconst SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nlet savedScrollPositions = {};\n/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */ function useScrollRestoration(_temp4) {\n    let { getKey, storageKey } = _temp4 === void 0 ? {} : _temp4;\n    let { router } = useDataRouterContext(DataRouterHook.UseScrollRestoration);\n    let { restoreScrollPosition, preventScrollReset } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);\n    let { basename } = react__WEBPACK_IMPORTED_MODULE_0__.useContext(react_router__WEBPACK_IMPORTED_MODULE_3__.UNSAFE_NavigationContext);\n    let location = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useLocation)();\n    let matches = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useMatches)();\n    let navigation = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useNavigation)();\n    // Trigger manual scroll restoration while we're active\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        window.history.scrollRestoration = \"manual\";\n        return ()=>{\n            window.history.scrollRestoration = \"auto\";\n        };\n    }, []);\n    // Save positions on pagehide\n    usePageHide(react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>{\n        if (navigation.state === \"idle\") {\n            let key = (getKey ? getKey(location, matches) : null) || location.key;\n            savedScrollPositions[key] = window.scrollY;\n        }\n        try {\n            sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n        } catch (error) {\n             true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_warning)(false, \"Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (\" + error + \").\") : 0;\n        }\n        window.history.scrollRestoration = \"auto\";\n    }, [\n        storageKey,\n        getKey,\n        navigation.state,\n        location,\n        matches\n    ]));\n    // Read in any saved scroll locations\n    if (typeof document !== \"undefined\") {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n            try {\n                let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n                if (sessionPositions) {\n                    savedScrollPositions = JSON.parse(sessionPositions);\n                }\n            } catch (e) {\n            // no-op, use default empty object\n            }\n        }, [\n            storageKey\n        ]);\n        // Enable scroll restoration in the router\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n            let getKeyWithoutBasename = getKey && basename !== \"/\" ? (location, matches)=>getKey(_extends({}, location, {\n                    pathname: (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(location.pathname, basename) || location.pathname\n                }), matches) : getKey;\n            let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, ()=>window.scrollY, getKeyWithoutBasename);\n            return ()=>disableScrollRestoration && disableScrollRestoration();\n        }, [\n            router,\n            basename,\n            getKey\n        ]);\n        // Restore scrolling when state.restoreScrollPosition changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n            // Explicit false means don't do anything (used for submissions)\n            if (restoreScrollPosition === false) {\n                return;\n            }\n            // been here before, scroll to it\n            if (typeof restoreScrollPosition === \"number\") {\n                window.scrollTo(0, restoreScrollPosition);\n                return;\n            }\n            // try to scroll to the hash\n            if (location.hash) {\n                let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\n                if (el) {\n                    el.scrollIntoView();\n                    return;\n                }\n            }\n            // Don't reset if this navigation opted out\n            if (preventScrollReset === true) {\n                return;\n            }\n            // otherwise go to the top on new locations\n            window.scrollTo(0, 0);\n        }, [\n            location,\n            restoreScrollPosition,\n            preventScrollReset\n        ]);\n    }\n}\n/**\n * Setup a callback to be fired on the window's `beforeunload` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */ function useBeforeUnload(callback, options) {\n    let { capture } = options || {};\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        let opts = capture != null ? {\n            capture\n        } : undefined;\n        window.addEventListener(\"beforeunload\", callback, opts);\n        return ()=>{\n            window.removeEventListener(\"beforeunload\", callback, opts);\n        };\n    }, [\n        callback,\n        capture\n    ]);\n}\n/**\n * Setup a callback to be fired on the window's `pagehide` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.  This event is better supported than beforeunload across browsers.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */ function usePageHide(callback, options) {\n    let { capture } = options || {};\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        let opts = capture != null ? {\n            capture\n        } : undefined;\n        window.addEventListener(\"pagehide\", callback, opts);\n        return ()=>{\n            window.removeEventListener(\"pagehide\", callback, opts);\n        };\n    }, [\n        callback,\n        capture\n    ]);\n}\n/**\n * Wrapper around useBlocker to show a window.confirm prompt to users instead\n * of building a custom UI with useBlocker.\n *\n * Warning: This has *a lot of rough edges* and behaves very differently (and\n * very incorrectly in some cases) across browsers if user click addition\n * back/forward navigations while the confirm is open.  Use at your own risk.\n */ function usePrompt(_ref12) {\n    let { when, message } = _ref12;\n    let blocker = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useBlocker)(when);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (blocker.state === \"blocked\") {\n            let proceed = window.confirm(message);\n            if (proceed) {\n                // This timeout is needed to avoid a weird \"race\" on POP navigations\n                // between the `window.history` revert navigation and the result of\n                // `window.confirm`\n                setTimeout(blocker.proceed, 0);\n            } else {\n                blocker.reset();\n            }\n        }\n    }, [\n        blocker,\n        message\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (blocker.state === \"blocked\" && !when) {\n            blocker.reset();\n        }\n    }, [\n        blocker,\n        when\n    ]);\n}\n/**\n * Return a boolean indicating if there is an active view transition to the\n * given href.  You can use this value to render CSS classes or viewTransitionName\n * styles onto your elements\n *\n * @param href The destination href\n * @param [opts.relative] Relative routing type (\"route\" | \"path\")\n */ function useViewTransitionState(to, opts) {\n    if (opts === void 0) {\n        opts = {};\n    }\n    let vtContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ViewTransitionContext);\n    !(vtContext != null) ?  true ? (0,react_router__WEBPACK_IMPORTED_MODULE_2__.UNSAFE_invariant)(false, \"`unstable_useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  \" + \"Did you accidentally import `RouterProvider` from `react-router`?\") : 0 : void 0;\n    let { basename } = useDataRouterContext(DataRouterHook.useViewTransitionState);\n    let path = (0,react_router__WEBPACK_IMPORTED_MODULE_3__.useResolvedPath)(to, {\n        relative: opts.relative\n    });\n    if (!vtContext.isTransitioning) {\n        return false;\n    }\n    let currentPath = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\n    let nextPath = (0,react_router__WEBPACK_IMPORTED_MODULE_2__.stripBasename)(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\n    // Transition is active if we're going to or coming from the indicated\n    // destination.  This ensures that other PUSH navigations that reverse\n    // an indicated transition apply.  I.e., on the list view you have:\n    //\n    //   <NavLink to=\"/details/1\" unstable_viewTransition>\n    //\n    // If you click the breadcrumb back to the list view:\n    //\n    //   <NavLink to=\"/list\" unstable_viewTransition>\n    //\n    // We should apply the transition because it's indicated as active going\n    // from /list -> /details/1 and therefore should be active on the reverse\n    // (even though this isn't strictly a POP reverse)\n    return (0,react_router__WEBPACK_IMPORTED_MODULE_2__.matchPath)(path.pathname, nextPath) != null || (0,react_router__WEBPACK_IMPORTED_MODULE_2__.matchPath)(path.pathname, currentPath) != null;\n}\n//#endregion\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtcm91dGVyLWRvbS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztDQVNDLEdBQzhCO0FBQ087QUFDbVI7QUFDMGU7QUFDMWxCO0FBRXpNLFNBQVNnRTtJQUNQQSxXQUFXQyxPQUFPQyxNQUFNLEdBQUdELE9BQU9DLE1BQU0sQ0FBQ0MsSUFBSSxLQUFLLFNBQVVDLE1BQU07UUFDaEUsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlDLFVBQVVDLE1BQU0sRUFBRUYsSUFBSztZQUN6QyxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7WUFDekIsSUFBSyxJQUFJSSxPQUFPRCxPQUFRO2dCQUN0QixJQUFJUCxPQUFPUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDSixRQUFRQyxNQUFNO29CQUNyREwsTUFBTSxDQUFDSyxJQUFJLEdBQUdELE1BQU0sQ0FBQ0MsSUFBSTtnQkFDM0I7WUFDRjtRQUNGO1FBQ0EsT0FBT0w7SUFDVDtJQUNBLE9BQU9KLFNBQVNhLEtBQUssQ0FBQyxJQUFJLEVBQUVQO0FBQzlCO0FBQ0EsU0FBU1EsOEJBQThCTixNQUFNLEVBQUVPLFFBQVE7SUFDckQsSUFBSVAsVUFBVSxNQUFNLE9BQU8sQ0FBQztJQUM1QixJQUFJSixTQUFTLENBQUM7SUFDZCxJQUFJWSxhQUFhZixPQUFPZ0IsSUFBSSxDQUFDVDtJQUM3QixJQUFJQyxLQUFLSjtJQUNULElBQUtBLElBQUksR0FBR0EsSUFBSVcsV0FBV1QsTUFBTSxFQUFFRixJQUFLO1FBQ3RDSSxNQUFNTyxVQUFVLENBQUNYLEVBQUU7UUFDbkIsSUFBSVUsU0FBU0csT0FBTyxDQUFDVCxRQUFRLEdBQUc7UUFDaENMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUND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c3QvaW5kZXguanM/MDNhNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFJlYWN0IFJvdXRlciBET00gdjYuMjAuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgVU5TQUZFX21hcFJvdXRlUHJvcGVydGllcywgVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0LCBVTlNBRkVfRGF0YVJvdXRlclN0YXRlQ29udGV4dCwgUm91dGVyLCBVTlNBRkVfdXNlUm91dGVzSW1wbCwgVU5TQUZFX05hdmlnYXRpb25Db250ZXh0LCB1c2VIcmVmLCB1c2VSZXNvbHZlZFBhdGgsIHVzZUxvY2F0aW9uLCB1c2VOYXZpZ2F0ZSwgY3JlYXRlUGF0aCwgVU5TQUZFX3VzZVJvdXRlSWQsIFVOU0FGRV9Sb3V0ZUNvbnRleHQsIHVzZU1hdGNoZXMsIHVzZU5hdmlnYXRpb24sIHVzZUJsb2NrZXIgfSBmcm9tICdyZWFjdC1yb3V0ZXInO1xuZXhwb3J0IHsgQWJvcnRlZERlZmVycmVkRXJyb3IsIEF3YWl0LCBNZW1vcnlSb3V0ZXIsIE5hdmlnYXRlLCBOYXZpZ2F0aW9uVHlwZSwgT3V0bGV0LCBSb3V0ZSwgUm91dGVyLCBSb3V0ZXMsIFVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCwgVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQsIFVOU0FGRV9Mb2NhdGlvbkNvbnRleHQsIFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCwgVU5TQUZFX1JvdXRlQ29udGV4dCwgVU5TQUZFX3VzZVJvdXRlSWQsIGNyZWF0ZU1lbW9yeVJvdXRlciwgY3JlYXRlUGF0aCwgY3JlYXRlUm91dGVzRnJvbUNoaWxkcmVuLCBjcmVhdGVSb3V0ZXNGcm9tRWxlbWVudHMsIGRlZmVyLCBnZW5lcmF0ZVBhdGgsIGlzUm91dGVFcnJvclJlc3BvbnNlLCBqc29uLCBtYXRjaFBhdGgsIG1hdGNoUm91dGVzLCBwYXJzZVBhdGgsIHJlZGlyZWN0LCByZWRpcmVjdERvY3VtZW50LCByZW5kZXJNYXRjaGVzLCByZXNvbHZlUGF0aCwgdXNlQWN0aW9uRGF0YSwgdXNlQXN5bmNFcnJvciwgdXNlQXN5bmNWYWx1ZSwgdXNlQmxvY2tlciwgdXNlSHJlZiwgdXNlSW5Sb3V0ZXJDb250ZXh0LCB1c2VMb2FkZXJEYXRhLCB1c2VMb2NhdGlvbiwgdXNlTWF0Y2gsIHVzZU1hdGNoZXMsIHVzZU5hdmlnYXRlLCB1c2VOYXZpZ2F0aW9uLCB1c2VOYXZpZ2F0aW9uVHlwZSwgdXNlT3V0bGV0LCB1c2VPdXRsZXRDb250ZXh0LCB1c2VQYXJhbXMsIHVzZVJlc29sdmVkUGF0aCwgdXNlUmV2YWxpZGF0b3IsIHVzZVJvdXRlRXJyb3IsIHVzZVJvdXRlTG9hZGVyRGF0YSwgdXNlUm91dGVzIH0gZnJvbSAncmVhY3Qtcm91dGVyJztcbmltcG9ydCB7IHN0cmlwQmFzZW5hbWUsIFVOU0FGRV93YXJuaW5nLCBjcmVhdGVSb3V0ZXIsIGNyZWF0ZUJyb3dzZXJIaXN0b3J5LCBjcmVhdGVIYXNoSGlzdG9yeSwgVU5TQUZFX0Vycm9yUmVzcG9uc2VJbXBsLCBVTlNBRkVfaW52YXJpYW50LCBqb2luUGF0aHMsIElETEVfRkVUQ0hFUiwgbWF0Y2hQYXRoIH0gZnJvbSAnQHJlbWl4LXJ1bi9yb3V0ZXInO1xuXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmNvbnN0IGRlZmF1bHRNZXRob2QgPSBcImdldFwiO1xuY29uc3QgZGVmYXVsdEVuY1R5cGUgPSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiO1xuZnVuY3Rpb24gaXNIdG1sRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QudGFnTmFtZSA9PT0gXCJzdHJpbmdcIjtcbn1cbmZ1bmN0aW9uIGlzQnV0dG9uRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImJ1dHRvblwiO1xufVxuZnVuY3Rpb24gaXNGb3JtRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIGlzSHRtbEVsZW1lbnQob2JqZWN0KSAmJiBvYmplY3QudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImZvcm1cIjtcbn1cbmZ1bmN0aW9uIGlzSW5wdXRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gaXNIdG1sRWxlbWVudChvYmplY3QpICYmIG9iamVjdC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIjtcbn1cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59XG5mdW5jdGlvbiBzaG91bGRQcm9jZXNzTGlua0NsaWNrKGV2ZW50LCB0YXJnZXQpIHtcbiAgcmV0dXJuIGV2ZW50LmJ1dHRvbiA9PT0gMCAmJiAoXG4gIC8vIElnbm9yZSBldmVyeXRoaW5nIGJ1dCBsZWZ0IGNsaWNrc1xuICAhdGFyZ2V0IHx8IHRhcmdldCA9PT0gXCJfc2VsZlwiKSAmJlxuICAvLyBMZXQgYnJvd3NlciBoYW5kbGUgXCJ0YXJnZXQ9X2JsYW5rXCIgZXRjLlxuICAhaXNNb2RpZmllZEV2ZW50KGV2ZW50KSAvLyBJZ25vcmUgY2xpY2tzIHdpdGggbW9kaWZpZXIga2V5c1xuICA7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0IHVzaW5nIHRoZSBnaXZlbiBpbml0aWFsaXplci5cbiAqXG4gKiBUaGlzIGlzIGlkZW50aWNhbCB0byBgbmV3IFVSTFNlYXJjaFBhcmFtcyhpbml0KWAgZXhjZXB0IGl0IGFsc29cbiAqIHN1cHBvcnRzIGFycmF5cyBhcyB2YWx1ZXMgaW4gdGhlIG9iamVjdCBmb3JtIG9mIHRoZSBpbml0aWFsaXplclxuICogaW5zdGVhZCBvZiBqdXN0IHN0cmluZ3MuIFRoaXMgaXMgY29udmVuaWVudCB3aGVuIHlvdSBuZWVkIG11bHRpcGxlXG4gKiB2YWx1ZXMgZm9yIGEgZ2l2ZW4ga2V5LCBidXQgZG9uJ3Qgd2FudCB0byB1c2UgYW4gYXJyYXkgaW5pdGlhbGl6ZXIuXG4gKlxuICogRm9yIGV4YW1wbGUsIGluc3RlYWQgb2Y6XG4gKlxuICogICBsZXQgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhbXG4gKiAgICAgWydzb3J0JywgJ25hbWUnXSxcbiAqICAgICBbJ3NvcnQnLCAncHJpY2UnXVxuICogICBdKTtcbiAqXG4gKiB5b3UgY2FuIGRvOlxuICpcbiAqICAgbGV0IHNlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcyh7XG4gKiAgICAgc29ydDogWyduYW1lJywgJ3ByaWNlJ11cbiAqICAgfSk7XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVNlYXJjaFBhcmFtcyhpbml0KSB7XG4gIGlmIChpbml0ID09PSB2b2lkIDApIHtcbiAgICBpbml0ID0gXCJcIjtcbiAgfVxuICByZXR1cm4gbmV3IFVSTFNlYXJjaFBhcmFtcyh0eXBlb2YgaW5pdCA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KGluaXQpIHx8IGluaXQgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXMgPyBpbml0IDogT2JqZWN0LmtleXMoaW5pdCkucmVkdWNlKChtZW1vLCBrZXkpID0+IHtcbiAgICBsZXQgdmFsdWUgPSBpbml0W2tleV07XG4gICAgcmV0dXJuIG1lbW8uY29uY2F0KEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKHYgPT4gW2tleSwgdl0pIDogW1trZXksIHZhbHVlXV0pO1xuICB9LCBbXSkpO1xufVxuZnVuY3Rpb24gZ2V0U2VhcmNoUGFyYW1zRm9yTG9jYXRpb24obG9jYXRpb25TZWFyY2gsIGRlZmF1bHRTZWFyY2hQYXJhbXMpIHtcbiAgbGV0IHNlYXJjaFBhcmFtcyA9IGNyZWF0ZVNlYXJjaFBhcmFtcyhsb2NhdGlvblNlYXJjaCk7XG4gIGlmIChkZWZhdWx0U2VhcmNoUGFyYW1zKSB7XG4gICAgLy8gVXNlIGBkZWZhdWx0U2VhcmNoUGFyYW1zLmZvckVhY2goLi4uKWAgaGVyZSBpbnN0ZWFkIG9mIGl0ZXJhdGluZyBvZlxuICAgIC8vIGBkZWZhdWx0U2VhcmNoUGFyYW1zLmtleXMoKWAgdG8gd29yay1hcm91bmQgYSBidWcgaW4gRmlyZWZveCByZWxhdGVkIHRvXG4gICAgLy8gd2ViIGV4dGVuc2lvbnMuIFJlbGV2YW50IEJ1Z3ppbGxhIHRpY2tldHM6XG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQxNDYwMlxuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEwMjM5ODRcbiAgICBkZWZhdWx0U2VhcmNoUGFyYW1zLmZvckVhY2goKF8sIGtleSkgPT4ge1xuICAgICAgaWYgKCFzZWFyY2hQYXJhbXMuaGFzKGtleSkpIHtcbiAgICAgICAgZGVmYXVsdFNlYXJjaFBhcmFtcy5nZXRBbGwoa2V5KS5mb3JFYWNoKHZhbHVlID0+IHtcbiAgICAgICAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc2VhcmNoUGFyYW1zO1xufVxuLy8gT25lLXRpbWUgY2hlY2sgZm9yIHN1Ym1pdHRlciBzdXBwb3J0XG5sZXQgX2Zvcm1EYXRhU3VwcG9ydHNTdWJtaXR0ZXIgPSBudWxsO1xuZnVuY3Rpb24gaXNGb3JtRGF0YVN1Ym1pdHRlclN1cHBvcnRlZCgpIHtcbiAgaWYgKF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyID09PSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIG5ldyBGb3JtRGF0YShkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKSxcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgaWYgRm9ybURhdGEgc3VwcG9ydHMgdGhlIHN1Ym1pdHRlciBwYXJhbWV0ZXIsIHRoaXMgd2lsbCB0aHJvd1xuICAgICAgMCk7XG4gICAgICBfZm9ybURhdGFTdXBwb3J0c1N1Ym1pdHRlciA9IGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyO1xufVxuY29uc3Qgc3VwcG9ydGVkRm9ybUVuY1R5cGVzID0gbmV3IFNldChbXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiwgXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIsIFwidGV4dC9wbGFpblwiXSk7XG5mdW5jdGlvbiBnZXRGb3JtRW5jVHlwZShlbmNUeXBlKSB7XG4gIGlmIChlbmNUeXBlICE9IG51bGwgJiYgIXN1cHBvcnRlZEZvcm1FbmNUeXBlcy5oYXMoZW5jVHlwZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhmYWxzZSwgXCJcXFwiXCIgKyBlbmNUeXBlICsgXCJcXFwiIGlzIG5vdCBhIHZhbGlkIGBlbmNUeXBlYCBmb3IgYDxGb3JtPmAvYDxmZXRjaGVyLkZvcm0+YCBcIiArIChcImFuZCB3aWxsIGRlZmF1bHQgdG8gXFxcIlwiICsgZGVmYXVsdEVuY1R5cGUgKyBcIlxcXCJcIikpIDogdm9pZCAwO1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBlbmNUeXBlO1xufVxuZnVuY3Rpb24gZ2V0Rm9ybVN1Ym1pc3Npb25JbmZvKHRhcmdldCwgYmFzZW5hbWUpIHtcbiAgbGV0IG1ldGhvZDtcbiAgbGV0IGFjdGlvbjtcbiAgbGV0IGVuY1R5cGU7XG4gIGxldCBmb3JtRGF0YTtcbiAgbGV0IGJvZHk7XG4gIGlmIChpc0Zvcm1FbGVtZW50KHRhcmdldCkpIHtcbiAgICAvLyBXaGVuIGdyYWJiaW5nIHRoZSBhY3Rpb24gZnJvbSB0aGUgZWxlbWVudCwgaXQgd2lsbCBoYXZlIGhhZCB0aGUgYmFzZW5hbWVcbiAgICAvLyBwcmVmaXhlZCB0byBlbnN1cmUgbm9uLUpTIHNjZW5hcmlvcyB3b3JrLCBzbyBzdHJpcCBpdCBzaW5jZSB3ZSdsbFxuICAgIC8vIHJlLXByZWZpeCBpbiB0aGUgcm91dGVyXG4gICAgbGV0IGF0dHIgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiYWN0aW9uXCIpO1xuICAgIGFjdGlvbiA9IGF0dHIgPyBzdHJpcEJhc2VuYW1lKGF0dHIsIGJhc2VuYW1lKSA6IG51bGw7XG4gICAgbWV0aG9kID0gdGFyZ2V0LmdldEF0dHJpYnV0ZShcIm1ldGhvZFwiKSB8fCBkZWZhdWx0TWV0aG9kO1xuICAgIGVuY1R5cGUgPSBnZXRGb3JtRW5jVHlwZSh0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZW5jdHlwZVwiKSkgfHwgZGVmYXVsdEVuY1R5cGU7XG4gICAgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEodGFyZ2V0KTtcbiAgfSBlbHNlIGlmIChpc0J1dHRvbkVsZW1lbnQodGFyZ2V0KSB8fCBpc0lucHV0RWxlbWVudCh0YXJnZXQpICYmICh0YXJnZXQudHlwZSA9PT0gXCJzdWJtaXRcIiB8fCB0YXJnZXQudHlwZSA9PT0gXCJpbWFnZVwiKSkge1xuICAgIGxldCBmb3JtID0gdGFyZ2V0LmZvcm07XG4gICAgaWYgKGZvcm0gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHN1Ym1pdCBhIDxidXR0b24+IG9yIDxpbnB1dCB0eXBlPVxcXCJzdWJtaXRcXFwiPiB3aXRob3V0IGEgPGZvcm0+XCIpO1xuICAgIH1cbiAgICAvLyA8YnV0dG9uPi88aW5wdXQgdHlwZT1cInN1Ym1pdFwiPiBtYXkgb3ZlcnJpZGUgYXR0cmlidXRlcyBvZiA8Zm9ybT5cbiAgICAvLyBXaGVuIGdyYWJiaW5nIHRoZSBhY3Rpb24gZnJvbSB0aGUgZWxlbWVudCwgaXQgd2lsbCBoYXZlIGhhZCB0aGUgYmFzZW5hbWVcbiAgICAvLyBwcmVmaXhlZCB0byBlbnN1cmUgbm9uLUpTIHNjZW5hcmlvcyB3b3JrLCBzbyBzdHJpcCBpdCBzaW5jZSB3ZSdsbFxuICAgIC8vIHJlLXByZWZpeCBpbiB0aGUgcm91dGVyXG4gICAgbGV0IGF0dHIgPSB0YXJnZXQuZ2V0QXR0cmlidXRlKFwiZm9ybWFjdGlvblwiKSB8fCBmb3JtLmdldEF0dHJpYnV0ZShcImFjdGlvblwiKTtcbiAgICBhY3Rpb24gPSBhdHRyID8gc3RyaXBCYXNlbmFtZShhdHRyLCBiYXNlbmFtZSkgOiBudWxsO1xuICAgIG1ldGhvZCA9IHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtbWV0aG9kXCIpIHx8IGZvcm0uZ2V0QXR0cmlidXRlKFwibWV0aG9kXCIpIHx8IGRlZmF1bHRNZXRob2Q7XG4gICAgZW5jVHlwZSA9IGdldEZvcm1FbmNUeXBlKHRhcmdldC5nZXRBdHRyaWJ1dGUoXCJmb3JtZW5jdHlwZVwiKSkgfHwgZ2V0Rm9ybUVuY1R5cGUoZm9ybS5nZXRBdHRyaWJ1dGUoXCJlbmN0eXBlXCIpKSB8fCBkZWZhdWx0RW5jVHlwZTtcbiAgICAvLyBCdWlsZCBhIEZvcm1EYXRhIG9iamVjdCBwb3B1bGF0ZWQgZnJvbSBhIGZvcm0gYW5kIHN1Ym1pdHRlclxuICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKGZvcm0sIHRhcmdldCk7XG4gICAgLy8gSWYgdGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgYEZvcm1EYXRhKGVsLCBzdWJtaXR0ZXIpYCBmb3JtYXQsXG4gICAgLy8gdGhlbiB0YWNrIG9uIHRoZSBzdWJtaXR0ZXIgdmFsdWUgYXQgdGhlIGVuZC4gIFRoaXMgaXMgYSBsaWdodHdlaWdodFxuICAgIC8vIHNvbHV0aW9uIHRoYXQgaXMgbm90IDEwMCUgc3BlYyBjb21wbGlhbnQuICBGb3IgY29tcGxldGUgc3VwcG9ydCBpbiBvbGRlclxuICAgIC8vIGJyb3dzZXJzLCBjb25zaWRlciB1c2luZyB0aGUgYGZvcm1kYXRhLXN1Ym1pdHRlci1wb2x5ZmlsbGAgcGFja2FnZVxuICAgIGlmICghaXNGb3JtRGF0YVN1Ym1pdHRlclN1cHBvcnRlZCgpKSB7XG4gICAgICBsZXQge1xuICAgICAgICBuYW1lLFxuICAgICAgICB0eXBlLFxuICAgICAgICB2YWx1ZVxuICAgICAgfSA9IHRhcmdldDtcbiAgICAgIGlmICh0eXBlID09PSBcImltYWdlXCIpIHtcbiAgICAgICAgbGV0IHByZWZpeCA9IG5hbWUgPyBuYW1lICsgXCIuXCIgOiBcIlwiO1xuICAgICAgICBmb3JtRGF0YS5hcHBlbmQocHJlZml4ICsgXCJ4XCIsIFwiMFwiKTtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKHByZWZpeCArIFwieVwiLCBcIjBcIik7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUpIHtcbiAgICAgICAgZm9ybURhdGEuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNIdG1sRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHN1Ym1pdCBlbGVtZW50IHRoYXQgaXMgbm90IDxmb3JtPiwgPGJ1dHRvbj4sIG9yIFwiICsgXCI8aW5wdXQgdHlwZT1cXFwic3VibWl0fGltYWdlXFxcIj5cIik7XG4gIH0gZWxzZSB7XG4gICAgbWV0aG9kID0gZGVmYXVsdE1ldGhvZDtcbiAgICBhY3Rpb24gPSBudWxsO1xuICAgIGVuY1R5cGUgPSBkZWZhdWx0RW5jVHlwZTtcbiAgICBib2R5ID0gdGFyZ2V0O1xuICB9XG4gIC8vIFNlbmQgYm9keSBmb3IgPEZvcm0gZW5jVHlwZT1cInRleHQvcGxhaW5cIiBzbyB3ZSBlbmNvZGUgaXQgaW50byB0ZXh0XG4gIGlmIChmb3JtRGF0YSAmJiBlbmNUeXBlID09PSBcInRleHQvcGxhaW5cIikge1xuICAgIGJvZHkgPSBmb3JtRGF0YTtcbiAgICBmb3JtRGF0YSA9IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGFjdGlvbixcbiAgICBtZXRob2Q6IG1ldGhvZC50b0xvd2VyQ2FzZSgpLFxuICAgIGVuY1R5cGUsXG4gICAgZm9ybURhdGEsXG4gICAgYm9keVxuICB9O1xufVxuXG5jb25zdCBfZXhjbHVkZWQgPSBbXCJvbkNsaWNrXCIsIFwicmVsYXRpdmVcIiwgXCJyZWxvYWREb2N1bWVudFwiLCBcInJlcGxhY2VcIiwgXCJzdGF0ZVwiLCBcInRhcmdldFwiLCBcInRvXCIsIFwicHJldmVudFNjcm9sbFJlc2V0XCIsIFwidW5zdGFibGVfdmlld1RyYW5zaXRpb25cIl0sXG4gIF9leGNsdWRlZDIgPSBbXCJhcmlhLWN1cnJlbnRcIiwgXCJjYXNlU2Vuc2l0aXZlXCIsIFwiY2xhc3NOYW1lXCIsIFwiZW5kXCIsIFwic3R5bGVcIiwgXCJ0b1wiLCBcInVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXCIsIFwiY2hpbGRyZW5cIl0sXG4gIF9leGNsdWRlZDMgPSBbXCJmZXRjaGVyS2V5XCIsIFwibmF2aWdhdGVcIiwgXCJyZWxvYWREb2N1bWVudFwiLCBcInJlcGxhY2VcIiwgXCJzdGF0ZVwiLCBcIm1ldGhvZFwiLCBcImFjdGlvblwiLCBcIm9uU3VibWl0XCIsIFwicmVsYXRpdmVcIiwgXCJwcmV2ZW50U2Nyb2xsUmVzZXRcIiwgXCJ1bnN0YWJsZV92aWV3VHJhbnNpdGlvblwiXTtcbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJSb3V0ZXIocm91dGVzLCBvcHRzKSB7XG4gIHJldHVybiBjcmVhdGVSb3V0ZXIoe1xuICAgIGJhc2VuYW1lOiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmJhc2VuYW1lLFxuICAgIGZ1dHVyZTogX2V4dGVuZHMoe30sIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZnV0dXJlLCB7XG4gICAgICB2N19wcmVwZW5kQmFzZW5hbWU6IHRydWVcbiAgICB9KSxcbiAgICBoaXN0b3J5OiBjcmVhdGVCcm93c2VySGlzdG9yeSh7XG4gICAgICB3aW5kb3c6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMud2luZG93XG4gICAgfSksXG4gICAgaHlkcmF0aW9uRGF0YTogKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaHlkcmF0aW9uRGF0YSkgfHwgcGFyc2VIeWRyYXRpb25EYXRhKCksXG4gICAgcm91dGVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllczogVU5TQUZFX21hcFJvdXRlUHJvcGVydGllcyxcbiAgICB3aW5kb3c6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMud2luZG93XG4gIH0pLmluaXRpYWxpemUoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hSb3V0ZXIocm91dGVzLCBvcHRzKSB7XG4gIHJldHVybiBjcmVhdGVSb3V0ZXIoe1xuICAgIGJhc2VuYW1lOiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLmJhc2VuYW1lLFxuICAgIGZ1dHVyZTogX2V4dGVuZHMoe30sIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuZnV0dXJlLCB7XG4gICAgICB2N19wcmVwZW5kQmFzZW5hbWU6IHRydWVcbiAgICB9KSxcbiAgICBoaXN0b3J5OiBjcmVhdGVIYXNoSGlzdG9yeSh7XG4gICAgICB3aW5kb3c6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMud2luZG93XG4gICAgfSksXG4gICAgaHlkcmF0aW9uRGF0YTogKG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMuaHlkcmF0aW9uRGF0YSkgfHwgcGFyc2VIeWRyYXRpb25EYXRhKCksXG4gICAgcm91dGVzLFxuICAgIG1hcFJvdXRlUHJvcGVydGllczogVU5TQUZFX21hcFJvdXRlUHJvcGVydGllcyxcbiAgICB3aW5kb3c6IG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMud2luZG93XG4gIH0pLmluaXRpYWxpemUoKTtcbn1cbmZ1bmN0aW9uIHBhcnNlSHlkcmF0aW9uRGF0YSgpIHtcbiAgdmFyIF93aW5kb3c7XG4gIGxldCBzdGF0ZSA9IChfd2luZG93ID0gd2luZG93KSA9PSBudWxsID8gdm9pZCAwIDogX3dpbmRvdy5fX3N0YXRpY1JvdXRlckh5ZHJhdGlvbkRhdGE7XG4gIGlmIChzdGF0ZSAmJiBzdGF0ZS5lcnJvcnMpIHtcbiAgICBzdGF0ZSA9IF9leHRlbmRzKHt9LCBzdGF0ZSwge1xuICAgICAgZXJyb3JzOiBkZXNlcmlhbGl6ZUVycm9ycyhzdGF0ZS5lcnJvcnMpXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemVFcnJvcnMoZXJyb3JzKSB7XG4gIGlmICghZXJyb3JzKSByZXR1cm4gbnVsbDtcbiAgbGV0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhlcnJvcnMpO1xuICBsZXQgc2VyaWFsaXplZCA9IHt9O1xuICBmb3IgKGxldCBba2V5LCB2YWxdIG9mIGVudHJpZXMpIHtcbiAgICAvLyBIZXkgeW91ISAgSWYgeW91IGNoYW5nZSB0aGlzLCBwbGVhc2UgY2hhbmdlIHRoZSBjb3JyZXNwb25kaW5nIGxvZ2ljIGluXG4gICAgLy8gc2VyaWFsaXplRXJyb3JzIGluIHJlYWN0LXJvdXRlci1kb20vc2VydmVyLnRzeCA6KVxuICAgIGlmICh2YWwgJiYgdmFsLl9fdHlwZSA9PT0gXCJSb3V0ZUVycm9yUmVzcG9uc2VcIikge1xuICAgICAgc2VyaWFsaXplZFtrZXldID0gbmV3IFVOU0FGRV9FcnJvclJlc3BvbnNlSW1wbCh2YWwuc3RhdHVzLCB2YWwuc3RhdHVzVGV4dCwgdmFsLmRhdGEsIHZhbC5pbnRlcm5hbCA9PT0gdHJ1ZSk7XG4gICAgfSBlbHNlIGlmICh2YWwgJiYgdmFsLl9fdHlwZSA9PT0gXCJFcnJvclwiKSB7XG4gICAgICAvLyBBdHRlbXB0IHRvIHJlY29uc3RydWN0IHRoZSByaWdodCB0eXBlIG9mIEVycm9yIChpLmUuLCBSZWZlcmVuY2VFcnJvcilcbiAgICAgIGlmICh2YWwuX19zdWJUeXBlKSB7XG4gICAgICAgIGxldCBFcnJvckNvbnN0cnVjdG9yID0gd2luZG93W3ZhbC5fX3N1YlR5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIEVycm9yQ29uc3RydWN0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3JDb25zdHJ1Y3Rvcih2YWwubWVzc2FnZSk7XG4gICAgICAgICAgICAvLyBXaXBlIGF3YXkgdGhlIGNsaWVudC1zaWRlIHN0YWNrIHRyYWNlLiAgTm90aGluZyB0byBmaWxsIGl0IGluIHdpdGhcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgZG9uJ3Qgc2VyaWFsaXplIFNTUiBzdGFjayB0cmFjZXMgZm9yIHNlY3VyaXR5IHJlYXNvbnNcbiAgICAgICAgICAgIGVycm9yLnN0YWNrID0gXCJcIjtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IGVycm9yO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIG5vLW9wIC0gZmFsbCB0aHJvdWdoIGFuZCBjcmVhdGUgYSBub3JtYWwgRXJyb3JcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZXJpYWxpemVkW2tleV0gPT0gbnVsbCkge1xuICAgICAgICBsZXQgZXJyb3IgPSBuZXcgRXJyb3IodmFsLm1lc3NhZ2UpO1xuICAgICAgICAvLyBXaXBlIGF3YXkgdGhlIGNsaWVudC1zaWRlIHN0YWNrIHRyYWNlLiAgTm90aGluZyB0byBmaWxsIGl0IGluIHdpdGhcbiAgICAgICAgLy8gYmVjYXVzZSB3ZSBkb24ndCBzZXJpYWxpemUgU1NSIHN0YWNrIHRyYWNlcyBmb3Igc2VjdXJpdHkgcmVhc29uc1xuICAgICAgICBlcnJvci5zdGFjayA9IFwiXCI7XG4gICAgICAgIHNlcmlhbGl6ZWRba2V5XSA9IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXJpYWxpemVkW2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuY29uc3QgVmlld1RyYW5zaXRpb25Db250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQoe1xuICBpc1RyYW5zaXRpb25pbmc6IGZhbHNlXG59KTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgVmlld1RyYW5zaXRpb25Db250ZXh0LmRpc3BsYXlOYW1lID0gXCJWaWV3VHJhbnNpdGlvblwiO1xufVxuY29uc3QgRmV0Y2hlcnNDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobmV3IE1hcCgpKTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgRmV0Y2hlcnNDb250ZXh0LmRpc3BsYXlOYW1lID0gXCJGZXRjaGVyc1wiO1xufVxuLy8jZW5kcmVnaW9uXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8jcmVnaW9uIENvbXBvbmVudHNcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vKipcbiAgV2VicGFjayArIFJlYWN0IDE3IGZhaWxzIHRvIGNvbXBpbGUgb24gYW55IG9mIHRoZSBmb2xsb3dpbmcgYmVjYXVzZSB3ZWJwYWNrXG4gIGNvbXBsYWlucyB0aGF0IGBzdGFydFRyYW5zaXRpb25gIGRvZXNuJ3QgZXhpc3QgaW4gYFJlYWN0YDpcbiAgKiBpbXBvcnQgeyBzdGFydFRyYW5zaXRpb24gfSBmcm9tIFwicmVhY3RcIlxuICAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gZnJvbSBcInJlYWN0XCI7XG4gICAgXCJzdGFydFRyYW5zaXRpb25cIiBpbiBSZWFjdCA/IFJlYWN0LnN0YXJ0VHJhbnNpdGlvbigoKSA9PiBzZXRTdGF0ZSgpKSA6IHNldFN0YXRlKClcbiAgKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tIGZyb20gXCJyZWFjdFwiO1xuICAgIFwic3RhcnRUcmFuc2l0aW9uXCIgaW4gUmVhY3QgPyBSZWFjdFtcInN0YXJ0VHJhbnNpdGlvblwiXSgoKSA9PiBzZXRTdGF0ZSgpKSA6IHNldFN0YXRlKClcblxuICBNb3ZpbmcgaXQgdG8gYSBjb25zdGFudCBzdWNoIGFzIHRoZSBmb2xsb3dpbmcgc29sdmVzIHRoZSBXZWJwYWNrL1JlYWN0IDE3IGlzc3VlOlxuICAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gZnJvbSBcInJlYWN0XCI7XG4gICAgY29uc3QgU1RBUlRfVFJBTlNJVElPTiA9IFwic3RhcnRUcmFuc2l0aW9uXCI7XG4gICAgU1RBUlRfVFJBTlNJVElPTiBpbiBSZWFjdCA/IFJlYWN0W1NUQVJUX1RSQU5TSVRJT05dKCgpID0+IHNldFN0YXRlKCkpIDogc2V0U3RhdGUoKVxuXG4gIEhvd2V2ZXIsIHRoYXQgaW50cm9kdWNlcyB3ZWJwYWNrL3RlcnNlciBtaW5pZmljYXRpb24gaXNzdWVzIGluIHByb2R1Y3Rpb24gYnVpbGRzXG4gIGluIFJlYWN0IDE4IHdoZXJlIG1pbmlmaWNhdGlvbi9vYmZ1c2NhdGlvbiBlbmRzIHVwIHJlbW92aW5nIHRoZSBjYWxsIG9mXG4gIFJlYWN0LnN0YXJ0VHJhbnNpdGlvbiBlbnRpcmVseSBmcm9tIHRoZSBmaXJzdCBoYWxmIG9mIHRoZSB0ZXJuYXJ5LiAgR3JhYmJpbmdcbiAgdGhpcyBleHBvcnRlZCByZWZlcmVuY2Ugb25jZSB1cCBmcm9udCByZXNvbHZlcyB0aGF0IGlzc3VlLlxuXG4gIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcmVtaXgtcnVuL3JlYWN0LXJvdXRlci9pc3N1ZXMvMTA1NzlcbiovXG5jb25zdCBTVEFSVF9UUkFOU0lUSU9OID0gXCJzdGFydFRyYW5zaXRpb25cIjtcbmNvbnN0IHN0YXJ0VHJhbnNpdGlvbkltcGwgPSBSZWFjdFtTVEFSVF9UUkFOU0lUSU9OXTtcbmNvbnN0IEZMVVNIX1NZTkMgPSBcImZsdXNoU3luY1wiO1xuY29uc3QgZmx1c2hTeW5jSW1wbCA9IFJlYWN0RE9NW0ZMVVNIX1NZTkNdO1xuZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uU2FmZShjYikge1xuICBpZiAoc3RhcnRUcmFuc2l0aW9uSW1wbCkge1xuICAgIHN0YXJ0VHJhbnNpdGlvbkltcGwoY2IpO1xuICB9IGVsc2Uge1xuICAgIGNiKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoU3luY1NhZmUoY2IpIHtcbiAgaWYgKGZsdXNoU3luY0ltcGwpIHtcbiAgICBmbHVzaFN5bmNJbXBsKGNiKTtcbiAgfSBlbHNlIHtcbiAgICBjYigpO1xuICB9XG59XG5jbGFzcyBEZWZlcnJlZCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhdHVzID0gXCJwZW5kaW5nXCI7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5yZXNvbHZlID0gdmFsdWUgPT4ge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5zdGF0dXMgPSBcInJlc29sdmVkXCI7XG4gICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLnJlamVjdCA9IHJlYXNvbiA9PiB7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgICB0aGlzLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgICAgICByZWplY3QocmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIFJlbWl4IFJvdXRlciBpbnN0YW5jZSwgcmVuZGVyIHRoZSBhcHByb3ByaWF0ZSBVSVxuICovXG5mdW5jdGlvbiBSb3V0ZXJQcm92aWRlcihfcmVmKSB7XG4gIGxldCB7XG4gICAgZmFsbGJhY2tFbGVtZW50LFxuICAgIHJvdXRlcixcbiAgICBmdXR1cmVcbiAgfSA9IF9yZWY7XG4gIGxldCBbc3RhdGUsIHNldFN0YXRlSW1wbF0gPSBSZWFjdC51c2VTdGF0ZShyb3V0ZXIuc3RhdGUpO1xuICBsZXQgW3BlbmRpbmdTdGF0ZSwgc2V0UGVuZGluZ1N0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gIGxldCBbdnRDb250ZXh0LCBzZXRWdENvbnRleHRdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGlzVHJhbnNpdGlvbmluZzogZmFsc2VcbiAgfSk7XG4gIGxldCBbcmVuZGVyRGZkLCBzZXRSZW5kZXJEZmRdID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgbGV0IFt0cmFuc2l0aW9uLCBzZXRUcmFuc2l0aW9uXSA9IFJlYWN0LnVzZVN0YXRlKCk7XG4gIGxldCBbaW50ZXJydXB0aW9uLCBzZXRJbnRlcnJ1cHRpb25dID0gUmVhY3QudXNlU3RhdGUoKTtcbiAgbGV0IGZldGNoZXJEYXRhID0gUmVhY3QudXNlUmVmKG5ldyBNYXAoKSk7XG4gIGxldCB7XG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uXG4gIH0gPSBmdXR1cmUgfHwge307XG4gIGxldCBvcHRJblN0YXJ0VHJhbnNpdGlvbiA9IFJlYWN0LnVzZUNhbGxiYWNrKGNiID0+IHtcbiAgICBpZiAodjdfc3RhcnRUcmFuc2l0aW9uKSB7XG4gICAgICBzdGFydFRyYW5zaXRpb25TYWZlKGNiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2IoKTtcbiAgICB9XG4gIH0sIFt2N19zdGFydFRyYW5zaXRpb25dKTtcbiAgbGV0IHNldFN0YXRlID0gUmVhY3QudXNlQ2FsbGJhY2soKG5ld1N0YXRlLCBfcmVmMikgPT4ge1xuICAgIGxldCB7XG4gICAgICBkZWxldGVkRmV0Y2hlcnMsXG4gICAgICB1bnN0YWJsZV9mbHVzaFN5bmM6IGZsdXNoU3luYyxcbiAgICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uT3B0czogdmlld1RyYW5zaXRpb25PcHRzXG4gICAgfSA9IF9yZWYyO1xuICAgIGRlbGV0ZWRGZXRjaGVycy5mb3JFYWNoKGtleSA9PiBmZXRjaGVyRGF0YS5jdXJyZW50LmRlbGV0ZShrZXkpKTtcbiAgICBuZXdTdGF0ZS5mZXRjaGVycy5mb3JFYWNoKChmZXRjaGVyLCBrZXkpID0+IHtcbiAgICAgIGlmIChmZXRjaGVyLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmZXRjaGVyRGF0YS5jdXJyZW50LnNldChrZXksIGZldGNoZXIuZGF0YSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IGlzVmlld1RyYW5zaXRpb25VbmF2YWlsYWJsZSA9IHJvdXRlci53aW5kb3cgPT0gbnVsbCB8fCB0eXBlb2Ygcm91dGVyLndpbmRvdy5kb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uICE9PSBcImZ1bmN0aW9uXCI7XG4gICAgLy8gSWYgdGhpcyBpc24ndCBhIHZpZXcgdHJhbnNpdGlvbiBvciBpdCdzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBicm93c2VyLFxuICAgIC8vIGp1c3QgdXBkYXRlIGFuZCBiZSBkb25lIHdpdGggaXRcbiAgICBpZiAoIXZpZXdUcmFuc2l0aW9uT3B0cyB8fCBpc1ZpZXdUcmFuc2l0aW9uVW5hdmFpbGFibGUpIHtcbiAgICAgIGlmIChmbHVzaFN5bmMpIHtcbiAgICAgICAgZmx1c2hTeW5jU2FmZSgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdEluU3RhcnRUcmFuc2l0aW9uKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBmbHVzaFN5bmMgKyBzdGFydFZpZXdUcmFuc2l0aW9uXG4gICAgaWYgKGZsdXNoU3luYykge1xuICAgICAgLy8gRmx1c2ggdGhyb3VnaCB0aGUgY29udGV4dCB0byBtYXJrIERPTSBlbGVtZW50cyBhcyB0cmFuc2l0aW9uPWluZ1xuICAgICAgZmx1c2hTeW5jU2FmZSgoKSA9PiB7XG4gICAgICAgIC8vIENhbmNlbCBhbnkgcGVuZGluZyB0cmFuc2l0aW9uc1xuICAgICAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgICAgIHJlbmRlckRmZCAmJiByZW5kZXJEZmQucmVzb2x2ZSgpO1xuICAgICAgICAgIHRyYW5zaXRpb24uc2tpcFRyYW5zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRWdENvbnRleHQoe1xuICAgICAgICAgIGlzVHJhbnNpdGlvbmluZzogdHJ1ZSxcbiAgICAgICAgICBmbHVzaFN5bmM6IHRydWUsXG4gICAgICAgICAgY3VycmVudExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMuY3VycmVudExvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLm5leHRMb2NhdGlvblxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgLy8gVXBkYXRlIHRoZSBET01cbiAgICAgIGxldCB0ID0gcm91dGVyLndpbmRvdy5kb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgZmx1c2hTeW5jU2FmZSgoKSA9PiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpKTtcbiAgICAgIH0pO1xuICAgICAgLy8gQ2xlYW4gdXAgYWZ0ZXIgdGhlIGFuaW1hdGlvbiBjb21wbGV0ZXNcbiAgICAgIHQuZmluaXNoZWQuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIGZsdXNoU3luY1NhZmUoKCkgPT4ge1xuICAgICAgICAgIHNldFJlbmRlckRmZCh1bmRlZmluZWQpO1xuICAgICAgICAgIHNldFRyYW5zaXRpb24odW5kZWZpbmVkKTtcbiAgICAgICAgICBzZXRQZW5kaW5nU3RhdGUodW5kZWZpbmVkKTtcbiAgICAgICAgICBzZXRWdENvbnRleHQoe1xuICAgICAgICAgICAgaXNUcmFuc2l0aW9uaW5nOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgZmx1c2hTeW5jU2FmZSgoKSA9PiBzZXRUcmFuc2l0aW9uKHQpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gc3RhcnRUcmFuc2l0aW9uICsgc3RhcnRWaWV3VHJhbnNpdGlvblxuICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICAvLyBJbnRlcnJ1cHRpbmcgYW4gaW4tcHJvZ3Jlc3MgdHJhbnNpdGlvbiwgY2FuY2VsIGFuZCBsZXQgZXZlcnl0aGluZyBmbHVzaFxuICAgICAgLy8gb3V0LCBhbmQgdGhlbiBraWNrIG9mZiBhIG5ldyB0cmFuc2l0aW9uIGZyb20gdGhlIGludGVycnVwdGlvbiBzdGF0ZVxuICAgICAgcmVuZGVyRGZkICYmIHJlbmRlckRmZC5yZXNvbHZlKCk7XG4gICAgICB0cmFuc2l0aW9uLnNraXBUcmFuc2l0aW9uKCk7XG4gICAgICBzZXRJbnRlcnJ1cHRpb24oe1xuICAgICAgICBzdGF0ZTogbmV3U3RhdGUsXG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgbmV4dExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMubmV4dExvY2F0aW9uXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29tcGxldGVkIG5hdmlnYXRpb24gdXBkYXRlIHdpdGggb3B0ZWQtaW4gdmlldyB0cmFuc2l0aW9ucywgbGV0ICdlciByaXBcbiAgICAgIHNldFBlbmRpbmdTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICBzZXRWdENvbnRleHQoe1xuICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXG4gICAgICAgIGZsdXNoU3luYzogZmFsc2UsXG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogdmlld1RyYW5zaXRpb25PcHRzLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgbmV4dExvY2F0aW9uOiB2aWV3VHJhbnNpdGlvbk9wdHMubmV4dExvY2F0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtyb3V0ZXIud2luZG93LCB0cmFuc2l0aW9uLCByZW5kZXJEZmQsIGZldGNoZXJEYXRhLCBvcHRJblN0YXJ0VHJhbnNpdGlvbl0pO1xuICAvLyBOZWVkIHRvIHVzZSBhIGxheW91dCBlZmZlY3QgaGVyZSBzbyB3ZSBhcmUgc3Vic2NyaWJlZCBlYXJseSBlbm91Z2ggdG9cbiAgLy8gcGljayB1cCBvbiBhbnkgcmVuZGVyLWRyaXZlbiByZWRpcmVjdHMvbmF2aWdhdGlvbnMgKHVzZUVmZmVjdC88TmF2aWdhdGU+KVxuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gcm91dGVyLnN1YnNjcmliZShzZXRTdGF0ZSksIFtyb3V0ZXIsIHNldFN0YXRlXSk7XG4gIC8vIFdoZW4gd2Ugc3RhcnQgYSB2aWV3IHRyYW5zaXRpb24sIGNyZWF0ZSBhIERlZmVycmVkIHdlIGNhbiB1c2UgZm9yIHRoZVxuICAvLyBldmVudHVhbCBcImNvbXBsZXRlZFwiIHJlbmRlclxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nICYmICF2dENvbnRleHQuZmx1c2hTeW5jKSB7XG4gICAgICBzZXRSZW5kZXJEZmQobmV3IERlZmVycmVkKCkpO1xuICAgIH1cbiAgfSwgW3Z0Q29udGV4dF0pO1xuICAvLyBPbmNlIHRoZSBkZWZlcnJlZCBpcyBjcmVhdGVkLCBraWNrIG9mZiBzdGFydFZpZXdUcmFuc2l0aW9uKCkgdG8gdXBkYXRlIHRoZVxuICAvLyBET00gYW5kIHRoZW4gd2FpdCBvbiB0aGUgRGVmZXJyZWQgdG8gcmVzb2x2ZSAoaW5kaWNhdGluZyB0aGUgRE9NIHVwZGF0ZSBoYXNcbiAgLy8gaGFwcGVuZWQpXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHJlbmRlckRmZCAmJiBwZW5kaW5nU3RhdGUgJiYgcm91dGVyLndpbmRvdykge1xuICAgICAgbGV0IG5ld1N0YXRlID0gcGVuZGluZ1N0YXRlO1xuICAgICAgbGV0IHJlbmRlclByb21pc2UgPSByZW5kZXJEZmQucHJvbWlzZTtcbiAgICAgIGxldCB0cmFuc2l0aW9uID0gcm91dGVyLndpbmRvdy5kb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uKGFzeW5jICgpID0+IHtcbiAgICAgICAgb3B0SW5TdGFydFRyYW5zaXRpb24oKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSk7XG4gICAgICAgIGF3YWl0IHJlbmRlclByb21pc2U7XG4gICAgICB9KTtcbiAgICAgIHRyYW5zaXRpb24uZmluaXNoZWQuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHNldFJlbmRlckRmZCh1bmRlZmluZWQpO1xuICAgICAgICBzZXRUcmFuc2l0aW9uKHVuZGVmaW5lZCk7XG4gICAgICAgIHNldFBlbmRpbmdTdGF0ZSh1bmRlZmluZWQpO1xuICAgICAgICBzZXRWdENvbnRleHQoe1xuICAgICAgICAgIGlzVHJhbnNpdGlvbmluZzogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHNldFRyYW5zaXRpb24odHJhbnNpdGlvbik7XG4gICAgfVxuICB9LCBbb3B0SW5TdGFydFRyYW5zaXRpb24sIHBlbmRpbmdTdGF0ZSwgcmVuZGVyRGZkLCByb3V0ZXIud2luZG93XSk7XG4gIC8vIFdoZW4gdGhlIG5ldyBsb2NhdGlvbiBmaW5hbGx5IHJlbmRlcnMgYW5kIGlzIGNvbW1pdHRlZCB0byB0aGUgRE9NLCB0aGlzXG4gIC8vIGVmZmVjdCB3aWxsIHJ1biB0byByZXNvbHZlIHRoZSB0cmFuc2l0aW9uXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHJlbmRlckRmZCAmJiBwZW5kaW5nU3RhdGUgJiYgc3RhdGUubG9jYXRpb24ua2V5ID09PSBwZW5kaW5nU3RhdGUubG9jYXRpb24ua2V5KSB7XG4gICAgICByZW5kZXJEZmQucmVzb2x2ZSgpO1xuICAgIH1cbiAgfSwgW3JlbmRlckRmZCwgdHJhbnNpdGlvbiwgc3RhdGUubG9jYXRpb24sIHBlbmRpbmdTdGF0ZV0pO1xuICAvLyBJZiB3ZSBnZXQgaW50ZXJydXB0ZWQgd2l0aCBhIG5ldyBuYXZpZ2F0aW9uIGR1cmluZyBhIHRyYW5zaXRpb24sIHdlIHNraXBcbiAgLy8gdGhlIGFjdGl2ZSB0cmFuc2l0aW9uLCBsZXQgaXQgY2xlYW51cCwgdGhlbiBraWNrIGl0IG9mZiBhZ2FpbiBoZXJlXG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF2dENvbnRleHQuaXNUcmFuc2l0aW9uaW5nICYmIGludGVycnVwdGlvbikge1xuICAgICAgc2V0UGVuZGluZ1N0YXRlKGludGVycnVwdGlvbi5zdGF0ZSk7XG4gICAgICBzZXRWdENvbnRleHQoe1xuICAgICAgICBpc1RyYW5zaXRpb25pbmc6IHRydWUsXG4gICAgICAgIGZsdXNoU3luYzogZmFsc2UsXG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogaW50ZXJydXB0aW9uLmN1cnJlbnRMb2NhdGlvbixcbiAgICAgICAgbmV4dExvY2F0aW9uOiBpbnRlcnJ1cHRpb24ubmV4dExvY2F0aW9uXG4gICAgICB9KTtcbiAgICAgIHNldEludGVycnVwdGlvbih1bmRlZmluZWQpO1xuICAgIH1cbiAgfSwgW3Z0Q29udGV4dC5pc1RyYW5zaXRpb25pbmcsIGludGVycnVwdGlvbl0pO1xuICBsZXQgbmF2aWdhdG9yID0gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNyZWF0ZUhyZWY6IHJvdXRlci5jcmVhdGVIcmVmLFxuICAgICAgZW5jb2RlTG9jYXRpb246IHJvdXRlci5lbmNvZGVMb2NhdGlvbixcbiAgICAgIGdvOiBuID0+IHJvdXRlci5uYXZpZ2F0ZShuKSxcbiAgICAgIHB1c2g6ICh0bywgc3RhdGUsIG9wdHMpID0+IHJvdXRlci5uYXZpZ2F0ZSh0bywge1xuICAgICAgICBzdGF0ZSxcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRzID09IG51bGwgPyB2b2lkIDAgOiBvcHRzLnByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgfSksXG4gICAgICByZXBsYWNlOiAodG8sIHN0YXRlLCBvcHRzKSA9PiByb3V0ZXIubmF2aWdhdGUodG8sIHtcbiAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXRcbiAgICAgIH0pXG4gICAgfTtcbiAgfSwgW3JvdXRlcl0pO1xuICBsZXQgYmFzZW5hbWUgPSByb3V0ZXIuYmFzZW5hbWUgfHwgXCIvXCI7XG4gIGxldCBkYXRhUm91dGVyQ29udGV4dCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICByb3V0ZXIsXG4gICAgbmF2aWdhdG9yLFxuICAgIHN0YXRpYzogZmFsc2UsXG4gICAgYmFzZW5hbWVcbiAgfSksIFtyb3V0ZXIsIG5hdmlnYXRvciwgYmFzZW5hbWVdKTtcbiAgLy8gVGhlIGZyYWdtZW50IGFuZCB7bnVsbH0gaGVyZSBhcmUgaW1wb3J0YW50ISAgV2UgbmVlZCB0aGVtIHRvIGtlZXAgUmVhY3QgMTgnc1xuICAvLyB1c2VJZCBoYXBweSB3aGVuIHdlIGFyZSBzZXJ2ZXItcmVuZGVyaW5nIHNpbmNlIHdlIG1heSBoYXZlIGEgPHNjcmlwdD4gaGVyZVxuICAvLyBjb250YWluaW5nIHRoZSBoeWRyYXRlZCBzZXJ2ZXItc2lkZSBzdGF0aWNDb250ZXh0IChmcm9tIFN0YXRpY1JvdXRlclByb3ZpZGVyKS5cbiAgLy8gdXNlSWQgcmVsaWVzIG9uIHRoZSBjb21wb25lbnQgdHJlZSBzdHJ1Y3R1cmUgdG8gZ2VuZXJhdGUgZGV0ZXJtaW5pc3RpYyBpZCdzXG4gIC8vIHNvIHdlIG5lZWQgdG8gZW5zdXJlIGl0IHJlbWFpbnMgdGhlIHNhbWUgb24gdGhlIGNsaWVudCBldmVuIHRob3VnaFxuICAvLyB3ZSBkb24ndCBuZWVkIHRoZSA8c2NyaXB0PiB0YWdcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChVTlNBRkVfRGF0YVJvdXRlckNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZGF0YVJvdXRlckNvbnRleHRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc3RhdGVcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRmV0Y2hlcnNDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGZldGNoZXJEYXRhLmN1cnJlbnRcbiAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoVmlld1RyYW5zaXRpb25Db250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IHZ0Q29udGV4dFxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICBiYXNlbmFtZTogYmFzZW5hbWUsXG4gICAgbG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgIG5hdmlnYXRpb25UeXBlOiBzdGF0ZS5oaXN0b3J5QWN0aW9uLFxuICAgIG5hdmlnYXRvcjogbmF2aWdhdG9yXG4gIH0sIHN0YXRlLmluaXRpYWxpemVkID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoRGF0YVJvdXRlcywge1xuICAgIHJvdXRlczogcm91dGVyLnJvdXRlcyxcbiAgICBzdGF0ZTogc3RhdGVcbiAgfSkgOiBmYWxsYmFja0VsZW1lbnQpKSkpKSwgbnVsbCk7XG59XG5mdW5jdGlvbiBEYXRhUm91dGVzKF9yZWYzKSB7XG4gIGxldCB7XG4gICAgcm91dGVzLFxuICAgIHN0YXRlXG4gIH0gPSBfcmVmMztcbiAgcmV0dXJuIFVOU0FGRV91c2VSb3V0ZXNJbXBsKHJvdXRlcywgdW5kZWZpbmVkLCBzdGF0ZSk7XG59XG4vKipcbiAqIEEgYDxSb3V0ZXI+YCBmb3IgdXNlIGluIHdlYiBicm93c2Vycy4gUHJvdmlkZXMgdGhlIGNsZWFuZXN0IFVSTHMuXG4gKi9cbmZ1bmN0aW9uIEJyb3dzZXJSb3V0ZXIoX3JlZjQpIHtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbixcbiAgICBmdXR1cmUsXG4gICAgd2luZG93XG4gIH0gPSBfcmVmNDtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlQnJvd3Nlckhpc3Rvcnkoe1xuICAgICAgd2luZG93LFxuICAgICAgdjVDb21wYXQ6IHRydWVcbiAgICB9KTtcbiAgfVxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuICBsZXQge1xuICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxuICB9ID0gZnV0dXJlIHx8IHt9O1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhuZXdTdGF0ZSA9PiB7XG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uICYmIHN0YXJ0VHJhbnNpdGlvbkltcGwgPyBzdGFydFRyYW5zaXRpb25JbXBsKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpIDogc2V0U3RhdGVJbXBsKG5ld1N0YXRlKTtcbiAgfSwgW3NldFN0YXRlSW1wbCwgdjdfc3RhcnRUcmFuc2l0aW9uXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5LCBzZXRTdGF0ZV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XG4gICAgYmFzZW5hbWU6IGJhc2VuYW1lLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmFjdGlvbixcbiAgICBuYXZpZ2F0b3I6IGhpc3RvcnlcbiAgfSk7XG59XG4vKipcbiAqIEEgYDxSb3V0ZXI+YCBmb3IgdXNlIGluIHdlYiBicm93c2Vycy4gU3RvcmVzIHRoZSBsb2NhdGlvbiBpbiB0aGUgaGFzaFxuICogcG9ydGlvbiBvZiB0aGUgVVJMIHNvIGl0IGlzIG5vdCBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gKi9cbmZ1bmN0aW9uIEhhc2hSb3V0ZXIoX3JlZjUpIHtcbiAgbGV0IHtcbiAgICBiYXNlbmFtZSxcbiAgICBjaGlsZHJlbixcbiAgICBmdXR1cmUsXG4gICAgd2luZG93XG4gIH0gPSBfcmVmNTtcbiAgbGV0IGhpc3RvcnlSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgaWYgKGhpc3RvcnlSZWYuY3VycmVudCA9PSBudWxsKSB7XG4gICAgaGlzdG9yeVJlZi5jdXJyZW50ID0gY3JlYXRlSGFzaEhpc3Rvcnkoe1xuICAgICAgd2luZG93LFxuICAgICAgdjVDb21wYXQ6IHRydWVcbiAgICB9KTtcbiAgfVxuICBsZXQgaGlzdG9yeSA9IGhpc3RvcnlSZWYuY3VycmVudDtcbiAgbGV0IFtzdGF0ZSwgc2V0U3RhdGVJbXBsXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICBhY3Rpb246IGhpc3RvcnkuYWN0aW9uLFxuICAgIGxvY2F0aW9uOiBoaXN0b3J5LmxvY2F0aW9uXG4gIH0pO1xuICBsZXQge1xuICAgIHY3X3N0YXJ0VHJhbnNpdGlvblxuICB9ID0gZnV0dXJlIHx8IHt9O1xuICBsZXQgc2V0U3RhdGUgPSBSZWFjdC51c2VDYWxsYmFjayhuZXdTdGF0ZSA9PiB7XG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uICYmIHN0YXJ0VHJhbnNpdGlvbkltcGwgPyBzdGFydFRyYW5zaXRpb25JbXBsKCgpID0+IHNldFN0YXRlSW1wbChuZXdTdGF0ZSkpIDogc2V0U3RhdGVJbXBsKG5ld1N0YXRlKTtcbiAgfSwgW3NldFN0YXRlSW1wbCwgdjdfc3RhcnRUcmFuc2l0aW9uXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiBoaXN0b3J5Lmxpc3RlbihzZXRTdGF0ZSksIFtoaXN0b3J5LCBzZXRTdGF0ZV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUm91dGVyLCB7XG4gICAgYmFzZW5hbWU6IGJhc2VuYW1lLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBsb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgbmF2aWdhdGlvblR5cGU6IHN0YXRlLmFjdGlvbixcbiAgICBuYXZpZ2F0b3I6IGhpc3RvcnlcbiAgfSk7XG59XG4vKipcbiAqIEEgYDxSb3V0ZXI+YCB0aGF0IGFjY2VwdHMgYSBwcmUtaW5zdGFudGlhdGVkIGhpc3Rvcnkgb2JqZWN0LiBJdCdzIGltcG9ydGFudFxuICogdG8gbm90ZSB0aGF0IHVzaW5nIHlvdXIgb3duIGhpc3Rvcnkgb2JqZWN0IGlzIGhpZ2hseSBkaXNjb3VyYWdlZCBhbmQgbWF5IGFkZFxuICogdHdvIHZlcnNpb25zIG9mIHRoZSBoaXN0b3J5IGxpYnJhcnkgdG8geW91ciBidW5kbGVzIHVubGVzcyB5b3UgdXNlIHRoZSBzYW1lXG4gKiB2ZXJzaW9uIG9mIHRoZSBoaXN0b3J5IGxpYnJhcnkgdGhhdCBSZWFjdCBSb3V0ZXIgdXNlcyBpbnRlcm5hbGx5LlxuICovXG5mdW5jdGlvbiBIaXN0b3J5Um91dGVyKF9yZWY2KSB7XG4gIGxldCB7XG4gICAgYmFzZW5hbWUsXG4gICAgY2hpbGRyZW4sXG4gICAgZnV0dXJlLFxuICAgIGhpc3RvcnlcbiAgfSA9IF9yZWY2O1xuICBsZXQgW3N0YXRlLCBzZXRTdGF0ZUltcGxdID0gUmVhY3QudXNlU3RhdGUoe1xuICAgIGFjdGlvbjogaGlzdG9yeS5hY3Rpb24sXG4gICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb25cbiAgfSk7XG4gIGxldCB7XG4gICAgdjdfc3RhcnRUcmFuc2l0aW9uXG4gIH0gPSBmdXR1cmUgfHwge307XG4gIGxldCBzZXRTdGF0ZSA9IFJlYWN0LnVzZUNhbGxiYWNrKG5ld1N0YXRlID0+IHtcbiAgICB2N19zdGFydFRyYW5zaXRpb24gJiYgc3RhcnRUcmFuc2l0aW9uSW1wbCA/IHN0YXJ0VHJhbnNpdGlvbkltcGwoKCkgPT4gc2V0U3RhdGVJbXBsKG5ld1N0YXRlKSkgOiBzZXRTdGF0ZUltcGwobmV3U3RhdGUpO1xuICB9LCBbc2V0U3RhdGVJbXBsLCB2N19zdGFydFRyYW5zaXRpb25dKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IGhpc3RvcnkubGlzdGVuKHNldFN0YXRlKSwgW2hpc3RvcnksIHNldFN0YXRlXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSb3V0ZXIsIHtcbiAgICBiYXNlbmFtZTogYmFzZW5hbWUsXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGxvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICBuYXZpZ2F0aW9uVHlwZTogc3RhdGUuYWN0aW9uLFxuICAgIG5hdmlnYXRvcjogaGlzdG9yeVxuICB9KTtcbn1cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgSGlzdG9yeVJvdXRlci5kaXNwbGF5TmFtZSA9IFwidW5zdGFibGVfSGlzdG9yeVJvdXRlclwiO1xufVxuY29uc3QgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcbmNvbnN0IEFCU09MVVRFX1VSTF9SRUdFWCA9IC9eKD86W2Etel1bYS16MC05Ky4tXSo6fFxcL1xcLykvaTtcbi8qKlxuICogVGhlIHB1YmxpYyBBUEkgZm9yIHJlbmRlcmluZyBhIGhpc3RvcnktYXdhcmUgYDxhPmAuXG4gKi9cbmNvbnN0IExpbmsgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBMaW5rV2l0aFJlZihfcmVmNywgcmVmKSB7XG4gIGxldCB7XG4gICAgICBvbkNsaWNrLFxuICAgICAgcmVsYXRpdmUsXG4gICAgICByZWxvYWREb2N1bWVudCxcbiAgICAgIHJlcGxhY2UsXG4gICAgICBzdGF0ZSxcbiAgICAgIHRhcmdldCxcbiAgICAgIHRvLFxuICAgICAgcHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb25cbiAgICB9ID0gX3JlZjcsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWY3LCBfZXhjbHVkZWQpO1xuICBsZXQge1xuICAgIGJhc2VuYW1lXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCk7XG4gIC8vIFJlbmRlcmVkIGludG8gPGEgaHJlZj4gZm9yIGFic29sdXRlIFVSTHNcbiAgbGV0IGFic29sdXRlSHJlZjtcbiAgbGV0IGlzRXh0ZXJuYWwgPSBmYWxzZTtcbiAgaWYgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiAmJiBBQlNPTFVURV9VUkxfUkVHRVgudGVzdCh0bykpIHtcbiAgICAvLyBSZW5kZXIgdGhlIGFic29sdXRlIGhyZWYgc2VydmVyLSBhbmQgY2xpZW50LXNpZGVcbiAgICBhYnNvbHV0ZUhyZWYgPSB0bztcbiAgICAvLyBPbmx5IGNoZWNrIGZvciBleHRlcm5hbCBvcmlnaW5zIGNsaWVudC1zaWRlXG4gICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbGV0IGN1cnJlbnRVcmwgPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgbGV0IHRhcmdldFVybCA9IHRvLnN0YXJ0c1dpdGgoXCIvL1wiKSA/IG5ldyBVUkwoY3VycmVudFVybC5wcm90b2NvbCArIHRvKSA6IG5ldyBVUkwodG8pO1xuICAgICAgICBsZXQgcGF0aCA9IHN0cmlwQmFzZW5hbWUodGFyZ2V0VXJsLnBhdGhuYW1lLCBiYXNlbmFtZSk7XG4gICAgICAgIGlmICh0YXJnZXRVcmwub3JpZ2luID09PSBjdXJyZW50VXJsLm9yaWdpbiAmJiBwYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBTdHJpcCB0aGUgcHJvdG9jb2wvb3JpZ2luL2Jhc2VuYW1lIGZvciBzYW1lLW9yaWdpbiBhYnNvbHV0ZSBVUkxzXG4gICAgICAgICAgdG8gPSBwYXRoICsgdGFyZ2V0VXJsLnNlYXJjaCArIHRhcmdldFVybC5oYXNoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzRXh0ZXJuYWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFdlIGNhbid0IGRvIGV4dGVybmFsIFVSTCBkZXRlY3Rpb24gd2l0aG91dCBhIHZhbGlkIFVSTFxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyhmYWxzZSwgXCI8TGluayB0bz1cXFwiXCIgKyB0byArIFwiXFxcIj4gY29udGFpbnMgYW4gaW52YWxpZCBVUkwgd2hpY2ggd2lsbCBwcm9iYWJseSBicmVhayBcIiArIFwid2hlbiBjbGlja2VkIC0gcGxlYXNlIHVwZGF0ZSB0byBhIHZhbGlkIFVSTCBwYXRoLlwiKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gUmVuZGVyZWQgaW50byA8YSBocmVmPiBmb3IgcmVsYXRpdmUgVVJMc1xuICBsZXQgaHJlZiA9IHVzZUhyZWYodG8sIHtcbiAgICByZWxhdGl2ZVxuICB9KTtcbiAgbGV0IGludGVybmFsT25DbGljayA9IHVzZUxpbmtDbGlja0hhbmRsZXIodG8sIHtcbiAgICByZXBsYWNlLFxuICAgIHN0YXRlLFxuICAgIHRhcmdldCxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgcmVsYXRpdmUsXG4gICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb25cbiAgfSk7XG4gIGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGV2ZW50KSB7XG4gICAgaWYgKG9uQ2xpY2spIG9uQ2xpY2soZXZlbnQpO1xuICAgIGlmICghZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgaW50ZXJuYWxPbkNsaWNrKGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIChcbiAgICAvKiNfX1BVUkVfXyovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGpzeC1hMTF5L2FuY2hvci1oYXMtY29udGVudFxuICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIF9leHRlbmRzKHt9LCByZXN0LCB7XG4gICAgICBocmVmOiBhYnNvbHV0ZUhyZWYgfHwgaHJlZixcbiAgICAgIG9uQ2xpY2s6IGlzRXh0ZXJuYWwgfHwgcmVsb2FkRG9jdW1lbnQgPyBvbkNsaWNrIDogaGFuZGxlQ2xpY2ssXG4gICAgICByZWY6IHJlZixcbiAgICAgIHRhcmdldDogdGFyZ2V0XG4gICAgfSkpXG4gICk7XG59KTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgTGluay5kaXNwbGF5TmFtZSA9IFwiTGlua1wiO1xufVxuLyoqXG4gKiBBIGA8TGluaz5gIHdyYXBwZXIgdGhhdCBrbm93cyBpZiBpdCdzIFwiYWN0aXZlXCIgb3Igbm90LlxuICovXG5jb25zdCBOYXZMaW5rID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gTmF2TGlua1dpdGhSZWYoX3JlZjgsIHJlZikge1xuICBsZXQge1xuICAgICAgXCJhcmlhLWN1cnJlbnRcIjogYXJpYUN1cnJlbnRQcm9wID0gXCJwYWdlXCIsXG4gICAgICBjYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVByb3AgPSBcIlwiLFxuICAgICAgZW5kID0gZmFsc2UsXG4gICAgICBzdHlsZTogc3R5bGVQcm9wLFxuICAgICAgdG8sXG4gICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbixcbiAgICAgIGNoaWxkcmVuXG4gICAgfSA9IF9yZWY4LFxuICAgIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShfcmVmOCwgX2V4Y2x1ZGVkMik7XG4gIGxldCBwYXRoID0gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7XG4gICAgcmVsYXRpdmU6IHJlc3QucmVsYXRpdmVcbiAgfSk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCByb3V0ZXJTdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xuICBsZXQge1xuICAgIG5hdmlnYXRvclxuICB9ID0gUmVhY3QudXNlQ29udGV4dChVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQpO1xuICBsZXQgaXNUcmFuc2l0aW9uaW5nID0gcm91dGVyU3RhdGUgIT0gbnVsbCAmJlxuICAvLyBDb25kaXRpb25hbCB1c2FnZSBpcyBPSyBoZXJlIGJlY2F1c2UgdGhlIHVzYWdlIG9mIGEgZGF0YSByb3V0ZXIgaXMgc3RhdGljXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICB1c2VWaWV3VHJhbnNpdGlvblN0YXRlKHBhdGgpICYmIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uID09PSB0cnVlO1xuICBsZXQgdG9QYXRobmFtZSA9IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbiA/IG5hdmlnYXRvci5lbmNvZGVMb2NhdGlvbihwYXRoKS5wYXRobmFtZSA6IHBhdGgucGF0aG5hbWU7XG4gIGxldCBsb2NhdGlvblBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gIGxldCBuZXh0TG9jYXRpb25QYXRobmFtZSA9IHJvdXRlclN0YXRlICYmIHJvdXRlclN0YXRlLm5hdmlnYXRpb24gJiYgcm91dGVyU3RhdGUubmF2aWdhdGlvbi5sb2NhdGlvbiA/IHJvdXRlclN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24ucGF0aG5hbWUgOiBudWxsO1xuICBpZiAoIWNhc2VTZW5zaXRpdmUpIHtcbiAgICBsb2NhdGlvblBhdGhuYW1lID0gbG9jYXRpb25QYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIG5leHRMb2NhdGlvblBhdGhuYW1lID0gbmV4dExvY2F0aW9uUGF0aG5hbWUgPyBuZXh0TG9jYXRpb25QYXRobmFtZS50b0xvd2VyQ2FzZSgpIDogbnVsbDtcbiAgICB0b1BhdGhuYW1lID0gdG9QYXRobmFtZS50b0xvd2VyQ2FzZSgpO1xuICB9XG4gIC8vIElmIHRoZSBgdG9gIGhhcyBhIHRyYWlsaW5nIHNsYXNoLCBsb29rIGF0IHRoYXQgZXhhY3Qgc3BvdC4gIE90aGVyd2lzZSxcbiAgLy8gd2UncmUgbG9va2luZyBmb3IgYSBzbGFzaCBfYWZ0ZXJfIHdoYXQncyBpbiBgdG9gLiAgRm9yIGV4YW1wbGU6XG4gIC8vXG4gIC8vIDxOYXZMaW5rIHRvPVwiL3VzZXJzXCI+IGFuZCA8TmF2TGluayB0bz1cIi91c2Vycy9cIj5cbiAgLy8gYm90aCB3YW50IHRvIGxvb2sgZm9yIGEgLyBhdCBpbmRleCA2IHRvIG1hdGNoIFVSTCBgL3VzZXJzL21hdHRgXG4gIGNvbnN0IGVuZFNsYXNoUG9zaXRpb24gPSB0b1BhdGhuYW1lICE9PSBcIi9cIiAmJiB0b1BhdGhuYW1lLmVuZHNXaXRoKFwiL1wiKSA/IHRvUGF0aG5hbWUubGVuZ3RoIC0gMSA6IHRvUGF0aG5hbWUubGVuZ3RoO1xuICBsZXQgaXNBY3RpdmUgPSBsb2NhdGlvblBhdGhuYW1lID09PSB0b1BhdGhuYW1lIHx8ICFlbmQgJiYgbG9jYXRpb25QYXRobmFtZS5zdGFydHNXaXRoKHRvUGF0aG5hbWUpICYmIGxvY2F0aW9uUGF0aG5hbWUuY2hhckF0KGVuZFNsYXNoUG9zaXRpb24pID09PSBcIi9cIjtcbiAgbGV0IGlzUGVuZGluZyA9IG5leHRMb2NhdGlvblBhdGhuYW1lICE9IG51bGwgJiYgKG5leHRMb2NhdGlvblBhdGhuYW1lID09PSB0b1BhdGhuYW1lIHx8ICFlbmQgJiYgbmV4dExvY2F0aW9uUGF0aG5hbWUuc3RhcnRzV2l0aCh0b1BhdGhuYW1lKSAmJiBuZXh0TG9jYXRpb25QYXRobmFtZS5jaGFyQXQodG9QYXRobmFtZS5sZW5ndGgpID09PSBcIi9cIik7XG4gIGxldCByZW5kZXJQcm9wcyA9IHtcbiAgICBpc0FjdGl2ZSxcbiAgICBpc1BlbmRpbmcsXG4gICAgaXNUcmFuc2l0aW9uaW5nXG4gIH07XG4gIGxldCBhcmlhQ3VycmVudCA9IGlzQWN0aXZlID8gYXJpYUN1cnJlbnRQcm9wIDogdW5kZWZpbmVkO1xuICBsZXQgY2xhc3NOYW1lO1xuICBpZiAodHlwZW9mIGNsYXNzTmFtZVByb3AgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNsYXNzTmFtZSA9IGNsYXNzTmFtZVByb3AocmVuZGVyUHJvcHMpO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHRoZSBjbGFzc05hbWUgcHJvcCBpcyBub3QgYSBmdW5jdGlvbiwgd2UgdXNlIGEgZGVmYXVsdCBgYWN0aXZlYFxuICAgIC8vIGNsYXNzIGZvciA8TmF2TGluayAvPnMgdGhhdCBhcmUgYWN0aXZlLiBJbiB2NSBgYWN0aXZlYCB3YXMgdGhlIGRlZmF1bHRcbiAgICAvLyB2YWx1ZSBmb3IgYGFjdGl2ZUNsYXNzTmFtZWAsIGJ1dCB3ZSBhcmUgcmVtb3ZpbmcgdGhhdCBBUEkgYW5kIGNhbiBzdGlsbFxuICAgIC8vIHVzZSB0aGUgb2xkIGRlZmF1bHQgYmVoYXZpb3IgZm9yIGEgY2xlYW5lciB1cGdyYWRlIHBhdGggYW5kIGtlZXAgdGhlXG4gICAgLy8gc2ltcGxlIHN0eWxpbmcgcnVsZXMgd29ya2luZyBhcyB0aGV5IGN1cnJlbnRseSBkby5cbiAgICBjbGFzc05hbWUgPSBbY2xhc3NOYW1lUHJvcCwgaXNBY3RpdmUgPyBcImFjdGl2ZVwiIDogbnVsbCwgaXNQZW5kaW5nID8gXCJwZW5kaW5nXCIgOiBudWxsLCBpc1RyYW5zaXRpb25pbmcgPyBcInRyYW5zaXRpb25pbmdcIiA6IG51bGxdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKTtcbiAgfVxuICBsZXQgc3R5bGUgPSB0eXBlb2Ygc3R5bGVQcm9wID09PSBcImZ1bmN0aW9uXCIgPyBzdHlsZVByb3AocmVuZGVyUHJvcHMpIDogc3R5bGVQcm9wO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoTGluaywgX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBcImFyaWEtY3VycmVudFwiOiBhcmlhQ3VycmVudCxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICByZWY6IHJlZixcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgdG86IHRvLFxuICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uOiB1bnN0YWJsZV92aWV3VHJhbnNpdGlvblxuICB9KSwgdHlwZW9mIGNoaWxkcmVuID09PSBcImZ1bmN0aW9uXCIgPyBjaGlsZHJlbihyZW5kZXJQcm9wcykgOiBjaGlsZHJlbik7XG59KTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgTmF2TGluay5kaXNwbGF5TmFtZSA9IFwiTmF2TGlua1wiO1xufVxuLyoqXG4gKiBBIGBAcmVtaXgtcnVuL3JvdXRlcmAtYXdhcmUgYDxmb3JtPmAuIEl0IGJlaGF2ZXMgbGlrZSBhIG5vcm1hbCBmb3JtIGV4Y2VwdFxuICogdGhhdCB0aGUgaW50ZXJhY3Rpb24gd2l0aCB0aGUgc2VydmVyIGlzIHdpdGggYGZldGNoYCBpbnN0ZWFkIG9mIG5ldyBkb2N1bWVudFxuICogcmVxdWVzdHMsIGFsbG93aW5nIGNvbXBvbmVudHMgdG8gYWRkIG5pY2VyIFVYIHRvIHRoZSBwYWdlIGFzIHRoZSBmb3JtIGlzXG4gKiBzdWJtaXR0ZWQgYW5kIHJldHVybnMgd2l0aCBkYXRhLlxuICovXG5jb25zdCBGb3JtID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKF9yZWY5LCBmb3J3YXJkZWRSZWYpID0+IHtcbiAgbGV0IHtcbiAgICAgIGZldGNoZXJLZXksXG4gICAgICBuYXZpZ2F0ZSxcbiAgICAgIHJlbG9hZERvY3VtZW50LFxuICAgICAgcmVwbGFjZSxcbiAgICAgIHN0YXRlLFxuICAgICAgbWV0aG9kID0gZGVmYXVsdE1ldGhvZCxcbiAgICAgIGFjdGlvbixcbiAgICAgIG9uU3VibWl0LFxuICAgICAgcmVsYXRpdmUsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvblxuICAgIH0gPSBfcmVmOSxcbiAgICBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWY5LCBfZXhjbHVkZWQzKTtcbiAgbGV0IHN1Ym1pdCA9IHVzZVN1Ym1pdCgpO1xuICBsZXQgZm9ybUFjdGlvbiA9IHVzZUZvcm1BY3Rpb24oYWN0aW9uLCB7XG4gICAgcmVsYXRpdmVcbiAgfSk7XG4gIGxldCBmb3JtTWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKCkgPT09IFwiZ2V0XCIgPyBcImdldFwiIDogXCJwb3N0XCI7XG4gIGxldCBzdWJtaXRIYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgIG9uU3VibWl0ICYmIG9uU3VibWl0KGV2ZW50KTtcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgbGV0IHN1Ym1pdHRlciA9IGV2ZW50Lm5hdGl2ZUV2ZW50LnN1Ym1pdHRlcjtcbiAgICBsZXQgc3VibWl0TWV0aG9kID0gKHN1Ym1pdHRlciA9PSBudWxsID8gdm9pZCAwIDogc3VibWl0dGVyLmdldEF0dHJpYnV0ZShcImZvcm1tZXRob2RcIikpIHx8IG1ldGhvZDtcbiAgICBzdWJtaXQoc3VibWl0dGVyIHx8IGV2ZW50LmN1cnJlbnRUYXJnZXQsIHtcbiAgICAgIGZldGNoZXJLZXksXG4gICAgICBtZXRob2Q6IHN1Ym1pdE1ldGhvZCxcbiAgICAgIG5hdmlnYXRlLFxuICAgICAgcmVwbGFjZSxcbiAgICAgIHN0YXRlLFxuICAgICAgcmVsYXRpdmUsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvblxuICAgIH0pO1xuICB9O1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIsIF9leHRlbmRzKHtcbiAgICByZWY6IGZvcndhcmRlZFJlZixcbiAgICBtZXRob2Q6IGZvcm1NZXRob2QsXG4gICAgYWN0aW9uOiBmb3JtQWN0aW9uLFxuICAgIG9uU3VibWl0OiByZWxvYWREb2N1bWVudCA/IG9uU3VibWl0IDogc3VibWl0SGFuZGxlclxuICB9LCBwcm9wcykpO1xufSk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIEZvcm0uZGlzcGxheU5hbWUgPSBcIkZvcm1cIjtcbn1cbi8qKlxuICogVGhpcyBjb21wb25lbnQgd2lsbCBlbXVsYXRlIHRoZSBicm93c2VyJ3Mgc2Nyb2xsIHJlc3RvcmF0aW9uIG9uIGxvY2F0aW9uXG4gKiBjaGFuZ2VzLlxuICovXG5mdW5jdGlvbiBTY3JvbGxSZXN0b3JhdGlvbihfcmVmMTApIHtcbiAgbGV0IHtcbiAgICBnZXRLZXksXG4gICAgc3RvcmFnZUtleVxuICB9ID0gX3JlZjEwO1xuICB1c2VTY3JvbGxSZXN0b3JhdGlvbih7XG4gICAgZ2V0S2V5LFxuICAgIHN0b3JhZ2VLZXlcbiAgfSk7XG4gIHJldHVybiBudWxsO1xufVxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBTY3JvbGxSZXN0b3JhdGlvbi5kaXNwbGF5TmFtZSA9IFwiU2Nyb2xsUmVzdG9yYXRpb25cIjtcbn1cbi8vI2VuZHJlZ2lvblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBIb29rc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbnZhciBEYXRhUm91dGVySG9vaztcbihmdW5jdGlvbiAoRGF0YVJvdXRlckhvb2spIHtcbiAgRGF0YVJvdXRlckhvb2tbXCJVc2VTY3JvbGxSZXN0b3JhdGlvblwiXSA9IFwidXNlU2Nyb2xsUmVzdG9yYXRpb25cIjtcbiAgRGF0YVJvdXRlckhvb2tbXCJVc2VTdWJtaXRcIl0gPSBcInVzZVN1Ym1pdFwiO1xuICBEYXRhUm91dGVySG9va1tcIlVzZVN1Ym1pdEZldGNoZXJcIl0gPSBcInVzZVN1Ym1pdEZldGNoZXJcIjtcbiAgRGF0YVJvdXRlckhvb2tbXCJVc2VGZXRjaGVyXCJdID0gXCJ1c2VGZXRjaGVyXCI7XG4gIERhdGFSb3V0ZXJIb29rW1widXNlVmlld1RyYW5zaXRpb25TdGF0ZVwiXSA9IFwidXNlVmlld1RyYW5zaXRpb25TdGF0ZVwiO1xufSkoRGF0YVJvdXRlckhvb2sgfHwgKERhdGFSb3V0ZXJIb29rID0ge30pKTtcbnZhciBEYXRhUm91dGVyU3RhdGVIb29rO1xuKGZ1bmN0aW9uIChEYXRhUm91dGVyU3RhdGVIb29rKSB7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VGZXRjaGVyXCJdID0gXCJ1c2VGZXRjaGVyXCI7XG4gIERhdGFSb3V0ZXJTdGF0ZUhvb2tbXCJVc2VGZXRjaGVyc1wiXSA9IFwidXNlRmV0Y2hlcnNcIjtcbiAgRGF0YVJvdXRlclN0YXRlSG9va1tcIlVzZVNjcm9sbFJlc3RvcmF0aW9uXCJdID0gXCJ1c2VTY3JvbGxSZXN0b3JhdGlvblwiO1xufSkoRGF0YVJvdXRlclN0YXRlSG9vayB8fCAoRGF0YVJvdXRlclN0YXRlSG9vayA9IHt9KSk7XG4vLyBJbnRlcm5hbCBob29rc1xuZnVuY3Rpb24gZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvcihob29rTmFtZSkge1xuICByZXR1cm4gaG9va05hbWUgKyBcIiBtdXN0IGJlIHVzZWQgd2l0aGluIGEgZGF0YSByb3V0ZXIuICBTZWUgaHR0cHM6Ly9yZWFjdHJvdXRlci5jb20vcm91dGVycy9waWNraW5nLWEtcm91dGVyLlwiO1xufVxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlckNvbnRleHQoaG9va05hbWUpIHtcbiAgbGV0IGN0eCA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX0RhdGFSb3V0ZXJDb250ZXh0KTtcbiAgIWN0eCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIGdldERhdGFSb3V0ZXJDb25zb2xlRXJyb3IoaG9va05hbWUpKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICByZXR1cm4gY3R4O1xufVxuZnVuY3Rpb24gdXNlRGF0YVJvdXRlclN0YXRlKGhvb2tOYW1lKSB7XG4gIGxldCBzdGF0ZSA9IFJlYWN0LnVzZUNvbnRleHQoVU5TQUZFX0RhdGFSb3V0ZXJTdGF0ZUNvbnRleHQpO1xuICAhc3RhdGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBnZXREYXRhUm91dGVyQ29uc29sZUVycm9yKGhvb2tOYW1lKSkgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgcmV0dXJuIHN0YXRlO1xufVxuLy8gRXh0ZXJuYWwgaG9va3Ncbi8qKlxuICogSGFuZGxlcyB0aGUgY2xpY2sgYmVoYXZpb3IgZm9yIHJvdXRlciBgPExpbms+YCBjb21wb25lbnRzLiBUaGlzIGlzIHVzZWZ1bCBpZlxuICogeW91IG5lZWQgdG8gY3JlYXRlIGN1c3RvbSBgPExpbms+YCBjb21wb25lbnRzIHdpdGggdGhlIHNhbWUgY2xpY2sgYmVoYXZpb3Igd2VcbiAqIHVzZSBpbiBvdXIgZXhwb3J0ZWQgYDxMaW5rPmAuXG4gKi9cbmZ1bmN0aW9uIHVzZUxpbmtDbGlja0hhbmRsZXIodG8sIF90ZW1wKSB7XG4gIGxldCB7XG4gICAgdGFyZ2V0LFxuICAgIHJlcGxhY2U6IHJlcGxhY2VQcm9wLFxuICAgIHN0YXRlLFxuICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICByZWxhdGl2ZSxcbiAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvblxuICB9ID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXA7XG4gIGxldCBuYXZpZ2F0ZSA9IHVzZU5hdmlnYXRlKCk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBwYXRoID0gdXNlUmVzb2x2ZWRQYXRoKHRvLCB7XG4gICAgcmVsYXRpdmVcbiAgfSk7XG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhldmVudCA9PiB7XG4gICAgaWYgKHNob3VsZFByb2Nlc3NMaW5rQ2xpY2soZXZlbnQsIHRhcmdldCkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAvLyBJZiB0aGUgVVJMIGhhc24ndCBjaGFuZ2VkLCBhIHJlZ3VsYXIgPGE+IHdpbGwgZG8gYSByZXBsYWNlIGluc3RlYWQgb2ZcbiAgICAgIC8vIGEgcHVzaCwgc28gZG8gdGhlIHNhbWUgaGVyZSB1bmxlc3MgdGhlIHJlcGxhY2UgcHJvcCBpcyBleHBsaWNpdGx5IHNldFxuICAgICAgbGV0IHJlcGxhY2UgPSByZXBsYWNlUHJvcCAhPT0gdW5kZWZpbmVkID8gcmVwbGFjZVByb3AgOiBjcmVhdGVQYXRoKGxvY2F0aW9uKSA9PT0gY3JlYXRlUGF0aChwYXRoKTtcbiAgICAgIG5hdmlnYXRlKHRvLCB7XG4gICAgICAgIHJlcGxhY2UsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICAgIHJlbGF0aXZlLFxuICAgICAgICB1bnN0YWJsZV92aWV3VHJhbnNpdGlvblxuICAgICAgfSk7XG4gICAgfVxuICB9LCBbbG9jYXRpb24sIG5hdmlnYXRlLCBwYXRoLCByZXBsYWNlUHJvcCwgc3RhdGUsIHRhcmdldCwgdG8sIHByZXZlbnRTY3JvbGxSZXNldCwgcmVsYXRpdmUsIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uXSk7XG59XG4vKipcbiAqIEEgY29udmVuaWVudCB3cmFwcGVyIGZvciByZWFkaW5nIGFuZCB3cml0aW5nIHNlYXJjaCBwYXJhbWV0ZXJzIHZpYSB0aGVcbiAqIFVSTFNlYXJjaFBhcmFtcyBpbnRlcmZhY2UuXG4gKi9cbmZ1bmN0aW9uIHVzZVNlYXJjaFBhcmFtcyhkZWZhdWx0SW5pdCkge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfd2FybmluZyh0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSBcInVuZGVmaW5lZFwiLCBcIllvdSBjYW5ub3QgdXNlIHRoZSBgdXNlU2VhcmNoUGFyYW1zYCBob29rIGluIGEgYnJvd3NlciB0aGF0IGRvZXMgbm90IFwiICsgXCJzdXBwb3J0IHRoZSBVUkxTZWFyY2hQYXJhbXMgQVBJLiBJZiB5b3UgbmVlZCB0byBzdXBwb3J0IEludGVybmV0IFwiICsgXCJFeHBsb3JlciAxMSwgd2UgcmVjb21tZW5kIHlvdSBsb2FkIGEgcG9seWZpbGwgc3VjaCBhcyBcIiArIFwiaHR0cHM6Ly9naXRodWIuY29tL3VuZ2FwL3VybC1zZWFyY2gtcGFyYW1zXFxuXFxuXCIgKyBcIklmIHlvdSdyZSB1bnN1cmUgaG93IHRvIGxvYWQgcG9seWZpbGxzLCB3ZSByZWNvbW1lbmQgeW91IGNoZWNrIG91dCBcIiArIFwiaHR0cHM6Ly9wb2x5ZmlsbC5pby92My8gd2hpY2ggcHJvdmlkZXMgc29tZSByZWNvbW1lbmRhdGlvbnMgYWJvdXQgaG93IFwiICsgXCJ0byBsb2FkIHBvbHlmaWxscyBvbmx5IGZvciB1c2VycyB0aGF0IG5lZWQgdGhlbSwgaW5zdGVhZCBvZiBmb3IgZXZlcnkgXCIgKyBcInVzZXIuXCIpIDogdm9pZCAwO1xuICBsZXQgZGVmYXVsdFNlYXJjaFBhcmFtc1JlZiA9IFJlYWN0LnVzZVJlZihjcmVhdGVTZWFyY2hQYXJhbXMoZGVmYXVsdEluaXQpKTtcbiAgbGV0IGhhc1NldFNlYXJjaFBhcmFtc1JlZiA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBzZWFyY2hQYXJhbXMgPSBSZWFjdC51c2VNZW1vKCgpID0+XG4gIC8vIE9ubHkgbWVyZ2UgaW4gdGhlIGRlZmF1bHRzIGlmIHdlIGhhdmVuJ3QgeWV0IGNhbGxlZCBzZXRTZWFyY2hQYXJhbXMuXG4gIC8vIE9uY2Ugd2UgY2FsbCB0aGF0IHdlIHdhbnQgdGhvc2UgdG8gdGFrZSBwcmVjZWRlbmNlLCBvdGhlcndpc2UgeW91IGNhbid0XG4gIC8vIHJlbW92ZSBhIHBhcmFtIHdpdGggc2V0U2VhcmNoUGFyYW1zKHt9KSBpZiBpdCBoYXMgYW4gaW5pdGlhbCB2YWx1ZVxuICBnZXRTZWFyY2hQYXJhbXNGb3JMb2NhdGlvbihsb2NhdGlvbi5zZWFyY2gsIGhhc1NldFNlYXJjaFBhcmFtc1JlZi5jdXJyZW50ID8gbnVsbCA6IGRlZmF1bHRTZWFyY2hQYXJhbXNSZWYuY3VycmVudCksIFtsb2NhdGlvbi5zZWFyY2hdKTtcbiAgbGV0IG5hdmlnYXRlID0gdXNlTmF2aWdhdGUoKTtcbiAgbGV0IHNldFNlYXJjaFBhcmFtcyA9IFJlYWN0LnVzZUNhbGxiYWNrKChuZXh0SW5pdCwgbmF2aWdhdGVPcHRpb25zKSA9PiB7XG4gICAgY29uc3QgbmV3U2VhcmNoUGFyYW1zID0gY3JlYXRlU2VhcmNoUGFyYW1zKHR5cGVvZiBuZXh0SW5pdCA9PT0gXCJmdW5jdGlvblwiID8gbmV4dEluaXQoc2VhcmNoUGFyYW1zKSA6IG5leHRJbml0KTtcbiAgICBoYXNTZXRTZWFyY2hQYXJhbXNSZWYuY3VycmVudCA9IHRydWU7XG4gICAgbmF2aWdhdGUoXCI/XCIgKyBuZXdTZWFyY2hQYXJhbXMsIG5hdmlnYXRlT3B0aW9ucyk7XG4gIH0sIFtuYXZpZ2F0ZSwgc2VhcmNoUGFyYW1zXSk7XG4gIHJldHVybiBbc2VhcmNoUGFyYW1zLCBzZXRTZWFyY2hQYXJhbXNdO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVDbGllbnRTaWRlU3VibWlzc2lvbigpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBhcmUgY2FsbGluZyBzdWJtaXQgZHVyaW5nIHRoZSBzZXJ2ZXIgcmVuZGVyLiBcIiArIFwiVHJ5IGNhbGxpbmcgc3VibWl0IHdpdGhpbiBhIGB1c2VFZmZlY3RgIG9yIGNhbGxiYWNrIGluc3RlYWQuXCIpO1xuICB9XG59XG5sZXQgZmV0Y2hlcklkID0gMDtcbmxldCBnZXRVbmlxdWVGZXRjaGVySWQgPSAoKSA9PiBcIl9fXCIgKyBTdHJpbmcoKytmZXRjaGVySWQpICsgXCJfX1wiO1xuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBtYXkgYmUgdXNlZCB0byBwcm9ncmFtbWF0aWNhbGx5IHN1Ym1pdCBhIGZvcm0gKG9yXG4gKiBzb21lIGFyYml0cmFyeSBkYXRhKSB0byB0aGUgc2VydmVyLlxuICovXG5mdW5jdGlvbiB1c2VTdWJtaXQoKSB7XG4gIGxldCB7XG4gICAgcm91dGVyXG4gIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VTdWJtaXQpO1xuICBsZXQge1xuICAgIGJhc2VuYW1lXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCBjdXJyZW50Um91dGVJZCA9IFVOU0FGRV91c2VSb3V0ZUlkKCk7XG4gIHJldHVybiBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICB2YWxpZGF0ZUNsaWVudFNpZGVTdWJtaXNzaW9uKCk7XG4gICAgbGV0IHtcbiAgICAgIGFjdGlvbixcbiAgICAgIG1ldGhvZCxcbiAgICAgIGVuY1R5cGUsXG4gICAgICBmb3JtRGF0YSxcbiAgICAgIGJvZHlcbiAgICB9ID0gZ2V0Rm9ybVN1Ym1pc3Npb25JbmZvKHRhcmdldCwgYmFzZW5hbWUpO1xuICAgIGlmIChvcHRpb25zLm5hdmlnYXRlID09PSBmYWxzZSkge1xuICAgICAgbGV0IGtleSA9IG9wdGlvbnMuZmV0Y2hlcktleSB8fCBnZXRVbmlxdWVGZXRjaGVySWQoKTtcbiAgICAgIHJvdXRlci5mZXRjaChrZXksIGN1cnJlbnRSb3V0ZUlkLCBvcHRpb25zLmFjdGlvbiB8fCBhY3Rpb24sIHtcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBvcHRpb25zLnByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgICAgZm9ybURhdGEsXG4gICAgICAgIGJvZHksXG4gICAgICAgIGZvcm1NZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8IG1ldGhvZCxcbiAgICAgICAgZm9ybUVuY1R5cGU6IG9wdGlvbnMuZW5jVHlwZSB8fCBlbmNUeXBlLFxuICAgICAgICB1bnN0YWJsZV9mbHVzaFN5bmM6IG9wdGlvbnMudW5zdGFibGVfZmx1c2hTeW5jXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm91dGVyLm5hdmlnYXRlKG9wdGlvbnMuYWN0aW9uIHx8IGFjdGlvbiwge1xuICAgICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IG9wdGlvbnMucHJldmVudFNjcm9sbFJlc2V0LFxuICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgYm9keSxcbiAgICAgICAgZm9ybU1ldGhvZDogb3B0aW9ucy5tZXRob2QgfHwgbWV0aG9kLFxuICAgICAgICBmb3JtRW5jVHlwZTogb3B0aW9ucy5lbmNUeXBlIHx8IGVuY1R5cGUsXG4gICAgICAgIHJlcGxhY2U6IG9wdGlvbnMucmVwbGFjZSxcbiAgICAgICAgc3RhdGU6IG9wdGlvbnMuc3RhdGUsXG4gICAgICAgIGZyb21Sb3V0ZUlkOiBjdXJyZW50Um91dGVJZCxcbiAgICAgICAgdW5zdGFibGVfZmx1c2hTeW5jOiBvcHRpb25zLnVuc3RhYmxlX2ZsdXNoU3luYyxcbiAgICAgICAgdW5zdGFibGVfdmlld1RyYW5zaXRpb246IG9wdGlvbnMudW5zdGFibGVfdmlld1RyYW5zaXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW3JvdXRlciwgYmFzZW5hbWUsIGN1cnJlbnRSb3V0ZUlkXSk7XG59XG4vLyB2NzogRXZlbnR1YWxseSB3ZSBzaG91bGQgZGVwcmVjYXRlIHRoaXMgZW50aXJlbHkgaW4gZmF2b3Igb2YgdXNpbmcgdGhlXG4vLyByb3V0ZXIgbWV0aG9kIGRpcmVjdGx5P1xuZnVuY3Rpb24gdXNlRm9ybUFjdGlvbihhY3Rpb24sIF90ZW1wMikge1xuICBsZXQge1xuICAgIHJlbGF0aXZlXG4gIH0gPSBfdGVtcDIgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAyO1xuICBsZXQge1xuICAgIGJhc2VuYW1lXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCByb3V0ZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9Sb3V0ZUNvbnRleHQpO1xuICAhcm91dGVDb250ZXh0ID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJ1c2VGb3JtQWN0aW9uIG11c3QgYmUgdXNlZCBpbnNpZGUgYSBSb3V0ZUNvbnRleHRcIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgbGV0IFttYXRjaF0gPSByb3V0ZUNvbnRleHQubWF0Y2hlcy5zbGljZSgtMSk7XG4gIC8vIFNoYWxsb3cgY2xvbmUgcGF0aCBzbyB3ZSBjYW4gbW9kaWZ5IGl0IGJlbG93LCBvdGhlcndpc2Ugd2UgbW9kaWZ5IHRoZVxuICAvLyBvYmplY3QgcmVmZXJlbmNlZCBieSB1c2VNZW1vIGluc2lkZSB1c2VSZXNvbHZlZFBhdGhcbiAgbGV0IHBhdGggPSBfZXh0ZW5kcyh7fSwgdXNlUmVzb2x2ZWRQYXRoKGFjdGlvbiA/IGFjdGlvbiA6IFwiLlwiLCB7XG4gICAgcmVsYXRpdmVcbiAgfSkpO1xuICAvLyBQcmV2aW91c2x5IHdlIHNldCB0aGUgZGVmYXVsdCBhY3Rpb24gdG8gXCIuXCIuIFRoZSBwcm9ibGVtIHdpdGggdGhpcyBpcyB0aGF0XG4gIC8vIGB1c2VSZXNvbHZlZFBhdGgoXCIuXCIpYCBleGNsdWRlcyBzZWFyY2ggcGFyYW1zIG9mIHRoZSByZXNvbHZlZCBVUkwuIFRoaXMgaXNcbiAgLy8gdGhlIGludGVuZGVkIGJlaGF2aW9yIG9mIHdoZW4gXCIuXCIgaXMgc3BlY2lmaWNhbGx5IHByb3ZpZGVkIGFzXG4gIC8vIHRoZSBmb3JtIGFjdGlvbiwgYnV0IGluY29uc2lzdGVudCB3LyBicm93c2VycyB3aGVuIHRoZSBhY3Rpb24gaXMgb21pdHRlZC5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9yZW1peC9pc3N1ZXMvOTI3XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGlmIChhY3Rpb24gPT0gbnVsbCkge1xuICAgIC8vIFNhZmUgdG8gd3JpdGUgdG8gdGhpcyBkaXJlY3RseSBoZXJlIHNpbmNlIGlmIGFjdGlvbiB3YXMgdW5kZWZpbmVkLCB3ZVxuICAgIC8vIHdvdWxkIGhhdmUgY2FsbGVkIHVzZVJlc29sdmVkUGF0aChcIi5cIikgd2hpY2ggd2lsbCBuZXZlciBpbmNsdWRlIGEgc2VhcmNoXG4gICAgcGF0aC5zZWFyY2ggPSBsb2NhdGlvbi5zZWFyY2g7XG4gICAgLy8gV2hlbiBncmFiYmluZyBzZWFyY2ggcGFyYW1zIGZyb20gdGhlIFVSTCwgcmVtb3ZlIGFueSBpbmNsdWRlZCA/aW5kZXggcGFyYW1cbiAgICAvLyBzaW5jZSBpdCBtaWdodCBub3QgYXBwbHkgdG8gb3VyIGNvbnRleHR1YWwgcm91dGUuICBXZSBhZGQgaXQgYmFjayBiYXNlZFxuICAgIC8vIG9uIG1hdGNoLnJvdXRlLmluZGV4IGJlbG93XG4gICAgbGV0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocGF0aC5zZWFyY2gpO1xuICAgIGlmIChwYXJhbXMuaGFzKFwiaW5kZXhcIikgJiYgcGFyYW1zLmdldChcImluZGV4XCIpID09PSBcIlwiKSB7XG4gICAgICBwYXJhbXMuZGVsZXRlKFwiaW5kZXhcIik7XG4gICAgICBwYXRoLnNlYXJjaCA9IHBhcmFtcy50b1N0cmluZygpID8gXCI/XCIgKyBwYXJhbXMudG9TdHJpbmcoKSA6IFwiXCI7XG4gICAgfVxuICB9XG4gIGlmICgoIWFjdGlvbiB8fCBhY3Rpb24gPT09IFwiLlwiKSAmJiBtYXRjaC5yb3V0ZS5pbmRleCkge1xuICAgIHBhdGguc2VhcmNoID0gcGF0aC5zZWFyY2ggPyBwYXRoLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgXCI/aW5kZXgmXCIpIDogXCI/aW5kZXhcIjtcbiAgfVxuICAvLyBJZiB3ZSdyZSBvcGVyYXRpbmcgd2l0aGluIGEgYmFzZW5hbWUsIHByZXBlbmQgaXQgdG8gdGhlIHBhdGhuYW1lIHByaW9yXG4gIC8vIHRvIGNyZWF0aW5nIHRoZSBmb3JtIGFjdGlvbi4gIElmIHRoaXMgaXMgYSByb290IG5hdmlnYXRpb24sIHRoZW4ganVzdCB1c2VcbiAgLy8gdGhlIHJhdyBiYXNlbmFtZSB3aGljaCBhbGxvd3MgdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlXG4gIC8vIHByZXNlbmNlIG9mIGEgdHJhaWxpbmcgc2xhc2ggb24gcm9vdCBhY3Rpb25zXG4gIGlmIChiYXNlbmFtZSAhPT0gXCIvXCIpIHtcbiAgICBwYXRoLnBhdGhuYW1lID0gcGF0aC5wYXRobmFtZSA9PT0gXCIvXCIgPyBiYXNlbmFtZSA6IGpvaW5QYXRocyhbYmFzZW5hbWUsIHBhdGgucGF0aG5hbWVdKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlUGF0aChwYXRoKTtcbn1cbi8vIFRPRE86ICh2NykgQ2hhbmdlIHRoZSB1c2VGZXRjaGVyIGdlbmVyaWMgZGVmYXVsdCBmcm9tIGBhbnlgIHRvIGB1bmtub3duYFxuLyoqXG4gKiBJbnRlcmFjdHMgd2l0aCByb3V0ZSBsb2FkZXJzIGFuZCBhY3Rpb25zIHdpdGhvdXQgY2F1c2luZyBhIG5hdmlnYXRpb24uIEdyZWF0XG4gKiBmb3IgYW55IGludGVyYWN0aW9uIHRoYXQgc3RheXMgb24gdGhlIHNhbWUgcGFnZS5cbiAqL1xuZnVuY3Rpb24gdXNlRmV0Y2hlcihfdGVtcDMpIHtcbiAgdmFyIF9yb3V0ZSRtYXRjaGVzO1xuICBsZXQge1xuICAgIGtleVxuICB9ID0gX3RlbXAzID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMztcbiAgbGV0IHtcbiAgICByb3V0ZXJcbiAgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLlVzZUZldGNoZXIpO1xuICBsZXQgc3RhdGUgPSB1c2VEYXRhUm91dGVyU3RhdGUoRGF0YVJvdXRlclN0YXRlSG9vay5Vc2VGZXRjaGVyKTtcbiAgbGV0IGZldGNoZXJEYXRhID0gUmVhY3QudXNlQ29udGV4dChGZXRjaGVyc0NvbnRleHQpO1xuICBsZXQgcm91dGUgPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9Sb3V0ZUNvbnRleHQpO1xuICBsZXQgcm91dGVJZCA9IChfcm91dGUkbWF0Y2hlcyA9IHJvdXRlLm1hdGNoZXNbcm91dGUubWF0Y2hlcy5sZW5ndGggLSAxXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yb3V0ZSRtYXRjaGVzLnJvdXRlLmlkO1xuICAhZmV0Y2hlckRhdGEgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcInVzZUZldGNoZXIgbXVzdCBiZSB1c2VkIGluc2lkZSBhIEZldGNoZXJzQ29udGV4dFwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAhcm91dGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcInVzZUZldGNoZXIgbXVzdCBiZSB1c2VkIGluc2lkZSBhIFJvdXRlQ29udGV4dFwiKSA6IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UpIDogdm9pZCAwO1xuICAhKHJvdXRlSWQgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBVTlNBRkVfaW52YXJpYW50KGZhbHNlLCBcInVzZUZldGNoZXIgY2FuIG9ubHkgYmUgdXNlZCBvbiByb3V0ZXMgdGhhdCBjb250YWluIGEgdW5pcXVlIFxcXCJpZFxcXCJcIikgOiBVTlNBRkVfaW52YXJpYW50KGZhbHNlKSA6IHZvaWQgMDtcbiAgLy8gRmV0Y2hlciBrZXkgaGFuZGxpbmdcbiAgbGV0IFtmZXRjaGVyS2V5LCBzZXRGZXRjaGVyS2V5XSA9IFJlYWN0LnVzZVN0YXRlKGtleSB8fCBcIlwiKTtcbiAgaWYgKGtleSAmJiBrZXkgIT09IGZldGNoZXJLZXkpIHtcbiAgICBzZXRGZXRjaGVyS2V5KGtleSk7XG4gIH0gZWxzZSBpZiAoIWZldGNoZXJLZXkpIHtcbiAgICBzZXRGZXRjaGVyS2V5KGdldFVuaXF1ZUZldGNoZXJJZCgpKTtcbiAgfVxuICAvLyBSZWdpc3RyYXRpb24vY2xlYW51cFxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJvdXRlci5nZXRGZXRjaGVyKGZldGNoZXJLZXkpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBUZWxsIHRoZSByb3V0ZXIgd2UndmUgdW5tb3VudGVkIC0gaWYgdjdfZmV0Y2hlclBlcnNpc3QgaXMgZW5hYmxlZCB0aGlzXG4gICAgICAvLyB3aWxsIG5vdCBkZWxldGUgaW1tZWRpYXRlbHkgYnV0IGluc3RlYWQgcXVldWUgdXAgYSBkZWxldGUgYWZ0ZXIgdGhlXG4gICAgICAvLyBmZXRjaGVyIHJldHVybnMgdG8gYW4gYGlkbGVgIHN0YXRlXG4gICAgICByb3V0ZXIuZGVsZXRlRmV0Y2hlcihmZXRjaGVyS2V5KTtcbiAgICB9O1xuICB9LCBbcm91dGVyLCBmZXRjaGVyS2V5XSk7XG4gIC8vIEZldGNoZXIgYWRkaXRpb25zXG4gIGxldCBsb2FkID0gUmVhY3QudXNlQ2FsbGJhY2soKGhyZWYsIG9wdHMpID0+IHtcbiAgICAhcm91dGVJZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV9pbnZhcmlhbnQoZmFsc2UsIFwiTm8gcm91dGVJZCBhdmFpbGFibGUgZm9yIGZldGNoZXIubG9hZCgpXCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gICAgcm91dGVyLmZldGNoKGZldGNoZXJLZXksIHJvdXRlSWQsIGhyZWYsIG9wdHMpO1xuICB9LCBbZmV0Y2hlcktleSwgcm91dGVJZCwgcm91dGVyXSk7XG4gIGxldCBzdWJtaXRJbXBsID0gdXNlU3VibWl0KCk7XG4gIGxldCBzdWJtaXQgPSBSZWFjdC51c2VDYWxsYmFjaygodGFyZ2V0LCBvcHRzKSA9PiB7XG4gICAgc3VibWl0SW1wbCh0YXJnZXQsIF9leHRlbmRzKHt9LCBvcHRzLCB7XG4gICAgICBuYXZpZ2F0ZTogZmFsc2UsXG4gICAgICBmZXRjaGVyS2V5XG4gICAgfSkpO1xuICB9LCBbZmV0Y2hlcktleSwgc3VibWl0SW1wbF0pO1xuICBsZXQgRmV0Y2hlckZvcm0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBsZXQgRmV0Y2hlckZvcm0gPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZvcm0sIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgICBuYXZpZ2F0ZTogZmFsc2UsXG4gICAgICAgIGZldGNoZXJLZXk6IGZldGNoZXJLZXksXG4gICAgICAgIHJlZjogcmVmXG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgRmV0Y2hlckZvcm0uZGlzcGxheU5hbWUgPSBcImZldGNoZXIuRm9ybVwiO1xuICAgIH1cbiAgICByZXR1cm4gRmV0Y2hlckZvcm07XG4gIH0sIFtmZXRjaGVyS2V5XSk7XG4gIC8vIEV4cG9zZWQgRmV0Y2hlcldpdGhDb21wb25lbnRzXG4gIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGZldGNoZXJLZXkpIHx8IElETEVfRkVUQ0hFUjtcbiAgbGV0IGRhdGEgPSBmZXRjaGVyRGF0YS5nZXQoZmV0Y2hlcktleSk7XG4gIGxldCBmZXRjaGVyV2l0aENvbXBvbmVudHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IF9leHRlbmRzKHtcbiAgICBGb3JtOiBGZXRjaGVyRm9ybSxcbiAgICBzdWJtaXQsXG4gICAgbG9hZFxuICB9LCBmZXRjaGVyLCB7XG4gICAgZGF0YVxuICB9KSwgW0ZldGNoZXJGb3JtLCBzdWJtaXQsIGxvYWQsIGZldGNoZXIsIGRhdGFdKTtcbiAgcmV0dXJuIGZldGNoZXJXaXRoQ29tcG9uZW50cztcbn1cbi8qKlxuICogUHJvdmlkZXMgYWxsIGZldGNoZXJzIGN1cnJlbnRseSBvbiB0aGUgcGFnZS4gVXNlZnVsIGZvciBsYXlvdXRzIGFuZCBwYXJlbnRcbiAqIHJvdXRlcyB0aGF0IG5lZWQgdG8gcHJvdmlkZSBwZW5kaW5nL29wdGltaXN0aWMgVUkgcmVnYXJkaW5nIHRoZSBmZXRjaC5cbiAqL1xuZnVuY3Rpb24gdXNlRmV0Y2hlcnMoKSB7XG4gIGxldCBzdGF0ZSA9IHVzZURhdGFSb3V0ZXJTdGF0ZShEYXRhUm91dGVyU3RhdGVIb29rLlVzZUZldGNoZXJzKTtcbiAgcmV0dXJuIEFycmF5LmZyb20oc3RhdGUuZmV0Y2hlcnMuZW50cmllcygpKS5tYXAoX3JlZjExID0+IHtcbiAgICBsZXQgW2tleSwgZmV0Y2hlcl0gPSBfcmVmMTE7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBmZXRjaGVyLCB7XG4gICAgICBrZXlcbiAgICB9KTtcbiAgfSk7XG59XG5jb25zdCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVkgPSBcInJlYWN0LXJvdXRlci1zY3JvbGwtcG9zaXRpb25zXCI7XG5sZXQgc2F2ZWRTY3JvbGxQb3NpdGlvbnMgPSB7fTtcbi8qKlxuICogV2hlbiByZW5kZXJlZCBpbnNpZGUgYSBSb3V0ZXJQcm92aWRlciwgd2lsbCByZXN0b3JlIHNjcm9sbCBwb3NpdGlvbnMgb24gbmF2aWdhdGlvbnNcbiAqL1xuZnVuY3Rpb24gdXNlU2Nyb2xsUmVzdG9yYXRpb24oX3RlbXA0KSB7XG4gIGxldCB7XG4gICAgZ2V0S2V5LFxuICAgIHN0b3JhZ2VLZXlcbiAgfSA9IF90ZW1wNCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDQ7XG4gIGxldCB7XG4gICAgcm91dGVyXG4gIH0gPSB1c2VEYXRhUm91dGVyQ29udGV4dChEYXRhUm91dGVySG9vay5Vc2VTY3JvbGxSZXN0b3JhdGlvbik7XG4gIGxldCB7XG4gICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uLFxuICAgIHByZXZlbnRTY3JvbGxSZXNldFxuICB9ID0gdXNlRGF0YVJvdXRlclN0YXRlKERhdGFSb3V0ZXJTdGF0ZUhvb2suVXNlU2Nyb2xsUmVzdG9yYXRpb24pO1xuICBsZXQge1xuICAgIGJhc2VuYW1lXG4gIH0gPSBSZWFjdC51c2VDb250ZXh0KFVOU0FGRV9OYXZpZ2F0aW9uQ29udGV4dCk7XG4gIGxldCBsb2NhdGlvbiA9IHVzZUxvY2F0aW9uKCk7XG4gIGxldCBtYXRjaGVzID0gdXNlTWF0Y2hlcygpO1xuICBsZXQgbmF2aWdhdGlvbiA9IHVzZU5hdmlnYXRpb24oKTtcbiAgLy8gVHJpZ2dlciBtYW51YWwgc2Nyb2xsIHJlc3RvcmF0aW9uIHdoaWxlIHdlJ3JlIGFjdGl2ZVxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJtYW51YWxcIjtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcImF1dG9cIjtcbiAgICB9O1xuICB9LCBbXSk7XG4gIC8vIFNhdmUgcG9zaXRpb25zIG9uIHBhZ2VoaWRlXG4gIHVzZVBhZ2VIaWRlKFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBpZiAobmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgIGxldCBrZXkgPSAoZ2V0S2V5ID8gZ2V0S2V5KGxvY2F0aW9uLCBtYXRjaGVzKSA6IG51bGwpIHx8IGxvY2F0aW9uLmtleTtcbiAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zW2tleV0gPSB3aW5kb3cuc2Nyb2xsWTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oc3RvcmFnZUtleSB8fCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVksIEpTT04uc3RyaW5naWZ5KHNhdmVkU2Nyb2xsUG9zaXRpb25zKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFVOU0FGRV93YXJuaW5nKGZhbHNlLCBcIkZhaWxlZCB0byBzYXZlIHNjcm9sbCBwb3NpdGlvbnMgaW4gc2Vzc2lvblN0b3JhZ2UsIDxTY3JvbGxSZXN0b3JhdGlvbiAvPiB3aWxsIG5vdCB3b3JrIHByb3Blcmx5IChcIiArIGVycm9yICsgXCIpLlwiKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgd2luZG93Lmhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSBcImF1dG9cIjtcbiAgfSwgW3N0b3JhZ2VLZXksIGdldEtleSwgbmF2aWdhdGlvbi5zdGF0ZSwgbG9jYXRpb24sIG1hdGNoZXNdKSk7XG4gIC8vIFJlYWQgaW4gYW55IHNhdmVkIHNjcm9sbCBsb2NhdGlvbnNcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBsZXQgc2Vzc2lvblBvc2l0aW9ucyA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSB8fCBTQ1JPTExfUkVTVE9SQVRJT05fU1RPUkFHRV9LRVkpO1xuICAgICAgICBpZiAoc2Vzc2lvblBvc2l0aW9ucykge1xuICAgICAgICAgIHNhdmVkU2Nyb2xsUG9zaXRpb25zID0gSlNPTi5wYXJzZShzZXNzaW9uUG9zaXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBuby1vcCwgdXNlIGRlZmF1bHQgZW1wdHkgb2JqZWN0XG4gICAgICB9XG4gICAgfSwgW3N0b3JhZ2VLZXldKTtcbiAgICAvLyBFbmFibGUgc2Nyb2xsIHJlc3RvcmF0aW9uIGluIHRoZSByb3V0ZXJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgbGV0IGdldEtleVdpdGhvdXRCYXNlbmFtZSA9IGdldEtleSAmJiBiYXNlbmFtZSAhPT0gXCIvXCIgPyAobG9jYXRpb24sIG1hdGNoZXMpID0+IGdldEtleSggLy8gU3RyaXAgdGhlIGJhc2VuYW1lIHRvIG1hdGNoIHVzZUxvY2F0aW9uKClcbiAgICAgIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgICAgICBwYXRobmFtZTogc3RyaXBCYXNlbmFtZShsb2NhdGlvbi5wYXRobmFtZSwgYmFzZW5hbWUpIHx8IGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICB9KSwgbWF0Y2hlcykgOiBnZXRLZXk7XG4gICAgICBsZXQgZGlzYWJsZVNjcm9sbFJlc3RvcmF0aW9uID0gcm91dGVyID09IG51bGwgPyB2b2lkIDAgOiByb3V0ZXIuZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24oc2F2ZWRTY3JvbGxQb3NpdGlvbnMsICgpID0+IHdpbmRvdy5zY3JvbGxZLCBnZXRLZXlXaXRob3V0QmFzZW5hbWUpO1xuICAgICAgcmV0dXJuICgpID0+IGRpc2FibGVTY3JvbGxSZXN0b3JhdGlvbiAmJiBkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24oKTtcbiAgICB9LCBbcm91dGVyLCBiYXNlbmFtZSwgZ2V0S2V5XSk7XG4gICAgLy8gUmVzdG9yZSBzY3JvbGxpbmcgd2hlbiBzdGF0ZS5yZXN0b3JlU2Nyb2xsUG9zaXRpb24gY2hhbmdlc1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAvLyBFeHBsaWNpdCBmYWxzZSBtZWFucyBkb24ndCBkbyBhbnl0aGluZyAodXNlZCBmb3Igc3VibWlzc2lvbnMpXG4gICAgICBpZiAocmVzdG9yZVNjcm9sbFBvc2l0aW9uID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBiZWVuIGhlcmUgYmVmb3JlLCBzY3JvbGwgdG8gaXRcbiAgICAgIGlmICh0eXBlb2YgcmVzdG9yZVNjcm9sbFBvc2l0aW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCByZXN0b3JlU2Nyb2xsUG9zaXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyB0cnkgdG8gc2Nyb2xsIHRvIHRoZSBoYXNoXG4gICAgICBpZiAobG9jYXRpb24uaGFzaCkge1xuICAgICAgICBsZXQgZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChkZWNvZGVVUklDb21wb25lbnQobG9jYXRpb24uaGFzaC5zbGljZSgxKSkpO1xuICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICBlbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgcmVzZXQgaWYgdGhpcyBuYXZpZ2F0aW9uIG9wdGVkIG91dFxuICAgICAgaWYgKHByZXZlbnRTY3JvbGxSZXNldCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBvdGhlcndpc2UgZ28gdG8gdGhlIHRvcCBvbiBuZXcgbG9jYXRpb25zXG4gICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgMCk7XG4gICAgfSwgW2xvY2F0aW9uLCByZXN0b3JlU2Nyb2xsUG9zaXRpb24sIHByZXZlbnRTY3JvbGxSZXNldF0pO1xuICB9XG59XG4vKipcbiAqIFNldHVwIGEgY2FsbGJhY2sgdG8gYmUgZmlyZWQgb24gdGhlIHdpbmRvdydzIGBiZWZvcmV1bmxvYWRgIGV2ZW50LiBUaGlzIGlzXG4gKiB1c2VmdWwgZm9yIHNhdmluZyBzb21lIGRhdGEgdG8gYHdpbmRvdy5sb2NhbFN0b3JhZ2VgIGp1c3QgYmVmb3JlIHRoZSBwYWdlXG4gKiByZWZyZXNoZXMuXG4gKlxuICogTm90ZTogVGhlIGBjYWxsYmFja2AgYXJndW1lbnQgc2hvdWxkIGJlIGEgZnVuY3Rpb24gY3JlYXRlZCB3aXRoXG4gKiBgUmVhY3QudXNlQ2FsbGJhY2soKWAuXG4gKi9cbmZ1bmN0aW9uIHVzZUJlZm9yZVVubG9hZChjYWxsYmFjaywgb3B0aW9ucykge1xuICBsZXQge1xuICAgIGNhcHR1cmVcbiAgfSA9IG9wdGlvbnMgfHwge307XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IG9wdHMgPSBjYXB0dXJlICE9IG51bGwgPyB7XG4gICAgICBjYXB0dXJlXG4gICAgfSA6IHVuZGVmaW5lZDtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImJlZm9yZXVubG9hZFwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGNhbGxiYWNrLCBvcHRzKTtcbiAgICB9O1xuICB9LCBbY2FsbGJhY2ssIGNhcHR1cmVdKTtcbn1cbi8qKlxuICogU2V0dXAgYSBjYWxsYmFjayB0byBiZSBmaXJlZCBvbiB0aGUgd2luZG93J3MgYHBhZ2VoaWRlYCBldmVudC4gVGhpcyBpc1xuICogdXNlZnVsIGZvciBzYXZpbmcgc29tZSBkYXRhIHRvIGB3aW5kb3cubG9jYWxTdG9yYWdlYCBqdXN0IGJlZm9yZSB0aGUgcGFnZVxuICogcmVmcmVzaGVzLiAgVGhpcyBldmVudCBpcyBiZXR0ZXIgc3VwcG9ydGVkIHRoYW4gYmVmb3JldW5sb2FkIGFjcm9zcyBicm93c2Vycy5cbiAqXG4gKiBOb3RlOiBUaGUgYGNhbGxiYWNrYCBhcmd1bWVudCBzaG91bGQgYmUgYSBmdW5jdGlvbiBjcmVhdGVkIHdpdGhcbiAqIGBSZWFjdC51c2VDYWxsYmFjaygpYC5cbiAqL1xuZnVuY3Rpb24gdXNlUGFnZUhpZGUoY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgbGV0IHtcbiAgICBjYXB0dXJlXG4gIH0gPSBvcHRpb25zIHx8IHt9O1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGxldCBvcHRzID0gY2FwdHVyZSAhPSBudWxsID8ge1xuICAgICAgY2FwdHVyZVxuICAgIH0gOiB1bmRlZmluZWQ7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCBjYWxsYmFjaywgb3B0cyk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgY2FsbGJhY2ssIG9wdHMpO1xuICAgIH07XG4gIH0sIFtjYWxsYmFjaywgY2FwdHVyZV0pO1xufVxuLyoqXG4gKiBXcmFwcGVyIGFyb3VuZCB1c2VCbG9ja2VyIHRvIHNob3cgYSB3aW5kb3cuY29uZmlybSBwcm9tcHQgdG8gdXNlcnMgaW5zdGVhZFxuICogb2YgYnVpbGRpbmcgYSBjdXN0b20gVUkgd2l0aCB1c2VCbG9ja2VyLlxuICpcbiAqIFdhcm5pbmc6IFRoaXMgaGFzICphIGxvdCBvZiByb3VnaCBlZGdlcyogYW5kIGJlaGF2ZXMgdmVyeSBkaWZmZXJlbnRseSAoYW5kXG4gKiB2ZXJ5IGluY29ycmVjdGx5IGluIHNvbWUgY2FzZXMpIGFjcm9zcyBicm93c2VycyBpZiB1c2VyIGNsaWNrIGFkZGl0aW9uXG4gKiBiYWNrL2ZvcndhcmQgbmF2aWdhdGlvbnMgd2hpbGUgdGhlIGNvbmZpcm0gaXMgb3Blbi4gIFVzZSBhdCB5b3VyIG93biByaXNrLlxuICovXG5mdW5jdGlvbiB1c2VQcm9tcHQoX3JlZjEyKSB7XG4gIGxldCB7XG4gICAgd2hlbixcbiAgICBtZXNzYWdlXG4gIH0gPSBfcmVmMTI7XG4gIGxldCBibG9ja2VyID0gdXNlQmxvY2tlcih3aGVuKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYmxvY2tlci5zdGF0ZSA9PT0gXCJibG9ja2VkXCIpIHtcbiAgICAgIGxldCBwcm9jZWVkID0gd2luZG93LmNvbmZpcm0obWVzc2FnZSk7XG4gICAgICBpZiAocHJvY2VlZCkge1xuICAgICAgICAvLyBUaGlzIHRpbWVvdXQgaXMgbmVlZGVkIHRvIGF2b2lkIGEgd2VpcmQgXCJyYWNlXCIgb24gUE9QIG5hdmlnYXRpb25zXG4gICAgICAgIC8vIGJldHdlZW4gdGhlIGB3aW5kb3cuaGlzdG9yeWAgcmV2ZXJ0IG5hdmlnYXRpb24gYW5kIHRoZSByZXN1bHQgb2ZcbiAgICAgICAgLy8gYHdpbmRvdy5jb25maXJtYFxuICAgICAgICBzZXRUaW1lb3V0KGJsb2NrZXIucHJvY2VlZCwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBibG9ja2VyLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCBbYmxvY2tlciwgbWVzc2FnZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChibG9ja2VyLnN0YXRlID09PSBcImJsb2NrZWRcIiAmJiAhd2hlbikge1xuICAgICAgYmxvY2tlci5yZXNldCgpO1xuICAgIH1cbiAgfSwgW2Jsb2NrZXIsIHdoZW5dKTtcbn1cbi8qKlxuICogUmV0dXJuIGEgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIHRoZXJlIGlzIGFuIGFjdGl2ZSB2aWV3IHRyYW5zaXRpb24gdG8gdGhlXG4gKiBnaXZlbiBocmVmLiAgWW91IGNhbiB1c2UgdGhpcyB2YWx1ZSB0byByZW5kZXIgQ1NTIGNsYXNzZXMgb3Igdmlld1RyYW5zaXRpb25OYW1lXG4gKiBzdHlsZXMgb250byB5b3VyIGVsZW1lbnRzXG4gKlxuICogQHBhcmFtIGhyZWYgVGhlIGRlc3RpbmF0aW9uIGhyZWZcbiAqIEBwYXJhbSBbb3B0cy5yZWxhdGl2ZV0gUmVsYXRpdmUgcm91dGluZyB0eXBlIChcInJvdXRlXCIgfCBcInBhdGhcIilcbiAqL1xuZnVuY3Rpb24gdXNlVmlld1RyYW5zaXRpb25TdGF0ZSh0bywgb3B0cykge1xuICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIGxldCB2dENvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFZpZXdUcmFuc2l0aW9uQ29udGV4dCk7XG4gICEodnRDb250ZXh0ICE9IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gVU5TQUZFX2ludmFyaWFudChmYWxzZSwgXCJgdW5zdGFibGVfdXNlVmlld1RyYW5zaXRpb25TdGF0ZWAgbXVzdCBiZSB1c2VkIHdpdGhpbiBgcmVhY3Qtcm91dGVyLWRvbWAncyBgUm91dGVyUHJvdmlkZXJgLiAgXCIgKyBcIkRpZCB5b3UgYWNjaWRlbnRhbGx5IGltcG9ydCBgUm91dGVyUHJvdmlkZXJgIGZyb20gYHJlYWN0LXJvdXRlcmA/XCIpIDogVU5TQUZFX2ludmFyaWFudChmYWxzZSkgOiB2b2lkIDA7XG4gIGxldCB7XG4gICAgYmFzZW5hbWVcbiAgfSA9IHVzZURhdGFSb3V0ZXJDb250ZXh0KERhdGFSb3V0ZXJIb29rLnVzZVZpZXdUcmFuc2l0aW9uU3RhdGUpO1xuICBsZXQgcGF0aCA9IHVzZVJlc29sdmVkUGF0aCh0bywge1xuICAgIHJlbGF0aXZlOiBvcHRzLnJlbGF0aXZlXG4gIH0pO1xuICBpZiAoIXZ0Q29udGV4dC5pc1RyYW5zaXRpb25pbmcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IGN1cnJlbnRQYXRoID0gc3RyaXBCYXNlbmFtZSh2dENvbnRleHQuY3VycmVudExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgdnRDb250ZXh0LmN1cnJlbnRMb2NhdGlvbi5wYXRobmFtZTtcbiAgbGV0IG5leHRQYXRoID0gc3RyaXBCYXNlbmFtZSh2dENvbnRleHQubmV4dExvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgdnRDb250ZXh0Lm5leHRMb2NhdGlvbi5wYXRobmFtZTtcbiAgLy8gVHJhbnNpdGlvbiBpcyBhY3RpdmUgaWYgd2UncmUgZ29pbmcgdG8gb3IgY29taW5nIGZyb20gdGhlIGluZGljYXRlZFxuICAvLyBkZXN0aW5hdGlvbi4gIFRoaXMgZW5zdXJlcyB0aGF0IG90aGVyIFBVU0ggbmF2aWdhdGlvbnMgdGhhdCByZXZlcnNlXG4gIC8vIGFuIGluZGljYXRlZCB0cmFuc2l0aW9uIGFwcGx5LiAgSS5lLiwgb24gdGhlIGxpc3QgdmlldyB5b3UgaGF2ZTpcbiAgLy9cbiAgLy8gICA8TmF2TGluayB0bz1cIi9kZXRhaWxzLzFcIiB1bnN0YWJsZV92aWV3VHJhbnNpdGlvbj5cbiAgLy9cbiAgLy8gSWYgeW91IGNsaWNrIHRoZSBicmVhZGNydW1iIGJhY2sgdG8gdGhlIGxpc3QgdmlldzpcbiAgLy9cbiAgLy8gICA8TmF2TGluayB0bz1cIi9saXN0XCIgdW5zdGFibGVfdmlld1RyYW5zaXRpb24+XG4gIC8vXG4gIC8vIFdlIHNob3VsZCBhcHBseSB0aGUgdHJhbnNpdGlvbiBiZWNhdXNlIGl0J3MgaW5kaWNhdGVkIGFzIGFjdGl2ZSBnb2luZ1xuICAvLyBmcm9tIC9saXN0IC0+IC9kZXRhaWxzLzEgYW5kIHRoZXJlZm9yZSBzaG91bGQgYmUgYWN0aXZlIG9uIHRoZSByZXZlcnNlXG4gIC8vIChldmVuIHRob3VnaCB0aGlzIGlzbid0IHN0cmljdGx5IGEgUE9QIHJldmVyc2UpXG4gIHJldHVybiBtYXRjaFBhdGgocGF0aC5wYXRobmFtZSwgbmV4dFBhdGgpICE9IG51bGwgfHwgbWF0Y2hQYXRoKHBhdGgucGF0aG5hbWUsIGN1cnJlbnRQYXRoKSAhPSBudWxsO1xufVxuLy8jZW5kcmVnaW9uXG5cbmV4cG9ydCB7IEJyb3dzZXJSb3V0ZXIsIEZvcm0sIEhhc2hSb3V0ZXIsIExpbmssIE5hdkxpbmssIFJvdXRlclByb3ZpZGVyLCBTY3JvbGxSZXN0b3JhdGlvbiwgRmV0Y2hlcnNDb250ZXh0IGFzIFVOU0FGRV9GZXRjaGVyc0NvbnRleHQsIFZpZXdUcmFuc2l0aW9uQ29udGV4dCBhcyBVTlNBRkVfVmlld1RyYW5zaXRpb25Db250ZXh0LCB1c2VTY3JvbGxSZXN0b3JhdGlvbiBhcyBVTlNBRkVfdXNlU2Nyb2xsUmVzdG9yYXRpb24sIGNyZWF0ZUJyb3dzZXJSb3V0ZXIsIGNyZWF0ZUhhc2hSb3V0ZXIsIGNyZWF0ZVNlYXJjaFBhcmFtcywgSGlzdG9yeVJvdXRlciBhcyB1bnN0YWJsZV9IaXN0b3J5Um91dGVyLCB1c2VQcm9tcHQgYXMgdW5zdGFibGVfdXNlUHJvbXB0LCB1c2VWaWV3VHJhbnNpdGlvblN0YXRlIGFzIHVuc3RhYmxlX3VzZVZpZXdUcmFuc2l0aW9uU3RhdGUsIHVzZUJlZm9yZVVubG9hZCwgdXNlRmV0Y2hlciwgdXNlRmV0Y2hlcnMsIHVzZUZvcm1BY3Rpb24sIHVzZUxpbmtDbGlja0hhbmRsZXIsIHVzZVNlYXJjaFBhcmFtcywgdXNlU3VibWl0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIlJlYWN0RE9NIiwiVU5TQUZFX21hcFJvdXRlUHJvcGVydGllcyIsIlVOU0FGRV9EYXRhUm91dGVyQ29udGV4dCIsIlVOU0FGRV9EYXRhUm91dGVyU3RhdGVDb250ZXh0IiwiUm91dGVyIiwiVU5TQUZFX3VzZVJvdXRlc0ltcGwiLCJVTlNBRkVfTmF2aWdhdGlvbkNvbnRleHQiLCJ1c2VIcmVmIiwidXNlUmVzb2x2ZWRQYXRoIiwidXNlTG9jYXRpb24iLCJ1c2VOYXZpZ2F0ZSIsImNyZWF0ZVBhdGgiLCJVTlNBRkVfdXNlUm91dGVJZCIsIlVOU0FGRV9Sb3V0ZUNvbnRleHQiLCJ1c2VNYXRjaGVzIiwidXNlTmF2aWdhdGlvbiIsInVzZUJsb2NrZXIiLCJBYm9ydGVkRGVmZXJyZWRFcnJvciIsIkF3YWl0IiwiTWVtb3J5Um91dGVyIiwiTmF2aWdhdGUiLCJOYXZpZ2F0aW9uVHlwZSIsIk91dGxldCIsIlJvdXRlIiwiUm91dGVzIiwiVU5TQUZFX0xvY2F0aW9uQ29udGV4dCIsImNyZWF0ZU1lbW9yeVJvdXRlciIsImNyZWF0ZVJvdXRlc0Zyb21DaGlsZHJlbiIsImNyZWF0ZVJvdXRlc0Zyb21FbGVtZW50cyIsImRlZmVyIiwiZ2VuZXJhdGVQYXRoIiwiaXNSb3V0ZUVycm9yUmVzcG9uc2UiLCJqc29uIiwibWF0Y2hQYXRoIiwibWF0Y2hSb3V0ZXMiLCJwYXJzZVBhdGgiLCJyZWRpcmVjdCIsInJlZGlyZWN0RG9jdW1lbnQiLCJyZW5kZXJNYXRjaGVzIiwicmVzb2x2ZVBhdGgiLCJ1c2VBY3Rpb25EYXRhIiwidXNlQXN5bmNFcnJvciIsInVzZUFzeW5jVmFsdWUiLCJ1c2VJblJvdXRlckNvbnRleHQiLCJ1c2VMb2FkZXJEYXRhIiwidXNlTWF0Y2giLCJ1c2VOYXZpZ2F0aW9uVHlwZSIsInVzZU91dGxldCIsInVzZU91dGxldENvbnRleHQiLCJ1c2VQYXJhbXMiLCJ1c2VSZXZhbGlkYXRvciIsInVzZVJvdXRlRXJyb3IiLCJ1c2VSb3V0ZUxvYWRlckRhdGEiLCJ1c2VSb3V0ZXMiLCJzdHJpcEJhc2VuYW1lIiwiVU5TQUZFX3dhcm5pbmciLCJjcmVhdGVSb3V0ZXIiLCJjcmVhdGVCcm93c2VySGlzdG9yeSIsImNyZWF0ZUhhc2hIaXN0b3J5IiwiVU5TQUZFX0Vycm9yUmVzcG9uc2VJbXBsIiwiVU5TQUZFX2ludmFyaWFudCIsImpvaW5QYXRocyIsIklETEVfRkVUQ0hFUiIsIl9leHRlbmRzIiwiT2JqZWN0IiwiYXNzaWduIiwiYmluZCIsInRhcmdldCIsImkiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJzb3VyY2UiLCJrZXkiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIiwiZXhjbHVkZWQiLCJzb3VyY2VLZXlzIiwia2V5cyIsImluZGV4T2YiLCJkZWZhdWx0TWV0aG9kIiwiZGVmYXVsdEVuY1R5cGUiLCJpc0h0bWxFbGVtZW50Iiwib2JqZWN0IiwidGFnTmFtZSIsImlzQnV0dG9uRWxlbWVudCIsInRvTG93ZXJDYXNlIiwiaXNGb3JtRWxlbWVudCIsImlzSW5wdXRFbGVtZW50IiwiaXNNb2RpZmllZEV2ZW50IiwiZXZlbnQiLCJtZXRhS2V5IiwiYWx0S2V5IiwiY3RybEtleSIsInNoaWZ0S2V5Iiwic2hvdWxkUHJvY2Vzc0xpbmtDbGljayIsImJ1dHRvbiIsImNyZWF0ZVNlYXJjaFBhcmFtcyIsImluaXQiLCJVUkxTZWFyY2hQYXJhbXMiLCJBcnJheSIsImlzQXJyYXkiLCJyZWR1Y2UiLCJtZW1vIiwidmFsdWUiLCJjb25jYXQiLCJtYXAiLCJ2IiwiZ2V0U2VhcmNoUGFyYW1zRm9yTG9jYXRpb24iLCJsb2NhdGlvblNlYXJjaCIsImRlZmF1bHRTZWFyY2hQYXJhbXMiLCJzZWFyY2hQYXJhbXMiLCJmb3JFYWNoIiwiXyIsImhhcyIsImdldEFsbCIsImFwcGVuZCIsIl9mb3JtRGF0YVN1cHBvcnRzU3VibWl0dGVyIiwiaXNGb3JtRGF0YVN1Ym1pdHRlclN1cHBvcnRlZCIsIkZvcm1EYXRhIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiZSIsInN1cHBvcnRlZEZvcm1FbmNUeXBlcyIsIlNldCIsImdldEZvcm1FbmNUeXBlIiwiZW5jVHlwZSIsImdldEZvcm1TdWJtaXNzaW9uSW5mbyIsImJhc2VuYW1lIiwibWV0aG9kIiwiYWN0aW9uIiwiZm9ybURhdGEiLCJib2R5IiwiYXR0ciIsImdldEF0dHJpYnV0ZSIsInR5cGUiLCJmb3JtIiwiRXJyb3IiLCJuYW1lIiwicHJlZml4IiwidW5kZWZpbmVkIiwiX2V4Y2x1ZGVkIiwiX2V4Y2x1ZGVkMiIsIl9leGNsdWRlZDMiLCJjcmVhdGVCcm93c2VyUm91dGVyIiwicm91dGVzIiwib3B0cyIsImZ1dHVyZSIsInY3X3ByZXBlbmRCYXNlbmFtZSIsImhpc3RvcnkiLCJ3aW5kb3ciLCJoeWRyYXRpb25EYXRhIiwicGFyc2VIeWRyYXRpb25EYXRhIiwibWFwUm91dGVQcm9wZXJ0aWVzIiwiaW5pdGlhbGl6ZSIsImNyZWF0ZUhhc2hSb3V0ZXIiLCJfd2luZG93Iiwic3RhdGUiLCJfX3N0YXRpY1JvdXRlckh5ZHJhdGlvbkRhdGEiLCJlcnJvcnMiLCJkZXNlcmlhbGl6ZUVycm9ycyIsImVudHJpZXMiLCJzZXJpYWxpemVkIiwidmFsIiwiX190eXBlIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImRhdGEiLCJpbnRlcm5hbCIsIl9fc3ViVHlwZSIsIkVycm9yQ29uc3RydWN0b3IiLCJlcnJvciIsIm1lc3NhZ2UiLCJzdGFjayIsIlZpZXdUcmFuc2l0aW9uQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJpc1RyYW5zaXRpb25pbmciLCJwcm9jZXNzIiwiZGlzcGxheU5hbWUiLCJGZXRjaGVyc0NvbnRleHQiLCJNYXAiLCJTVEFSVF9UUkFOU0lUSU9OIiwic3RhcnRUcmFuc2l0aW9uSW1wbCIsIkZMVVNIX1NZTkMiLCJmbHVzaFN5bmNJbXBsIiwic3RhcnRUcmFuc2l0aW9uU2FmZSIsImNiIiwiZmx1c2hTeW5jU2FmZSIsIkRlZmVycmVkIiwiY29uc3RydWN0b3IiLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZWFzb24iLCJSb3V0ZXJQcm92aWRlciIsIl9yZWYiLCJmYWxsYmFja0VsZW1lbnQiLCJyb3V0ZXIiLCJzZXRTdGF0ZUltcGwiLCJ1c2VTdGF0ZSIsInBlbmRpbmdTdGF0ZSIsInNldFBlbmRpbmdTdGF0ZSIsInZ0Q29udGV4dCIsInNldFZ0Q29udGV4dCIsInJlbmRlckRmZCIsInNldFJlbmRlckRmZCIsInRyYW5zaXRpb24iLCJzZXRUcmFuc2l0aW9uIiwiaW50ZXJydXB0aW9uIiwic2V0SW50ZXJydXB0aW9uIiwiZmV0Y2hlckRhdGEiLCJ1c2VSZWYiLCJ2N19zdGFydFRyYW5zaXRpb24iLCJvcHRJblN0YXJ0VHJhbnNpdGlvbiIsInVzZUNhbGxiYWNrIiwic2V0U3RhdGUiLCJuZXdTdGF0ZSIsIl9yZWYyIiwiZGVsZXRlZEZldGNoZXJzIiwidW5zdGFibGVfZmx1c2hTeW5jIiwiZmx1c2hTeW5jIiwidW5zdGFibGVfdmlld1RyYW5zaXRpb25PcHRzIiwidmlld1RyYW5zaXRpb25PcHRzIiwiY3VycmVudCIsImRlbGV0ZSIsImZldGNoZXJzIiwiZmV0Y2hlciIsInNldCIsImlzVmlld1RyYW5zaXRpb25VbmF2YWlsYWJsZSIsInN0YXJ0Vmlld1RyYW5zaXRpb24iLCJza2lwVHJhbnNpdGlvbiIsImN1cnJlbnRMb2NhdGlvbiIsIm5leHRMb2NhdGlvbiIsInQiLCJmaW5pc2hlZCIsImZpbmFsbHkiLCJ1c2VMYXlvdXRFZmZlY3QiLCJzdWJzY3JpYmUiLCJ1c2VFZmZlY3QiLCJyZW5kZXJQcm9taXNlIiwibG9jYXRpb24iLCJuYXZpZ2F0b3IiLCJ1c2VNZW1vIiwiY3JlYXRlSHJlZiIsImVuY29kZUxvY2F0aW9uIiwiZ28iLCJuIiwibmF2aWdhdGUiLCJwdXNoIiwidG8iLCJwcmV2ZW50U2Nyb2xsUmVzZXQiLCJyZXBsYWNlIiwiZGF0YVJvdXRlckNvbnRleHQiLCJzdGF0aWMiLCJGcmFnbWVudCIsIlByb3ZpZGVyIiwibmF2aWdhdGlvblR5cGUiLCJoaXN0b3J5QWN0aW9uIiwiaW5pdGlhbGl6ZWQiLCJEYXRhUm91dGVzIiwiX3JlZjMiLCJCcm93c2VyUm91dGVyIiwiX3JlZjQiLCJjaGlsZHJlbiIsImhpc3RvcnlSZWYiLCJ2NUNvbXBhdCIsImxpc3RlbiIsIkhhc2hSb3V0ZXIiLCJfcmVmNSIsIkhpc3RvcnlSb3V0ZXIiLCJfcmVmNiIsImlzQnJvd3NlciIsIkFCU09MVVRFX1VSTF9SRUdFWCIsIkxpbmsiLCJmb3J3YXJkUmVmIiwiTGlua1dpdGhSZWYiLCJfcmVmNyIsInJlZiIsIm9uQ2xpY2siLCJyZWxhdGl2ZSIsInJlbG9hZERvY3VtZW50IiwidW5zdGFibGVfdmlld1RyYW5zaXRpb24iLCJyZXN0IiwidXNlQ29udGV4dCIsImFic29sdXRlSHJlZiIsImlzRXh0ZXJuYWwiLCJ0ZXN0IiwiY3VycmVudFVybCIsIlVSTCIsImhyZWYiLCJ0YXJnZXRVcmwiLCJzdGFydHNXaXRoIiwicHJvdG9jb2wiLCJwYXRoIiwicGF0aG5hbWUiLCJvcmlnaW4iLCJzZWFyY2giLCJoYXNoIiwiaW50ZXJuYWxPbkNsaWNrIiwidXNlTGlua0NsaWNrSGFuZGxlciIsImhhbmRsZUNsaWNrIiwiZGVmYXVsdFByZXZlbnRlZCIsIk5hdkxpbmsiLCJOYXZMaW5rV2l0aFJlZiIsIl9yZWY4IiwiYXJpYUN1cnJlbnRQcm9wIiwiY2FzZVNlbnNpdGl2ZSIsImNsYXNzTmFtZSIsImNsYXNzTmFtZVByb3AiLCJlbmQiLCJzdHlsZSIsInN0eWxlUHJvcCIsInJvdXRlclN0YXRlIiwidXNlVmlld1RyYW5zaXRpb25TdGF0ZSIsInRvUGF0aG5hbWUiLCJsb2NhdGlvblBhdGhuYW1lIiwibmV4dExvY2F0aW9uUGF0aG5hbWUiLCJuYXZpZ2F0aW9uIiwiZW5kU2xhc2hQb3NpdGlvbiIsImVuZHNXaXRoIiwiaXNBY3RpdmUiLCJjaGFyQXQiLCJpc1BlbmRpbmciLCJyZW5kZXJQcm9wcyIsImFyaWFDdXJyZW50IiwiZmlsdGVyIiwiQm9vbGVhbiIsImpvaW4iLCJGb3JtIiwiX3JlZjkiLCJmb3J3YXJkZWRSZWYiLCJmZXRjaGVyS2V5Iiwib25TdWJtaXQiLCJwcm9wcyIsInN1Ym1pdCIsInVzZVN1Ym1pdCIsImZvcm1BY3Rpb24iLCJ1c2VGb3JtQWN0aW9uIiwiZm9ybU1ldGhvZCIsInN1Ym1pdEhhbmRsZXIiLCJwcmV2ZW50RGVmYXVsdCIsInN1Ym1pdHRlciIsIm5hdGl2ZUV2ZW50Iiwic3VibWl0TWV0aG9kIiwiY3VycmVudFRhcmdldCIsIlNjcm9sbFJlc3RvcmF0aW9uIiwiX3JlZjEwIiwiZ2V0S2V5Iiwic3RvcmFnZUtleSIsInVzZVNjcm9sbFJlc3RvcmF0aW9uIiwiRGF0YVJvdXRlckhvb2siLCJEYXRhUm91dGVyU3RhdGVIb29rIiwiZ2V0RGF0YVJvdXRlckNvbnNvbGVFcnJvciIsImhvb2tOYW1lIiwidXNlRGF0YVJvdXRlckNvbnRleHQiLCJjdHgiLCJ1c2VEYXRhUm91dGVyU3RhdGUiLCJfdGVtcCIsInJlcGxhY2VQcm9wIiwidXNlU2VhcmNoUGFyYW1zIiwiZGVmYXVsdEluaXQiLCJkZWZhdWx0U2VhcmNoUGFyYW1zUmVmIiwiaGFzU2V0U2VhcmNoUGFyYW1zUmVmIiwic2V0U2VhcmNoUGFyYW1zIiwibmV4dEluaXQiLCJuYXZpZ2F0ZU9wdGlvbnMiLCJuZXdTZWFyY2hQYXJhbXMiLCJ2YWxpZGF0ZUNsaWVudFNpZGVTdWJtaXNzaW9uIiwiZmV0Y2hlcklkIiwiZ2V0VW5pcXVlRmV0Y2hlcklkIiwiU3RyaW5nIiwiVXNlU3VibWl0IiwiY3VycmVudFJvdXRlSWQiLCJvcHRpb25zIiwiZmV0Y2giLCJmb3JtRW5jVHlwZSIsImZyb21Sb3V0ZUlkIiwiX3RlbXAyIiwicm91dGVDb250ZXh0IiwibWF0Y2giLCJtYXRjaGVzIiwic2xpY2UiLCJwYXJhbXMiLCJnZXQiLCJ0b1N0cmluZyIsInJvdXRlIiwiaW5kZXgiLCJ1c2VGZXRjaGVyIiwiX3RlbXAzIiwiX3JvdXRlJG1hdGNoZXMiLCJVc2VGZXRjaGVyIiwicm91dGVJZCIsImlkIiwic2V0RmV0Y2hlcktleSIsImdldEZldGNoZXIiLCJkZWxldGVGZXRjaGVyIiwibG9hZCIsInN1Ym1pdEltcGwiLCJGZXRjaGVyRm9ybSIsImZldGNoZXJXaXRoQ29tcG9uZW50cyIsInVzZUZldGNoZXJzIiwiVXNlRmV0Y2hlcnMiLCJmcm9tIiwiX3JlZjExIiwiU0NST0xMX1JFU1RPUkFUSU9OX1NUT1JBR0VfS0VZIiwic2F2ZWRTY3JvbGxQb3NpdGlvbnMiLCJfdGVtcDQiLCJVc2VTY3JvbGxSZXN0b3JhdGlvbiIsInJlc3RvcmVTY3JvbGxQb3NpdGlvbiIsInNjcm9sbFJlc3RvcmF0aW9uIiwidXNlUGFnZUhpZGUiLCJzY3JvbGxZIiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwiSlNPTiIsInN0cmluZ2lmeSIsInNlc3Npb25Qb3NpdGlvbnMiLCJnZXRJdGVtIiwicGFyc2UiLCJnZXRLZXlXaXRob3V0QmFzZW5hbWUiLCJkaXNhYmxlU2Nyb2xsUmVzdG9yYXRpb24iLCJlbmFibGVTY3JvbGxSZXN0b3JhdGlvbiIsInNjcm9sbFRvIiwiZWwiLCJnZXRFbGVtZW50QnlJZCIsImRlY29kZVVSSUNvbXBvbmVudCIsInNjcm9sbEludG9WaWV3IiwidXNlQmVmb3JlVW5sb2FkIiwiY2FsbGJhY2siLCJjYXB0dXJlIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJ1c2VQcm9tcHQiLCJfcmVmMTIiLCJ3aGVuIiwiYmxvY2tlciIsInByb2NlZWQiLCJjb25maXJtIiwic2V0VGltZW91dCIsInJlc2V0IiwiY3VycmVudFBhdGgiLCJuZXh0UGF0aCIsIlVOU0FGRV9GZXRjaGVyc0NvbnRleHQiLCJVTlNBRkVfVmlld1RyYW5zaXRpb25Db250ZXh0IiwiVU5TQUZFX3VzZVNjcm9sbFJlc3RvcmF0aW9uIiwidW5zdGFibGVfSGlzdG9yeVJvdXRlciIsInVuc3RhYmxlX3VzZVByb21wdCIsInVuc3RhYmxlX3VzZVZpZXdUcmFuc2l0aW9uU3RhdGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-router-dom/dist/index.js\n");

/***/ })

};
;