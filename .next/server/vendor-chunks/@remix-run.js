"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@remix-run";
exports.ids = ["vendor-chunks/@remix-run"];
exports.modules = {

/***/ "(ssr)/./node_modules/@remix-run/router/dist/router.js":
/*!*******************************************************!*\
  !*** ./node_modules/@remix-run/router/dist/router.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbortedDeferredError: () => (/* binding */ AbortedDeferredError),\n/* harmony export */   Action: () => (/* binding */ Action),\n/* harmony export */   IDLE_BLOCKER: () => (/* binding */ IDLE_BLOCKER),\n/* harmony export */   IDLE_FETCHER: () => (/* binding */ IDLE_FETCHER),\n/* harmony export */   IDLE_NAVIGATION: () => (/* binding */ IDLE_NAVIGATION),\n/* harmony export */   UNSAFE_DEFERRED_SYMBOL: () => (/* binding */ UNSAFE_DEFERRED_SYMBOL),\n/* harmony export */   UNSAFE_DeferredData: () => (/* binding */ DeferredData),\n/* harmony export */   UNSAFE_ErrorResponseImpl: () => (/* binding */ ErrorResponseImpl),\n/* harmony export */   UNSAFE_convertRouteMatchToUiMatch: () => (/* binding */ convertRouteMatchToUiMatch),\n/* harmony export */   UNSAFE_convertRoutesToDataRoutes: () => (/* binding */ convertRoutesToDataRoutes),\n/* harmony export */   UNSAFE_getPathContributingMatches: () => (/* binding */ getPathContributingMatches),\n/* harmony export */   UNSAFE_invariant: () => (/* binding */ invariant),\n/* harmony export */   UNSAFE_warning: () => (/* binding */ warning),\n/* harmony export */   createBrowserHistory: () => (/* binding */ createBrowserHistory),\n/* harmony export */   createHashHistory: () => (/* binding */ createHashHistory),\n/* harmony export */   createMemoryHistory: () => (/* binding */ createMemoryHistory),\n/* harmony export */   createPath: () => (/* binding */ createPath),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   createStaticHandler: () => (/* binding */ createStaticHandler),\n/* harmony export */   defer: () => (/* binding */ defer),\n/* harmony export */   generatePath: () => (/* binding */ generatePath),\n/* harmony export */   getStaticContextFromError: () => (/* binding */ getStaticContextFromError),\n/* harmony export */   getToPathname: () => (/* binding */ getToPathname),\n/* harmony export */   isDeferredData: () => (/* binding */ isDeferredData),\n/* harmony export */   isRouteErrorResponse: () => (/* binding */ isRouteErrorResponse),\n/* harmony export */   joinPaths: () => (/* binding */ joinPaths),\n/* harmony export */   json: () => (/* binding */ json),\n/* harmony export */   matchPath: () => (/* binding */ matchPath),\n/* harmony export */   matchRoutes: () => (/* binding */ matchRoutes),\n/* harmony export */   normalizePathname: () => (/* binding */ normalizePathname),\n/* harmony export */   parsePath: () => (/* binding */ parsePath),\n/* harmony export */   redirect: () => (/* binding */ redirect),\n/* harmony export */   redirectDocument: () => (/* binding */ redirectDocument),\n/* harmony export */   resolvePath: () => (/* binding */ resolvePath),\n/* harmony export */   resolveTo: () => (/* binding */ resolveTo),\n/* harmony export */   stripBasename: () => (/* binding */ stripBasename)\n/* harmony export */ });\n/**\n * @remix-run/router v1.13.1\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */ function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Actions represent the type of change to a location value.\n */ var Action;\n(function(Action) {\n    /**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */ Action[\"Pop\"] = \"POP\";\n    /**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */ Action[\"Push\"] = \"PUSH\";\n    /**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */ Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\nconst PopStateEventType = \"popstate\";\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */ function createMemoryHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    let { initialEntries = [\n        \"/\"\n    ], initialIndex, v5Compat = false } = options;\n    let entries; // Declare so we can access from createMemoryLocation\n    entries = initialEntries.map((entry, index)=>createMemoryLocation(entry, typeof entry === \"string\" ? null : entry.state, index === 0 ? \"default\" : undefined));\n    let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n    let action = Action.Pop;\n    let listener = null;\n    function clampIndex(n) {\n        return Math.min(Math.max(n, 0), entries.length - 1);\n    }\n    function getCurrentLocation() {\n        return entries[index];\n    }\n    function createMemoryLocation(to, state, key) {\n        if (state === void 0) {\n            state = null;\n        }\n        let location = createLocation(entries ? getCurrentLocation().pathname : \"/\", to, state, key);\n        warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in memory history: \" + JSON.stringify(to));\n        return location;\n    }\n    function createHref(to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    let history = {\n        get index () {\n            return index;\n        },\n        get action () {\n            return action;\n        },\n        get location () {\n            return getCurrentLocation();\n        },\n        createHref,\n        createURL (to) {\n            return new URL(createHref(to), \"http://localhost\");\n        },\n        encodeLocation (to) {\n            let path = typeof to === \"string\" ? parsePath(to) : to;\n            return {\n                pathname: path.pathname || \"\",\n                search: path.search || \"\",\n                hash: path.hash || \"\"\n            };\n        },\n        push (to, state) {\n            action = Action.Push;\n            let nextLocation = createMemoryLocation(to, state);\n            index += 1;\n            entries.splice(index, entries.length, nextLocation);\n            if (v5Compat && listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta: 1\n                });\n            }\n        },\n        replace (to, state) {\n            action = Action.Replace;\n            let nextLocation = createMemoryLocation(to, state);\n            entries[index] = nextLocation;\n            if (v5Compat && listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta: 0\n                });\n            }\n        },\n        go (delta) {\n            action = Action.Pop;\n            let nextIndex = clampIndex(index + delta);\n            let nextLocation = entries[nextIndex];\n            index = nextIndex;\n            if (listener) {\n                listener({\n                    action,\n                    location: nextLocation,\n                    delta\n                });\n            }\n        },\n        listen (fn) {\n            listener = fn;\n            return ()=>{\n                listener = null;\n            };\n        }\n    };\n    return history;\n}\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */ function createBrowserHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    function createBrowserLocation(window1, globalHistory) {\n        let { pathname, search, hash } = window1.location;\n        return createLocation(\"\", {\n            pathname,\n            search,\n            hash\n        }, // state defaults to `null` because `window.history.state` does\n        globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n    }\n    function createBrowserHref(window1, to) {\n        return typeof to === \"string\" ? to : createPath(to);\n    }\n    return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */ function createHashHistory(options) {\n    if (options === void 0) {\n        options = {};\n    }\n    function createHashLocation(window1, globalHistory) {\n        let { pathname = \"/\", search = \"\", hash = \"\" } = parsePath(window1.location.hash.substr(1));\n        // Hash URL should always have a leading / just like window.location.pathname\n        // does, so if an app ends up at a route like /#something then we add a\n        // leading slash so all of our path-matching behaves the same as if it would\n        // in a browser router.  This is particularly important when there exists a\n        // root splat route (<Route path=\"*\">) since that matches internally against\n        // \"/*\" and we'd expect /#something to 404 in a hash router app.\n        if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n            pathname = \"/\" + pathname;\n        }\n        return createLocation(\"\", {\n            pathname,\n            search,\n            hash\n        }, // state defaults to `null` because `window.history.state` does\n        globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n    }\n    function createHashHref(window1, to) {\n        let base = window1.document.querySelector(\"base\");\n        let href = \"\";\n        if (base && base.getAttribute(\"href\")) {\n            let url = window1.location.href;\n            let hashIndex = url.indexOf(\"#\");\n            href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n        }\n        return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n    }\n    function validateHashLocation(location, to) {\n        warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\");\n    }\n    return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n}\nfunction invariant(value, message) {\n    if (value === false || value === null || typeof value === \"undefined\") {\n        throw new Error(message);\n    }\n}\nfunction warning(cond, message) {\n    if (!cond) {\n        // eslint-disable-next-line no-console\n        if (typeof console !== \"undefined\") console.warn(message);\n        try {\n            // Welcome to debugging history!\n            //\n            // This error is thrown as a convenience, so you can more easily\n            // find the source for a warning that appears in the console by\n            // enabling \"pause on exceptions\" in your JavaScript debugger.\n            throw new Error(message);\n        // eslint-disable-next-line no-empty\n        } catch (e) {}\n    }\n}\nfunction createKey() {\n    return Math.random().toString(36).substr(2, 8);\n}\n/**\n * For browser-based histories, we combine the state and key into an object\n */ function getHistoryState(location, index) {\n    return {\n        usr: location.state,\n        key: location.key,\n        idx: index\n    };\n}\n/**\n * Creates a Location object with a unique key from the given Path\n */ function createLocation(current, to, state, key) {\n    if (state === void 0) {\n        state = null;\n    }\n    let location = _extends({\n        pathname: typeof current === \"string\" ? current : current.pathname,\n        search: \"\",\n        hash: \"\"\n    }, typeof to === \"string\" ? parsePath(to) : to, {\n        state,\n        // TODO: This could be cleaned up.  push/replace should probably just take\n        // full Locations now and avoid the need to run through this flow at all\n        // But that's a pretty big refactor to the current test suite so going to\n        // keep as is for the time being and just let any incoming keys take precedence\n        key: to && to.key || key || createKey()\n    });\n    return location;\n}\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */ function createPath(_ref) {\n    let { pathname = \"/\", search = \"\", hash = \"\" } = _ref;\n    if (search && search !== \"?\") pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n    if (hash && hash !== \"#\") pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n    return pathname;\n}\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */ function parsePath(path) {\n    let parsedPath = {};\n    if (path) {\n        let hashIndex = path.indexOf(\"#\");\n        if (hashIndex >= 0) {\n            parsedPath.hash = path.substr(hashIndex);\n            path = path.substr(0, hashIndex);\n        }\n        let searchIndex = path.indexOf(\"?\");\n        if (searchIndex >= 0) {\n            parsedPath.search = path.substr(searchIndex);\n            path = path.substr(0, searchIndex);\n        }\n        if (path) {\n            parsedPath.pathname = path;\n        }\n    }\n    return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref, validateLocation, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    let { window: window1 = document.defaultView, v5Compat = false } = options;\n    let globalHistory = window1.history;\n    let action = Action.Pop;\n    let listener = null;\n    let index = getIndex();\n    // Index should only be null when we initialize. If not, it's because the\n    // user called history.pushState or history.replaceState directly, in which\n    // case we should log a warning as it will result in bugs.\n    if (index == null) {\n        index = 0;\n        globalHistory.replaceState(_extends({}, globalHistory.state, {\n            idx: index\n        }), \"\");\n    }\n    function getIndex() {\n        let state = globalHistory.state || {\n            idx: null\n        };\n        return state.idx;\n    }\n    function handlePop() {\n        action = Action.Pop;\n        let nextIndex = getIndex();\n        let delta = nextIndex == null ? null : nextIndex - index;\n        index = nextIndex;\n        if (listener) {\n            listener({\n                action,\n                location: history.location,\n                delta\n            });\n        }\n    }\n    function push(to, state) {\n        action = Action.Push;\n        let location = createLocation(history.location, to, state);\n        if (validateLocation) validateLocation(location, to);\n        index = getIndex() + 1;\n        let historyState = getHistoryState(location, index);\n        let url = history.createHref(location);\n        // try...catch because iOS limits us to 100 pushState calls :/\n        try {\n            globalHistory.pushState(historyState, \"\", url);\n        } catch (error) {\n            // If the exception is because `state` can't be serialized, let that throw\n            // outwards just like a replace call would so the dev knows the cause\n            // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n            // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n            if (error instanceof DOMException && error.name === \"DataCloneError\") {\n                throw error;\n            }\n            // They are going to lose state here, but there is no real\n            // way to warn them about it since the page will refresh...\n            window1.location.assign(url);\n        }\n        if (v5Compat && listener) {\n            listener({\n                action,\n                location: history.location,\n                delta: 1\n            });\n        }\n    }\n    function replace(to, state) {\n        action = Action.Replace;\n        let location = createLocation(history.location, to, state);\n        if (validateLocation) validateLocation(location, to);\n        index = getIndex();\n        let historyState = getHistoryState(location, index);\n        let url = history.createHref(location);\n        globalHistory.replaceState(historyState, \"\", url);\n        if (v5Compat && listener) {\n            listener({\n                action,\n                location: history.location,\n                delta: 0\n            });\n        }\n    }\n    function createURL(to) {\n        // window.location.origin is \"null\" (the literal string value) in Firefox\n        // under certain conditions, notably when serving from a local HTML file\n        // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n        let base = window1.location.origin !== \"null\" ? window1.location.origin : window1.location.href;\n        let href = typeof to === \"string\" ? to : createPath(to);\n        invariant(base, \"No window.location.(origin|href) available to create URL for href: \" + href);\n        return new URL(href, base);\n    }\n    let history = {\n        get action () {\n            return action;\n        },\n        get location () {\n            return getLocation(window1, globalHistory);\n        },\n        listen (fn) {\n            if (listener) {\n                throw new Error(\"A history only accepts one active listener\");\n            }\n            window1.addEventListener(PopStateEventType, handlePop);\n            listener = fn;\n            return ()=>{\n                window1.removeEventListener(PopStateEventType, handlePop);\n                listener = null;\n            };\n        },\n        createHref (to) {\n            return createHref(window1, to);\n        },\n        createURL,\n        encodeLocation (to) {\n            // Encode a Location the same way window.location would\n            let url = createURL(to);\n            return {\n                pathname: url.pathname,\n                search: url.search,\n                hash: url.hash\n            };\n        },\n        push,\n        replace,\n        go (n) {\n            return globalHistory.go(n);\n        }\n    };\n    return history;\n}\n//#endregion\nvar ResultType;\n(function(ResultType) {\n    ResultType[\"data\"] = \"data\";\n    ResultType[\"deferred\"] = \"deferred\";\n    ResultType[\"redirect\"] = \"redirect\";\n    ResultType[\"error\"] = \"error\";\n})(ResultType || (ResultType = {}));\nconst immutableRouteKeys = new Set([\n    \"lazy\",\n    \"caseSensitive\",\n    \"path\",\n    \"id\",\n    \"index\",\n    \"children\"\n]);\nfunction isIndexRoute(route) {\n    return route.index === true;\n}\n// Walk the route tree generating unique IDs where necessary, so we are working\n// solely with AgnosticDataRouteObject's within the Router\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties, parentPath, manifest) {\n    if (parentPath === void 0) {\n        parentPath = [];\n    }\n    if (manifest === void 0) {\n        manifest = {};\n    }\n    return routes.map((route, index)=>{\n        let treePath = [\n            ...parentPath,\n            index\n        ];\n        let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n        invariant(route.index !== true || !route.children, \"Cannot specify children on an index route\");\n        invariant(!manifest[id], 'Found a route id collision on id \"' + id + '\".  Route ' + \"id's must be globally unique within Data Router usages\");\n        if (isIndexRoute(route)) {\n            let indexRoute = _extends({}, route, mapRouteProperties(route), {\n                id\n            });\n            manifest[id] = indexRoute;\n            return indexRoute;\n        } else {\n            let pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {\n                id,\n                children: undefined\n            });\n            manifest[id] = pathOrLayoutRoute;\n            if (route.children) {\n                pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest);\n            }\n            return pathOrLayoutRoute;\n        }\n    });\n}\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */ function matchRoutes(routes, locationArg, basename) {\n    if (basename === void 0) {\n        basename = \"/\";\n    }\n    let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n    let pathname = stripBasename(location.pathname || \"/\", basename);\n    if (pathname == null) {\n        return null;\n    }\n    let branches = flattenRoutes(routes);\n    rankRouteBranches(branches);\n    let matches = null;\n    for(let i = 0; matches == null && i < branches.length; ++i){\n        matches = matchRouteBranch(branches[i], // Incoming pathnames are generally encoded from either window.location\n        // or from router.navigate, but we want to match against the unencoded\n        // paths in the route definitions.  Memory router locations won't be\n        // encoded here but there also shouldn't be anything to decode so this\n        // should be a safe operation.  This avoids needing matchRoutes to be\n        // history-aware.\n        safelyDecodeURI(pathname));\n    }\n    return matches;\n}\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n    let { route, pathname, params } = match;\n    return {\n        id: route.id,\n        pathname,\n        params,\n        data: loaderData[route.id],\n        handle: route.handle\n    };\n}\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\n    if (branches === void 0) {\n        branches = [];\n    }\n    if (parentsMeta === void 0) {\n        parentsMeta = [];\n    }\n    if (parentPath === void 0) {\n        parentPath = \"\";\n    }\n    let flattenRoute = (route, index, relativePath)=>{\n        let meta = {\n            relativePath: relativePath === undefined ? route.path || \"\" : relativePath,\n            caseSensitive: route.caseSensitive === true,\n            childrenIndex: index,\n            route\n        };\n        if (meta.relativePath.startsWith(\"/\")) {\n            invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path \"' + meta.relativePath + '\" nested under path ' + ('\"' + parentPath + '\" is not valid. An absolute child route path ') + \"must start with the combined path of all its parent routes.\");\n            meta.relativePath = meta.relativePath.slice(parentPath.length);\n        }\n        let path = joinPaths([\n            parentPath,\n            meta.relativePath\n        ]);\n        let routesMeta = parentsMeta.concat(meta);\n        // Add the children before adding this route to the array, so we traverse the\n        // route tree depth-first and child routes appear before their parents in\n        // the \"flattened\" version.\n        if (route.children && route.children.length > 0) {\n            invariant(// Our types know better, but runtime JS may not!\n            // @ts-expect-error\n            route.index !== true, \"Index routes must not have child routes. Please remove \" + ('all child routes from route path \"' + path + '\".'));\n            flattenRoutes(route.children, branches, routesMeta, path);\n        }\n        // Routes without a path shouldn't ever match by themselves unless they are\n        // index routes, so don't add them to the list of possible branches.\n        if (route.path == null && !route.index) {\n            return;\n        }\n        branches.push({\n            path,\n            score: computeScore(path, route.index),\n            routesMeta\n        });\n    };\n    routes.forEach((route, index)=>{\n        var _route$path;\n        // coarse-grain check for optional params\n        if (route.path === \"\" || !((_route$path = route.path) != null && _route$path.includes(\"?\"))) {\n            flattenRoute(route, index);\n        } else {\n            for (let exploded of explodeOptionalSegments(route.path)){\n                flattenRoute(route, index, exploded);\n            }\n        }\n    });\n    return branches;\n}\n/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */ function explodeOptionalSegments(path) {\n    let segments = path.split(\"/\");\n    if (segments.length === 0) return [];\n    let [first, ...rest] = segments;\n    // Optional path segments are denoted by a trailing `?`\n    let isOptional = first.endsWith(\"?\");\n    // Compute the corresponding required segment: `foo?` -> `foo`\n    let required = first.replace(/\\?$/, \"\");\n    if (rest.length === 0) {\n        // Intepret empty string as omitting an optional segment\n        // `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\n        return isOptional ? [\n            required,\n            \"\"\n        ] : [\n            required\n        ];\n    }\n    let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n    let result = [];\n    // All child paths with the prefix.  Do this for all children before the\n    // optional version for all children, so we get consistent ordering where the\n    // parent optional aspect is preferred as required.  Otherwise, we can get\n    // child sections interspersed where deeper optional segments are higher than\n    // parent optional segments, where for example, /:two would explode _earlier_\n    // then /:one.  By always including the parent as required _for all children_\n    // first, we avoid this issue\n    result.push(...restExploded.map((subpath)=>subpath === \"\" ? required : [\n            required,\n            subpath\n        ].join(\"/\")));\n    // Then, if this is an optional value, add all child versions without\n    if (isOptional) {\n        result.push(...restExploded);\n    }\n    // for absolute paths, ensure `/` instead of empty segment\n    return result.map((exploded)=>path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded);\n}\nfunction rankRouteBranches(branches) {\n    branches.sort((a, b)=>a.score !== b.score ? b.score - a.score // Higher score first\n         : compareIndexes(a.routesMeta.map((meta)=>meta.childrenIndex), b.routesMeta.map((meta)=>meta.childrenIndex)));\n}\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = (s)=>s === \"*\";\nfunction computeScore(path, index) {\n    let segments = path.split(\"/\");\n    let initialScore = segments.length;\n    if (segments.some(isSplat)) {\n        initialScore += splatPenalty;\n    }\n    if (index) {\n        initialScore += indexRouteValue;\n    }\n    return segments.filter((s)=>!isSplat(s)).reduce((score, segment)=>score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\n}\nfunction compareIndexes(a, b) {\n    let siblings = a.length === b.length && a.slice(0, -1).every((n, i)=>n === b[i]);\n    return siblings ? // If two routes are siblings, we should try to match the earlier sibling\n    // first. This allows people to have fine-grained control over the matching\n    // behavior by simply putting routes with identical paths in the order they\n    // want them tried.\n    a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n    // so they sort equally.\n    0;\n}\nfunction matchRouteBranch(branch, pathname) {\n    let { routesMeta } = branch;\n    let matchedParams = {};\n    let matchedPathname = \"/\";\n    let matches = [];\n    for(let i = 0; i < routesMeta.length; ++i){\n        let meta = routesMeta[i];\n        let end = i === routesMeta.length - 1;\n        let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n        let match = matchPath({\n            path: meta.relativePath,\n            caseSensitive: meta.caseSensitive,\n            end\n        }, remainingPathname);\n        if (!match) return null;\n        Object.assign(matchedParams, match.params);\n        let route = meta.route;\n        matches.push({\n            // TODO: Can this as be avoided?\n            params: matchedParams,\n            pathname: joinPaths([\n                matchedPathname,\n                match.pathname\n            ]),\n            pathnameBase: normalizePathname(joinPaths([\n                matchedPathname,\n                match.pathnameBase\n            ])),\n            route\n        });\n        if (match.pathnameBase !== \"/\") {\n            matchedPathname = joinPaths([\n                matchedPathname,\n                match.pathnameBase\n            ]);\n        }\n    }\n    return matches;\n}\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */ function generatePath(originalPath, params) {\n    if (params === void 0) {\n        params = {};\n    }\n    let path = originalPath;\n    if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n        warning(false, 'Route path \"' + path + '\" will be treated as if it were ' + ('\"' + path.replace(/\\*$/, \"/*\") + '\" because the `*` character must ') + \"always follow a `/` in the pattern. To get rid of this warning, \" + ('please change the route path to \"' + path.replace(/\\*$/, \"/*\") + '\".'));\n        path = path.replace(/\\*$/, \"/*\");\n    }\n    // ensure `/` is added at the beginning if the path is absolute\n    const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n    const stringify = (p)=>p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n    const segments = path.split(/\\/+/).map((segment, index, array)=>{\n        const isLastSegment = index === array.length - 1;\n        // only apply the splat if it's the last segment\n        if (isLastSegment && segment === \"*\") {\n            const star = \"*\";\n            // Apply the splat\n            return stringify(params[star]);\n        }\n        const keyMatch = segment.match(/^:(\\w+)(\\??)$/);\n        if (keyMatch) {\n            const [, key, optional] = keyMatch;\n            let param = params[key];\n            invariant(optional === \"?\" || param != null, 'Missing \":' + key + '\" param');\n            return stringify(param);\n        }\n        // Remove any optional markers from optional static segments\n        return segment.replace(/\\?$/g, \"\");\n    })// Remove empty segments\n    .filter((segment)=>!!segment);\n    return prefix + segments.join(\"/\");\n}\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */ function matchPath(pattern, pathname) {\n    if (typeof pattern === \"string\") {\n        pattern = {\n            path: pattern,\n            caseSensitive: false,\n            end: true\n        };\n    }\n    let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n    let match = pathname.match(matcher);\n    if (!match) return null;\n    let matchedPathname = match[0];\n    let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n    let captureGroups = match.slice(1);\n    let params = compiledParams.reduce((memo, _ref, index)=>{\n        let { paramName, isOptional } = _ref;\n        // We need to compute the pathnameBase here using the raw splat value\n        // instead of using params[\"*\"] later because it will be decoded then\n        if (paramName === \"*\") {\n            let splatValue = captureGroups[index] || \"\";\n            pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n        }\n        const value = captureGroups[index];\n        if (isOptional && !value) {\n            memo[paramName] = undefined;\n        } else {\n            memo[paramName] = safelyDecodeURIComponent(value || \"\", paramName);\n        }\n        return memo;\n    }, {});\n    return {\n        params,\n        pathname: matchedPathname,\n        pathnameBase,\n        pattern\n    };\n}\nfunction compilePath(path, caseSensitive, end) {\n    if (caseSensitive === void 0) {\n        caseSensitive = false;\n    }\n    if (end === void 0) {\n        end = true;\n    }\n    warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), 'Route path \"' + path + '\" will be treated as if it were ' + ('\"' + path.replace(/\\*$/, \"/*\") + '\" because the `*` character must ') + \"always follow a `/` in the pattern. To get rid of this warning, \" + ('please change the route path to \"' + path.replace(/\\*$/, \"/*\") + '\".'));\n    let params = [];\n    let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n    .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n    .replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n    .replace(/\\/:(\\w+)(\\?)?/g, (_, paramName, isOptional)=>{\n        params.push({\n            paramName,\n            isOptional: isOptional != null\n        });\n        return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\n    });\n    if (path.endsWith(\"*\")) {\n        params.push({\n            paramName: \"*\"\n        });\n        regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" // Already matched the initial /, just match the rest\n         : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n    } else if (end) {\n        // When matching to the end, ignore trailing slashes\n        regexpSource += \"\\\\/*$\";\n    } else if (path !== \"\" && path !== \"/\") {\n        // If our path is non-empty and contains anything beyond an initial slash,\n        // then we have _some_ form of path in our regex, so we should expect to\n        // match only if we find the end of this path segment.  Look for an optional\n        // non-captured trailing slash (to match a portion of the URL) or the end\n        // of the path (if we've matched to the end).  We used to do this with a\n        // word boundary but that gives false positives on routes like\n        // /user-preferences since `-` counts as a word boundary.\n        regexpSource += \"(?:(?=\\\\/|$))\";\n    } else ;\n    let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n    return [\n        matcher,\n        params\n    ];\n}\nfunction safelyDecodeURI(value) {\n    try {\n        return decodeURI(value);\n    } catch (error) {\n        warning(false, 'The URL path \"' + value + '\" could not be decoded because it is is a ' + \"malformed URL segment. This is probably due to a bad percent \" + (\"encoding (\" + error + \").\"));\n        return value;\n    }\n}\nfunction safelyDecodeURIComponent(value, paramName) {\n    try {\n        return decodeURIComponent(value);\n    } catch (error) {\n        warning(false, 'The value for the URL param \"' + paramName + '\" will not be decoded because' + (' the string \"' + value + '\" is a malformed URL segment. This is probably') + (\" due to a bad percent encoding (\" + error + \").\"));\n        return value;\n    }\n}\n/**\n * @private\n */ function stripBasename(pathname, basename) {\n    if (basename === \"/\") return pathname;\n    if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n        return null;\n    }\n    // We want to leave trailing slash behavior in the user's control, so if they\n    // specify a basename with a trailing slash, we should support it\n    let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n    let nextChar = pathname.charAt(startIndex);\n    if (nextChar && nextChar !== \"/\") {\n        // pathname does not start with basename/\n        return null;\n    }\n    return pathname.slice(startIndex) || \"/\";\n}\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */ function resolvePath(to, fromPathname) {\n    if (fromPathname === void 0) {\n        fromPathname = \"/\";\n    }\n    let { pathname: toPathname, search = \"\", hash = \"\" } = typeof to === \"string\" ? parsePath(to) : to;\n    let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n    return {\n        pathname,\n        search: normalizeSearch(search),\n        hash: normalizeHash(hash)\n    };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n    let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n    let relativeSegments = relativePath.split(\"/\");\n    relativeSegments.forEach((segment)=>{\n        if (segment === \"..\") {\n            // Keep the root \"\" segment so the pathname starts at /\n            if (segments.length > 1) segments.pop();\n        } else if (segment !== \".\") {\n            segments.push(segment);\n        }\n    });\n    return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n    return \"Cannot include a '\" + char + \"' character in a manually specified \" + (\"`to.\" + field + \"` field [\" + JSON.stringify(path) + \"].  Please separate it out to the \") + (\"`to.\" + dest + \"` field. Alternatively you may provide the full path as \") + 'a string in <Link to=\"...\"> and the router will parse it for you.';\n}\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */ function getPathContributingMatches(matches) {\n    return matches.filter((match, index)=>index === 0 || match.route.path && match.route.path.length > 0);\n}\n/**\n * @private\n */ function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {\n    if (isPathRelative === void 0) {\n        isPathRelative = false;\n    }\n    let to;\n    if (typeof toArg === \"string\") {\n        to = parsePath(toArg);\n    } else {\n        to = _extends({}, toArg);\n        invariant(!to.pathname || !to.pathname.includes(\"?\"), getInvalidPathError(\"?\", \"pathname\", \"search\", to));\n        invariant(!to.pathname || !to.pathname.includes(\"#\"), getInvalidPathError(\"#\", \"pathname\", \"hash\", to));\n        invariant(!to.search || !to.search.includes(\"#\"), getInvalidPathError(\"#\", \"search\", \"hash\", to));\n    }\n    let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n    let toPathname = isEmptyPath ? \"/\" : to.pathname;\n    let from;\n    // Routing is relative to the current pathname if explicitly requested.\n    //\n    // If a pathname is explicitly provided in `to`, it should be relative to the\n    // route context. This is explained in `Note on `<Link to>` values` in our\n    // migration guide from v5 as a means of disambiguation between `to` values\n    // that begin with `/` and those that do not. However, this is problematic for\n    // `to` values that do not provide a pathname. `to` can simply be a search or\n    // hash string, in which case we should assume that the navigation is relative\n    // to the current location's pathname and *not* the route pathname.\n    if (toPathname == null) {\n        from = locationPathname;\n    } else if (isPathRelative) {\n        let fromSegments = routePathnames[routePathnames.length - 1].replace(/^\\//, \"\").split(\"/\");\n        if (toPathname.startsWith(\"..\")) {\n            let toSegments = toPathname.split(\"/\");\n            // With relative=\"path\", each leading .. segment means \"go up one URL segment\"\n            while(toSegments[0] === \"..\"){\n                toSegments.shift();\n                fromSegments.pop();\n            }\n            to.pathname = toSegments.join(\"/\");\n        }\n        from = \"/\" + fromSegments.join(\"/\");\n    } else {\n        let routePathnameIndex = routePathnames.length - 1;\n        if (toPathname.startsWith(\"..\")) {\n            let toSegments = toPathname.split(\"/\");\n            // With relative=\"route\" (the default), each leading .. segment means\n            // \"go up one route\" instead of \"go up one URL segment\".  This is a key\n            // difference from how <a href> works and a major reason we call this a\n            // \"to\" value instead of a \"href\".\n            while(toSegments[0] === \"..\"){\n                toSegments.shift();\n                routePathnameIndex -= 1;\n            }\n            to.pathname = toSegments.join(\"/\");\n        }\n        // If there are more \"..\" segments than parent routes, resolve relative to\n        // the root / URL.\n        from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n    }\n    let path = resolvePath(to, from);\n    // Ensure the pathname has a trailing slash if the original \"to\" had one\n    let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n    // Or if this was a link to the current path which has a trailing slash\n    let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n    if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n        path.pathname += \"/\";\n    }\n    return path;\n}\n/**\n * @private\n */ function getToPathname(to) {\n    // Empty strings should be treated the same as / paths\n    return to === \"\" || to.pathname === \"\" ? \"/\" : typeof to === \"string\" ? parsePath(to).pathname : to.pathname;\n}\n/**\n * @private\n */ const joinPaths = (paths)=>paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n/**\n * @private\n */ const normalizePathname = (pathname)=>pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n/**\n * @private\n */ const normalizeSearch = (search)=>!search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\n/**\n * @private\n */ const normalizeHash = (hash)=>!hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */ const json = function json(data, init) {\n    if (init === void 0) {\n        init = {};\n    }\n    let responseInit = typeof init === \"number\" ? {\n        status: init\n    } : init;\n    let headers = new Headers(responseInit.headers);\n    if (!headers.has(\"Content-Type\")) {\n        headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n    }\n    return new Response(JSON.stringify(data), _extends({}, responseInit, {\n        headers\n    }));\n};\nclass AbortedDeferredError extends Error {\n}\nclass DeferredData {\n    constructor(data, responseInit){\n        this.pendingKeysSet = new Set();\n        this.subscribers = new Set();\n        this.deferredKeys = [];\n        invariant(data && typeof data === \"object\" && !Array.isArray(data), \"defer() only accepts plain objects\");\n        // Set up an AbortController + Promise we can race against to exit early\n        // cancellation\n        let reject;\n        this.abortPromise = new Promise((_, r)=>reject = r);\n        this.controller = new AbortController();\n        let onAbort = ()=>reject(new AbortedDeferredError(\"Deferred data aborted\"));\n        this.unlistenAbortSignal = ()=>this.controller.signal.removeEventListener(\"abort\", onAbort);\n        this.controller.signal.addEventListener(\"abort\", onAbort);\n        this.data = Object.entries(data).reduce((acc, _ref2)=>{\n            let [key, value] = _ref2;\n            return Object.assign(acc, {\n                [key]: this.trackPromise(key, value)\n            });\n        }, {});\n        if (this.done) {\n            // All incoming values were resolved\n            this.unlistenAbortSignal();\n        }\n        this.init = responseInit;\n    }\n    trackPromise(key, value) {\n        if (!(value instanceof Promise)) {\n            return value;\n        }\n        this.deferredKeys.push(key);\n        this.pendingKeysSet.add(key);\n        // We store a little wrapper promise that will be extended with\n        // _data/_error props upon resolve/reject\n        let promise = Promise.race([\n            value,\n            this.abortPromise\n        ]).then((data)=>this.onSettle(promise, key, undefined, data), (error)=>this.onSettle(promise, key, error));\n        // Register rejection listeners to avoid uncaught promise rejections on\n        // errors or aborted deferred values\n        promise.catch(()=>{});\n        Object.defineProperty(promise, \"_tracked\", {\n            get: ()=>true\n        });\n        return promise;\n    }\n    onSettle(promise, key, error, data) {\n        if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {\n            this.unlistenAbortSignal();\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>error\n            });\n            return Promise.reject(error);\n        }\n        this.pendingKeysSet.delete(key);\n        if (this.done) {\n            // Nothing left to abort!\n            this.unlistenAbortSignal();\n        }\n        // If the promise was resolved/rejected with undefined, we'll throw an error as you\n        // should always resolve with a value or null\n        if (error === undefined && data === undefined) {\n            let undefinedError = new Error('Deferred data for key \"' + key + '\" resolved/rejected with `undefined`, ' + \"you must resolve/reject with a value or `null`.\");\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>undefinedError\n            });\n            this.emit(false, key);\n            return Promise.reject(undefinedError);\n        }\n        if (data === undefined) {\n            Object.defineProperty(promise, \"_error\", {\n                get: ()=>error\n            });\n            this.emit(false, key);\n            return Promise.reject(error);\n        }\n        Object.defineProperty(promise, \"_data\", {\n            get: ()=>data\n        });\n        this.emit(false, key);\n        return data;\n    }\n    emit(aborted, settledKey) {\n        this.subscribers.forEach((subscriber)=>subscriber(aborted, settledKey));\n    }\n    subscribe(fn) {\n        this.subscribers.add(fn);\n        return ()=>this.subscribers.delete(fn);\n    }\n    cancel() {\n        this.controller.abort();\n        this.pendingKeysSet.forEach((v, k)=>this.pendingKeysSet.delete(k));\n        this.emit(true);\n    }\n    async resolveData(signal) {\n        let aborted = false;\n        if (!this.done) {\n            let onAbort = ()=>this.cancel();\n            signal.addEventListener(\"abort\", onAbort);\n            aborted = await new Promise((resolve)=>{\n                this.subscribe((aborted)=>{\n                    signal.removeEventListener(\"abort\", onAbort);\n                    if (aborted || this.done) {\n                        resolve(aborted);\n                    }\n                });\n            });\n        }\n        return aborted;\n    }\n    get done() {\n        return this.pendingKeysSet.size === 0;\n    }\n    get unwrappedData() {\n        invariant(this.data !== null && this.done, \"Can only unwrap data on initialized and settled deferreds\");\n        return Object.entries(this.data).reduce((acc, _ref3)=>{\n            let [key, value] = _ref3;\n            return Object.assign(acc, {\n                [key]: unwrapTrackedPromise(value)\n            });\n        }, {});\n    }\n    get pendingKeys() {\n        return Array.from(this.pendingKeysSet);\n    }\n}\nfunction isTrackedPromise(value) {\n    return value instanceof Promise && value._tracked === true;\n}\nfunction unwrapTrackedPromise(value) {\n    if (!isTrackedPromise(value)) {\n        return value;\n    }\n    if (value._error) {\n        throw value._error;\n    }\n    return value._data;\n}\nconst defer = function defer(data, init) {\n    if (init === void 0) {\n        init = {};\n    }\n    let responseInit = typeof init === \"number\" ? {\n        status: init\n    } : init;\n    return new DeferredData(data, responseInit);\n};\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */ const redirect = function redirect(url, init) {\n    if (init === void 0) {\n        init = 302;\n    }\n    let responseInit = init;\n    if (typeof responseInit === \"number\") {\n        responseInit = {\n            status: responseInit\n        };\n    } else if (typeof responseInit.status === \"undefined\") {\n        responseInit.status = 302;\n    }\n    let headers = new Headers(responseInit.headers);\n    headers.set(\"Location\", url);\n    return new Response(null, _extends({}, responseInit, {\n        headers\n    }));\n};\n/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */ const redirectDocument = (url, init)=>{\n    let response = redirect(url, init);\n    response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n    return response;\n};\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n *\n * We don't export the class for public use since it's an implementation\n * detail, but we export the interface above so folks can build their own\n * abstractions around instances via isRouteErrorResponse()\n */ class ErrorResponseImpl {\n    constructor(status, statusText, data, internal){\n        if (internal === void 0) {\n            internal = false;\n        }\n        this.status = status;\n        this.statusText = statusText || \"\";\n        this.internal = internal;\n        if (data instanceof Error) {\n            this.data = data.toString();\n            this.error = data;\n        } else {\n            this.data = data;\n        }\n    }\n}\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */ function isRouteErrorResponse(error) {\n    return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\n}\nconst validMutationMethodsArr = [\n    \"post\",\n    \"put\",\n    \"patch\",\n    \"delete\"\n];\nconst validMutationMethods = new Set(validMutationMethodsArr);\nconst validRequestMethodsArr = [\n    \"get\",\n    ...validMutationMethodsArr\n];\nconst validRequestMethods = new Set(validRequestMethodsArr);\nconst redirectStatusCodes = new Set([\n    301,\n    302,\n    303,\n    307,\n    308\n]);\nconst redirectPreserveMethodStatusCodes = new Set([\n    307,\n    308\n]);\nconst IDLE_NAVIGATION = {\n    state: \"idle\",\n    location: undefined,\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined\n};\nconst IDLE_FETCHER = {\n    state: \"idle\",\n    data: undefined,\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined\n};\nconst IDLE_BLOCKER = {\n    state: \"unblocked\",\n    proceed: undefined,\n    reset: undefined,\n    location: undefined\n};\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nconst defaultMapRouteProperties = (route)=>({\n        hasErrorBoundary: Boolean(route.hasErrorBoundary)\n    });\nconst TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a router and listen to history POP navigations\n */ function createRouter(init) {\n    const routerWindow = init.window ? init.window :  false ? 0 : undefined;\n    const isBrowser = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\n    const isServer = !isBrowser;\n    invariant(init.routes.length > 0, \"You must provide a non-empty routes array to createRouter\");\n    let mapRouteProperties;\n    if (init.mapRouteProperties) {\n        mapRouteProperties = init.mapRouteProperties;\n    } else if (init.detectErrorBoundary) {\n        // If they are still using the deprecated version, wrap it with the new API\n        let detectErrorBoundary = init.detectErrorBoundary;\n        mapRouteProperties = (route)=>({\n                hasErrorBoundary: detectErrorBoundary(route)\n            });\n    } else {\n        mapRouteProperties = defaultMapRouteProperties;\n    }\n    // Routes keyed by ID\n    let manifest = {};\n    // Routes in tree format for matching\n    let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, undefined, manifest);\n    let inFlightDataRoutes;\n    let basename = init.basename || \"/\";\n    // Config driven behavior flags\n    let future = _extends({\n        v7_fetcherPersist: false,\n        v7_normalizeFormMethod: false,\n        v7_prependBasename: false\n    }, init.future);\n    // Cleanup function for history\n    let unlistenHistory = null;\n    // Externally-provided functions to call on all state changes\n    let subscribers = new Set();\n    // Externally-provided object to hold scroll restoration locations during routing\n    let savedScrollPositions = null;\n    // Externally-provided function to get scroll restoration keys\n    let getScrollRestorationKey = null;\n    // Externally-provided function to get current scroll position\n    let getScrollPosition = null;\n    // One-time flag to control the initial hydration scroll restoration.  Because\n    // we don't get the saved positions from <ScrollRestoration /> until _after_\n    // the initial render, we need to manually trigger a separate updateState to\n    // send along the restoreScrollPosition\n    // Set to true if we have `hydrationData` since we assume we were SSR'd and that\n    // SSR did the initial scroll restoration.\n    let initialScrollRestored = init.hydrationData != null;\n    let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n    let initialErrors = null;\n    if (initialMatches == null) {\n        // If we do not match a user-provided-route, fall back to the root\n        // to allow the error boundary to take over\n        let error = getInternalRouterError(404, {\n            pathname: init.history.location.pathname\n        });\n        let { matches, route } = getShortCircuitMatches(dataRoutes);\n        initialMatches = matches;\n        initialErrors = {\n            [route.id]: error\n        };\n    }\n    let initialized = // All initialMatches need to be loaded before we're ready.  If we have lazy\n    // functions around still then we'll need to run them in initialize()\n    !initialMatches.some((m)=>m.route.lazy) && // And we have to either have no loaders or have been provided hydrationData\n    (!initialMatches.some((m)=>m.route.loader) || init.hydrationData != null);\n    let router;\n    let state = {\n        historyAction: init.history.action,\n        location: init.history.location,\n        matches: initialMatches,\n        initialized,\n        navigation: IDLE_NAVIGATION,\n        // Don't restore on initial updateState() if we were SSR'd\n        restoreScrollPosition: init.hydrationData != null ? false : null,\n        preventScrollReset: false,\n        revalidation: \"idle\",\n        loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n        actionData: init.hydrationData && init.hydrationData.actionData || null,\n        errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n        fetchers: new Map(),\n        blockers: new Map()\n    };\n    // -- Stateful internal variables to manage navigations --\n    // Current navigation in progress (to be committed in completeNavigation)\n    let pendingAction = Action.Pop;\n    // Should the current navigation prevent the scroll reset if scroll cannot\n    // be restored?\n    let pendingPreventScrollReset = false;\n    // AbortController for the active navigation\n    let pendingNavigationController;\n    // Should the current navigation enable document.startViewTransition?\n    let pendingViewTransitionEnabled = false;\n    // Store applied view transitions so we can apply them on POP\n    let appliedViewTransitions = new Map();\n    // Cleanup function for persisting applied transitions to sessionStorage\n    let removePageHideEventListener = null;\n    // We use this to avoid touching history in completeNavigation if a\n    // revalidation is entirely uninterrupted\n    let isUninterruptedRevalidation = false;\n    // Use this internal flag to force revalidation of all loaders:\n    //  - submissions (completed or interrupted)\n    //  - useRevalidator()\n    //  - X-Remix-Revalidate (from redirect)\n    let isRevalidationRequired = false;\n    // Use this internal array to capture routes that require revalidation due\n    // to a cancelled deferred on action submission\n    let cancelledDeferredRoutes = [];\n    // Use this internal array to capture fetcher loads that were cancelled by an\n    // action navigation and require revalidation\n    let cancelledFetcherLoads = [];\n    // AbortControllers for any in-flight fetchers\n    let fetchControllers = new Map();\n    // Track loads based on the order in which they started\n    let incrementingLoadId = 0;\n    // Track the outstanding pending navigation data load to be compared against\n    // the globally incrementing load when a fetcher load lands after a completed\n    // navigation\n    let pendingNavigationLoadId = -1;\n    // Fetchers that triggered data reloads as a result of their actions\n    let fetchReloadIds = new Map();\n    // Fetchers that triggered redirect navigations\n    let fetchRedirectIds = new Set();\n    // Most recent href/match for fetcher.load calls for fetchers\n    let fetchLoadMatches = new Map();\n    // Ref-count mounted fetchers so we know when it's ok to clean them up\n    let activeFetchers = new Map();\n    // Fetchers that have requested a delete when using v7_fetcherPersist,\n    // they'll be officially removed after they return to idle\n    let deletedFetchers = new Set();\n    // Store DeferredData instances for active route matches.  When a\n    // route loader returns defer() we stick one in here.  Then, when a nested\n    // promise resolves we update loaderData.  If a new navigation starts we\n    // cancel active deferreds for eliminated routes.\n    let activeDeferreds = new Map();\n    // Store blocker functions in a separate Map outside of router state since\n    // we don't need to update UI state if they change\n    let blockerFunctions = new Map();\n    // Flag to ignore the next history update, so we can revert the URL change on\n    // a POP navigation that was blocked by the user without touching router state\n    let ignoreNextHistoryUpdate = false;\n    // Initialize the router, all side effects should be kicked off from here.\n    // Implemented as a Fluent API for ease of:\n    //   let router = createRouter(init).initialize();\n    function initialize() {\n        // If history informs us of a POP navigation, start the navigation but do not update\n        // state.  We'll update our own state once the navigation completes\n        unlistenHistory = init.history.listen((_ref)=>{\n            let { action: historyAction, location, delta } = _ref;\n            // Ignore this event if it was just us resetting the URL from a\n            // blocked POP navigation\n            if (ignoreNextHistoryUpdate) {\n                ignoreNextHistoryUpdate = false;\n                return;\n            }\n            warning(blockerFunctions.size === 0 || delta != null, \"You are trying to use a blocker on a POP navigation to a location \" + \"that was not created by @remix-run/router. This will fail silently in \" + \"production. This can happen if you are navigating outside the router \" + \"via `window.history.pushState`/`window.location.hash` instead of using \" + \"router navigation APIs.  This can also happen if you are using \" + \"createHashRouter and the user manually changes the URL.\");\n            let blockerKey = shouldBlockNavigation({\n                currentLocation: state.location,\n                nextLocation: location,\n                historyAction\n            });\n            if (blockerKey && delta != null) {\n                // Restore the URL to match the current UI, but don't update router state\n                ignoreNextHistoryUpdate = true;\n                init.history.go(delta * -1);\n                // Put the blocker into a blocked state\n                updateBlocker(blockerKey, {\n                    state: \"blocked\",\n                    location,\n                    proceed () {\n                        updateBlocker(blockerKey, {\n                            state: \"proceeding\",\n                            proceed: undefined,\n                            reset: undefined,\n                            location\n                        });\n                        // Re-do the same POP navigation we just blocked\n                        init.history.go(delta);\n                    },\n                    reset () {\n                        let blockers = new Map(state.blockers);\n                        blockers.set(blockerKey, IDLE_BLOCKER);\n                        updateState({\n                            blockers\n                        });\n                    }\n                });\n                return;\n            }\n            return startNavigation(historyAction, location);\n        });\n        if (isBrowser) {\n            // FIXME: This feels gross.  How can we cleanup the lines between\n            // scrollRestoration/appliedTransitions persistance?\n            restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n            let _saveAppliedTransitions = ()=>persistAppliedTransitions(routerWindow, appliedViewTransitions);\n            routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions);\n            removePageHideEventListener = ()=>routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions);\n        }\n        // Kick off initial data load if needed.  Use Pop to avoid modifying history\n        // Note we don't do any handling of lazy here.  For SPA's it'll get handled\n        // in the normal navigation flow.  For SSR it's expected that lazy modules are\n        // resolved prior to router creation since we can't go into a fallbackElement\n        // UI for SSR'd apps\n        if (!state.initialized) {\n            startNavigation(Action.Pop, state.location);\n        }\n        return router;\n    }\n    // Clean up a router and it's side effects\n    function dispose() {\n        if (unlistenHistory) {\n            unlistenHistory();\n        }\n        if (removePageHideEventListener) {\n            removePageHideEventListener();\n        }\n        subscribers.clear();\n        pendingNavigationController && pendingNavigationController.abort();\n        state.fetchers.forEach((_, key)=>deleteFetcher(key));\n        state.blockers.forEach((_, key)=>deleteBlocker(key));\n    }\n    // Subscribe to state updates for the router\n    function subscribe(fn) {\n        subscribers.add(fn);\n        return ()=>subscribers.delete(fn);\n    }\n    // Update our state and notify the calling context of the change\n    function updateState(newState, opts) {\n        if (opts === void 0) {\n            opts = {};\n        }\n        state = _extends({}, state, newState);\n        // Prep fetcher cleanup so we can tell the UI which fetcher data entries\n        // can be removed\n        let completedFetchers = [];\n        let deletedFetchersKeys = [];\n        if (future.v7_fetcherPersist) {\n            state.fetchers.forEach((fetcher, key)=>{\n                if (fetcher.state === \"idle\") {\n                    if (deletedFetchers.has(key)) {\n                        // Unmounted from the UI and can be totally removed\n                        deletedFetchersKeys.push(key);\n                    } else {\n                        // Returned to idle but still mounted in the UI, so semi-remains for\n                        // revalidations and such\n                        completedFetchers.push(key);\n                    }\n                }\n            });\n        }\n        // Iterate over a local copy so that if flushSync is used and we end up\n        // removing and adding a new subscriber due to the useCallback dependencies,\n        // we don't get ourselves into a loop calling the new subscriber immediately\n        [\n            ...subscribers\n        ].forEach((subscriber)=>subscriber(state, {\n                deletedFetchers: deletedFetchersKeys,\n                unstable_viewTransitionOpts: opts.viewTransitionOpts,\n                unstable_flushSync: opts.flushSync === true\n            }));\n        // Remove idle fetchers from state since we only care about in-flight fetchers.\n        if (future.v7_fetcherPersist) {\n            completedFetchers.forEach((key)=>state.fetchers.delete(key));\n            deletedFetchersKeys.forEach((key)=>deleteFetcher(key));\n        }\n    }\n    // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n    // and setting state.[historyAction/location/matches] to the new route.\n    // - Location is a required param\n    // - Navigation will always be set to IDLE_NAVIGATION\n    // - Can pass any other state in newState\n    function completeNavigation(location, newState, _temp) {\n        var _location$state, _location$state2;\n        let { flushSync } = _temp === void 0 ? {} : _temp;\n        // Deduce if we're in a loading/actionReload state:\n        // - We have committed actionData in the store\n        // - The current navigation was a mutation submission\n        // - We're past the submitting state and into the loading state\n        // - The location being loaded is not the result of a redirect\n        let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;\n        let actionData;\n        if (newState.actionData) {\n            if (Object.keys(newState.actionData).length > 0) {\n                actionData = newState.actionData;\n            } else {\n                // Empty actionData -> clear prior actionData due to an action error\n                actionData = null;\n            }\n        } else if (isActionReload) {\n            // Keep the current data if we're wrapping up the action reload\n            actionData = state.actionData;\n        } else {\n            // Clear actionData on any other completed navigations\n            actionData = null;\n        }\n        // Always preserve any existing loaderData from re-used routes\n        let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\n        // On a successful navigation we can assume we got through all blockers\n        // so we can start fresh\n        let blockers = state.blockers;\n        if (blockers.size > 0) {\n            blockers = new Map(blockers);\n            blockers.forEach((_, k)=>blockers.set(k, IDLE_BLOCKER));\n        }\n        // Always respect the user flag.  Otherwise don't reset on mutation\n        // submission navigations unless they redirect\n        let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;\n        if (inFlightDataRoutes) {\n            dataRoutes = inFlightDataRoutes;\n            inFlightDataRoutes = undefined;\n        }\n        if (isUninterruptedRevalidation) ;\n        else if (pendingAction === Action.Pop) ;\n        else if (pendingAction === Action.Push) {\n            init.history.push(location, location.state);\n        } else if (pendingAction === Action.Replace) {\n            init.history.replace(location, location.state);\n        }\n        let viewTransitionOpts;\n        // On POP, enable transitions if they were enabled on the original navigation\n        if (pendingAction === Action.Pop) {\n            // Forward takes precedence so they behave like the original navigation\n            let priorPaths = appliedViewTransitions.get(state.location.pathname);\n            if (priorPaths && priorPaths.has(location.pathname)) {\n                viewTransitionOpts = {\n                    currentLocation: state.location,\n                    nextLocation: location\n                };\n            } else if (appliedViewTransitions.has(location.pathname)) {\n                // If we don't have a previous forward nav, assume we're popping back to\n                // the new location and enable if that location previously enabled\n                viewTransitionOpts = {\n                    currentLocation: location,\n                    nextLocation: state.location\n                };\n            }\n        } else if (pendingViewTransitionEnabled) {\n            // Store the applied transition on PUSH/REPLACE\n            let toPaths = appliedViewTransitions.get(state.location.pathname);\n            if (toPaths) {\n                toPaths.add(location.pathname);\n            } else {\n                toPaths = new Set([\n                    location.pathname\n                ]);\n                appliedViewTransitions.set(state.location.pathname, toPaths);\n            }\n            viewTransitionOpts = {\n                currentLocation: state.location,\n                nextLocation: location\n            };\n        }\n        updateState(_extends({}, newState, {\n            actionData,\n            loaderData,\n            historyAction: pendingAction,\n            location,\n            initialized: true,\n            navigation: IDLE_NAVIGATION,\n            revalidation: \"idle\",\n            restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\n            preventScrollReset,\n            blockers\n        }), {\n            viewTransitionOpts,\n            flushSync: flushSync === true\n        });\n        // Reset stateful navigation vars\n        pendingAction = Action.Pop;\n        pendingPreventScrollReset = false;\n        pendingViewTransitionEnabled = false;\n        isUninterruptedRevalidation = false;\n        isRevalidationRequired = false;\n        cancelledDeferredRoutes = [];\n        cancelledFetcherLoads = [];\n    }\n    // Trigger a navigation event, which can either be a numerical POP or a PUSH\n    // replace with an optional submission\n    async function navigate(to, opts) {\n        if (typeof to === \"number\") {\n            init.history.go(to);\n            return;\n        }\n        let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);\n        let { path, submission, error } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);\n        let currentLocation = state.location;\n        let nextLocation = createLocation(state.location, path, opts && opts.state);\n        // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\n        // URL from window.location, so we need to encode it here so the behavior\n        // remains the same as POP and non-data-router usages.  new URL() does all\n        // the same encoding we'd get from a history.pushState/window.location read\n        // without having to touch history\n        nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));\n        let userReplace = opts && opts.replace != null ? opts.replace : undefined;\n        let historyAction = Action.Push;\n        if (userReplace === true) {\n            historyAction = Action.Replace;\n        } else if (userReplace === false) ;\n        else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n            // By default on submissions to the current location we REPLACE so that\n            // users don't have to double-click the back button to get to the prior\n            // location.  If the user redirects to a different location from the\n            // action/loader this will be ignored and the redirect will be a PUSH\n            historyAction = Action.Replace;\n        }\n        let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : undefined;\n        let flushSync = (opts && opts.unstable_flushSync) === true;\n        let blockerKey = shouldBlockNavigation({\n            currentLocation,\n            nextLocation,\n            historyAction\n        });\n        if (blockerKey) {\n            // Put the blocker into a blocked state\n            updateBlocker(blockerKey, {\n                state: \"blocked\",\n                location: nextLocation,\n                proceed () {\n                    updateBlocker(blockerKey, {\n                        state: \"proceeding\",\n                        proceed: undefined,\n                        reset: undefined,\n                        location: nextLocation\n                    });\n                    // Send the same navigation through\n                    navigate(to, opts);\n                },\n                reset () {\n                    let blockers = new Map(state.blockers);\n                    blockers.set(blockerKey, IDLE_BLOCKER);\n                    updateState({\n                        blockers\n                    });\n                }\n            });\n            return;\n        }\n        return await startNavigation(historyAction, nextLocation, {\n            submission,\n            // Send through the formData serialization error if we have one so we can\n            // render at the right error boundary after we match routes\n            pendingError: error,\n            preventScrollReset,\n            replace: opts && opts.replace,\n            enableViewTransition: opts && opts.unstable_viewTransition,\n            flushSync\n        });\n    }\n    // Revalidate all current loaders.  If a navigation is in progress or if this\n    // is interrupted by a navigation, allow this to \"succeed\" by calling all\n    // loaders during the next loader round\n    function revalidate() {\n        interruptActiveLoads();\n        updateState({\n            revalidation: \"loading\"\n        });\n        // If we're currently submitting an action, we don't need to start a new\n        // navigation, we'll just let the follow up loader execution call all loaders\n        if (state.navigation.state === \"submitting\") {\n            return;\n        }\n        // If we're currently in an idle state, start a new navigation for the current\n        // action/location and mark it as uninterrupted, which will skip the history\n        // update in completeNavigation\n        if (state.navigation.state === \"idle\") {\n            startNavigation(state.historyAction, state.location, {\n                startUninterruptedRevalidation: true\n            });\n            return;\n        }\n        // Otherwise, if we're currently in a loading state, just start a new\n        // navigation to the navigation.location but do not trigger an uninterrupted\n        // revalidation so that history correctly updates once the navigation completes\n        startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n            overrideNavigation: state.navigation\n        });\n    }\n    // Start a navigation to the given action/location.  Can optionally provide a\n    // overrideNavigation which will override the normalLoad in the case of a redirect\n    // navigation\n    async function startNavigation(historyAction, location, opts) {\n        // Abort any in-progress navigations and start a new one. Unset any ongoing\n        // uninterrupted revalidations unless told otherwise, since we want this\n        // new navigation to update history normally\n        pendingNavigationController && pendingNavigationController.abort();\n        pendingNavigationController = null;\n        pendingAction = historyAction;\n        isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n        // Save the current scroll position every time we start a new navigation,\n        // and track whether we should reset scroll on completion\n        saveScrollPosition(state.location, state.matches);\n        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n        pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let loadingNavigation = opts && opts.overrideNavigation;\n        let matches = matchRoutes(routesToUse, location, basename);\n        let flushSync = (opts && opts.flushSync) === true;\n        // Short circuit with a 404 on the root error boundary if we match nothing\n        if (!matches) {\n            let error = getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n            let { matches: notFoundMatches, route } = getShortCircuitMatches(routesToUse);\n            // Cancel all pending deferred on 404s since we don't keep any routes\n            cancelActiveDeferreds();\n            completeNavigation(location, {\n                matches: notFoundMatches,\n                loaderData: {},\n                errors: {\n                    [route.id]: error\n                }\n            }, {\n                flushSync\n            });\n            return;\n        }\n        // Short circuit if it's only a hash change and not a revalidation or\n        // mutation submission.\n        //\n        // Ignore on initial page loads because since the initial load will always\n        // be \"same hash\".  For example, on /page#hash and submit a <Form method=\"post\">\n        // which will default to a navigation to /page\n        if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n            completeNavigation(location, {\n                matches\n            }, {\n                flushSync\n            });\n            return;\n        }\n        // Create a controller/Request for this navigation\n        pendingNavigationController = new AbortController();\n        let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\n        let pendingActionData;\n        let pendingError;\n        if (opts && opts.pendingError) {\n            // If we have a pendingError, it means the user attempted a GET submission\n            // with binary FormData so assign here and skip to handleLoaders.  That\n            // way we handle calling loaders above the boundary etc.  It's not really\n            // different from an actionError in that sense.\n            pendingError = {\n                [findNearestBoundary(matches).route.id]: opts.pendingError\n            };\n        } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\n            // Call action if we received an action submission\n            let actionOutput = await handleAction(request, location, opts.submission, matches, {\n                replace: opts.replace,\n                flushSync\n            });\n            if (actionOutput.shortCircuited) {\n                return;\n            }\n            pendingActionData = actionOutput.pendingActionData;\n            pendingError = actionOutput.pendingActionError;\n            loadingNavigation = getLoadingNavigation(location, opts.submission);\n            flushSync = false;\n            // Create a GET request for the loaders\n            request = new Request(request.url, {\n                signal: request.signal\n            });\n        }\n        // Call loaders\n        let { shortCircuited, loaderData, errors } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, flushSync, pendingActionData, pendingError);\n        if (shortCircuited) {\n            return;\n        }\n        // Clean up now that the action/loaders have completed.  Don't clean up if\n        // we short circuited because pendingNavigationController will have already\n        // been assigned to a new controller for the next navigation\n        pendingNavigationController = null;\n        completeNavigation(location, _extends({\n            matches\n        }, pendingActionData ? {\n            actionData: pendingActionData\n        } : {}, {\n            loaderData,\n            errors\n        }));\n    }\n    // Call the action matched by the leaf route for this navigation and handle\n    // redirects/errors\n    async function handleAction(request, location, submission, matches, opts) {\n        if (opts === void 0) {\n            opts = {};\n        }\n        interruptActiveLoads();\n        // Put us in a submitting state\n        let navigation = getSubmittingNavigation(location, submission);\n        updateState({\n            navigation\n        }, {\n            flushSync: opts.flushSync === true\n        });\n        // Call our action and get the result\n        let result;\n        let actionMatch = getTargetMatch(matches, location);\n        if (!actionMatch.route.action && !actionMatch.route.lazy) {\n            result = {\n                type: ResultType.error,\n                error: getInternalRouterError(405, {\n                    method: request.method,\n                    pathname: location.pathname,\n                    routeId: actionMatch.route.id\n                })\n            };\n        } else {\n            result = await callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties, basename);\n            if (request.signal.aborted) {\n                return {\n                    shortCircuited: true\n                };\n            }\n        }\n        if (isRedirectResult(result)) {\n            let replace;\n            if (opts && opts.replace != null) {\n                replace = opts.replace;\n            } else {\n                // If the user didn't explicity indicate replace behavior, replace if\n                // we redirected to the exact same location we're currently at to avoid\n                // double back-buttons\n                replace = result.location === state.location.pathname + state.location.search;\n            }\n            await startRedirectNavigation(state, result, {\n                submission,\n                replace\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        if (isErrorResult(result)) {\n            // Store off the pending error - we use it to determine which loaders\n            // to call and will commit it when we complete the navigation\n            let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n            // By default, all submissions are REPLACE navigations, but if the\n            // action threw an error that'll be rendered in an errorElement, we fall\n            // back to PUSH so that the user can use the back button to get back to\n            // the pre-submission form location to try again\n            if ((opts && opts.replace) !== true) {\n                pendingAction = Action.Push;\n            }\n            return {\n                // Send back an empty object we can use to clear out any prior actionData\n                pendingActionData: {},\n                pendingActionError: {\n                    [boundaryMatch.route.id]: result.error\n                }\n            };\n        }\n        if (isDeferredResult(result)) {\n            throw getInternalRouterError(400, {\n                type: \"defer-action\"\n            });\n        }\n        return {\n            pendingActionData: {\n                [actionMatch.route.id]: result.data\n            }\n        };\n    }\n    // Call all applicable loaders for the given matches, handling redirects,\n    // errors, etc.\n    async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, flushSync, pendingActionData, pendingError) {\n        // Figure out the right navigation we want to use for data loading\n        let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n        // If this was a redirect from an action we don't have a \"submission\" but\n        // we have it on the loading navigation so use that if available\n        let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError);\n        // Cancel pending deferreds for no-longer-matched routes or routes we're\n        // about to reload.  Note that if this is an action reload we would have\n        // already cancelled all pending deferreds so this would be a no-op\n        cancelActiveDeferreds((routeId)=>!(matches && matches.some((m)=>m.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m)=>m.route.id === routeId));\n        pendingNavigationLoadId = ++incrementingLoadId;\n        // Short circuit if we have no loaders to run\n        if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n            let updatedFetchers = markFetchRedirectsDone();\n            completeNavigation(location, _extends({\n                matches,\n                loaderData: {},\n                // Commit pending error if we're short circuiting\n                errors: pendingError || null\n            }, pendingActionData ? {\n                actionData: pendingActionData\n            } : {}, updatedFetchers ? {\n                fetchers: new Map(state.fetchers)\n            } : {}), {\n                flushSync\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        // If this is an uninterrupted revalidation, we remain in our current idle\n        // state.  If not, we need to switch to our loading state and load data,\n        // preserving any new action data or existing action data (in the case of\n        // a revalidation interrupting an actionReload)\n        if (!isUninterruptedRevalidation) {\n            revalidatingFetchers.forEach((rf)=>{\n                let fetcher = state.fetchers.get(rf.key);\n                let revalidatingFetcher = getLoadingFetcher(undefined, fetcher ? fetcher.data : undefined);\n                state.fetchers.set(rf.key, revalidatingFetcher);\n            });\n            let actionData = pendingActionData || state.actionData;\n            updateState(_extends({\n                navigation: loadingNavigation\n            }, actionData ? Object.keys(actionData).length === 0 ? {\n                actionData: null\n            } : {\n                actionData\n            } : {}, revalidatingFetchers.length > 0 ? {\n                fetchers: new Map(state.fetchers)\n            } : {}), {\n                flushSync\n            });\n        }\n        revalidatingFetchers.forEach((rf)=>{\n            if (fetchControllers.has(rf.key)) {\n                abortFetcher(rf.key);\n            }\n            if (rf.controller) {\n                // Fetchers use an independent AbortController so that aborting a fetcher\n                // (via deleteFetcher) does not abort the triggering navigation that\n                // triggered the revalidation\n                fetchControllers.set(rf.key, rf.controller);\n            }\n        });\n        // Proxy navigation abort through to revalidation fetchers\n        let abortPendingFetchRevalidations = ()=>revalidatingFetchers.forEach((f)=>abortFetcher(f.key));\n        if (pendingNavigationController) {\n            pendingNavigationController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n        }\n        let { results, loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);\n        if (request.signal.aborted) {\n            return {\n                shortCircuited: true\n            };\n        }\n        // Clean up _after_ loaders have completed.  Don't clean up if we short\n        // circuited because fetchControllers would have been aborted and\n        // reassigned to new controllers for the next navigation\n        if (pendingNavigationController) {\n            pendingNavigationController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n        }\n        revalidatingFetchers.forEach((rf)=>fetchControllers.delete(rf.key));\n        // If any loaders returned a redirect Response, start a new REPLACE navigation\n        let redirect = findRedirect(results);\n        if (redirect) {\n            if (redirect.idx >= matchesToLoad.length) {\n                // If this redirect came from a fetcher make sure we mark it in\n                // fetchRedirectIds so it doesn't get revalidated on the next set of\n                // loader executions\n                let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n                fetchRedirectIds.add(fetcherKey);\n            }\n            await startRedirectNavigation(state, redirect.result, {\n                replace\n            });\n            return {\n                shortCircuited: true\n            };\n        }\n        // Process and commit output from loaders\n        let { loaderData, errors } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);\n        // Wire up subscribers to update loaderData as promises settle\n        activeDeferreds.forEach((deferredData, routeId)=>{\n            deferredData.subscribe((aborted)=>{\n                // Note: No need to updateState here since the TrackedPromise on\n                // loaderData is stable across resolve/reject\n                // Remove this instance if we were aborted or if promises have settled\n                if (aborted || deferredData.done) {\n                    activeDeferreds.delete(routeId);\n                }\n            });\n        });\n        let updatedFetchers = markFetchRedirectsDone();\n        let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n        let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n        return _extends({\n            loaderData,\n            errors\n        }, shouldUpdateFetchers ? {\n            fetchers: new Map(state.fetchers)\n        } : {});\n    }\n    // Trigger a fetcher load/submit for the given fetcher key\n    function fetch(key, routeId, href, opts) {\n        if (isServer) {\n            throw new Error(\"router.fetch() was called during the server render, but it shouldn't be. \" + \"You are likely calling a useFetcher() method in the body of your component. \" + \"Try moving it to a useEffect or a callback.\");\n        }\n        if (fetchControllers.has(key)) abortFetcher(key);\n        let flushSync = (opts && opts.unstable_flushSync) === true;\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, routeId, opts == null ? void 0 : opts.relative);\n        let matches = matchRoutes(routesToUse, normalizedPath, basename);\n        if (!matches) {\n            setFetcherError(key, routeId, getInternalRouterError(404, {\n                pathname: normalizedPath\n            }), {\n                flushSync\n            });\n            return;\n        }\n        let { path, submission, error } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);\n        if (error) {\n            setFetcherError(key, routeId, error, {\n                flushSync\n            });\n            return;\n        }\n        let match = getTargetMatch(matches, path);\n        pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n        if (submission && isMutationMethod(submission.formMethod)) {\n            handleFetcherAction(key, routeId, path, match, matches, flushSync, submission);\n            return;\n        }\n        // Store off the match so we can call it's shouldRevalidate on subsequent\n        // revalidations\n        fetchLoadMatches.set(key, {\n            routeId,\n            path\n        });\n        handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission);\n    }\n    // Call the action for the matched fetcher.submit(), and then handle redirects,\n    // errors, and revalidation\n    async function handleFetcherAction(key, routeId, path, match, requestMatches, flushSync, submission) {\n        interruptActiveLoads();\n        fetchLoadMatches.delete(key);\n        if (!match.route.action && !match.route.lazy) {\n            let error = getInternalRouterError(405, {\n                method: submission.formMethod,\n                pathname: path,\n                routeId: routeId\n            });\n            setFetcherError(key, routeId, error, {\n                flushSync\n            });\n            return;\n        }\n        // Put this fetcher into it's submitting state\n        let existingFetcher = state.fetchers.get(key);\n        updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n            flushSync\n        });\n        // Call the action for the fetcher\n        let abortController = new AbortController();\n        let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\n        fetchControllers.set(key, abortController);\n        let originatingLoadId = incrementingLoadId;\n        let actionResult = await callLoaderOrAction(\"action\", fetchRequest, match, requestMatches, manifest, mapRouteProperties, basename);\n        if (fetchRequest.signal.aborted) {\n            // We can delete this so long as we weren't aborted by our own fetcher\n            // re-submit which would have put _new_ controller is in fetchControllers\n            if (fetchControllers.get(key) === abortController) {\n                fetchControllers.delete(key);\n            }\n            return;\n        }\n        if (deletedFetchers.has(key)) {\n            updateFetcherState(key, getDoneFetcher(undefined));\n            return;\n        }\n        if (isRedirectResult(actionResult)) {\n            fetchControllers.delete(key);\n            if (pendingNavigationLoadId > originatingLoadId) {\n                // A new navigation was kicked off after our action started, so that\n                // should take precedence over this redirect navigation.  We already\n                // set isRevalidationRequired so all loaders for the new route should\n                // fire unless opted out via shouldRevalidate\n                updateFetcherState(key, getDoneFetcher(undefined));\n                return;\n            } else {\n                fetchRedirectIds.add(key);\n                updateFetcherState(key, getLoadingFetcher(submission));\n                return startRedirectNavigation(state, actionResult, {\n                    fetcherSubmission: submission\n                });\n            }\n        }\n        // Process any non-redirect errors thrown\n        if (isErrorResult(actionResult)) {\n            setFetcherError(key, routeId, actionResult.error);\n            return;\n        }\n        if (isDeferredResult(actionResult)) {\n            throw getInternalRouterError(400, {\n                type: \"defer-action\"\n            });\n        }\n        // Start the data load for current matches, or the next location if we're\n        // in the middle of a navigation\n        let nextLocation = state.navigation.location || state.location;\n        let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\n        let routesToUse = inFlightDataRoutes || dataRoutes;\n        let matches = state.navigation.state !== \"idle\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n        invariant(matches, \"Didn't find any matches after fetcher action\");\n        let loadId = ++incrementingLoadId;\n        fetchReloadIds.set(key, loadId);\n        let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n        state.fetchers.set(key, loadFetcher);\n        let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, {\n            [match.route.id]: actionResult.data\n        }, undefined // No need to send through errors since we short circuit above\n        );\n        // Put all revalidating fetchers into the loading state, except for the\n        // current fetcher which we want to keep in it's current loading state which\n        // contains it's action submission info + action data\n        revalidatingFetchers.filter((rf)=>rf.key !== key).forEach((rf)=>{\n            let staleKey = rf.key;\n            let existingFetcher = state.fetchers.get(staleKey);\n            let revalidatingFetcher = getLoadingFetcher(undefined, existingFetcher ? existingFetcher.data : undefined);\n            state.fetchers.set(staleKey, revalidatingFetcher);\n            if (fetchControllers.has(staleKey)) {\n                abortFetcher(staleKey);\n            }\n            if (rf.controller) {\n                fetchControllers.set(staleKey, rf.controller);\n            }\n        });\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n        let abortPendingFetchRevalidations = ()=>revalidatingFetchers.forEach((rf)=>abortFetcher(rf.key));\n        abortController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n        let { results, loaderResults, fetcherResults } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);\n        if (abortController.signal.aborted) {\n            return;\n        }\n        abortController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n        fetchReloadIds.delete(key);\n        fetchControllers.delete(key);\n        revalidatingFetchers.forEach((r)=>fetchControllers.delete(r.key));\n        let redirect = findRedirect(results);\n        if (redirect) {\n            if (redirect.idx >= matchesToLoad.length) {\n                // If this redirect came from a fetcher make sure we mark it in\n                // fetchRedirectIds so it doesn't get revalidated on the next set of\n                // loader executions\n                let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n                fetchRedirectIds.add(fetcherKey);\n            }\n            return startRedirectNavigation(state, redirect.result);\n        }\n        // Process and commit output from loaders\n        let { loaderData, errors } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);\n        // Since we let revalidations complete even if the submitting fetcher was\n        // deleted, only put it back to idle if it hasn't been deleted\n        if (state.fetchers.has(key)) {\n            let doneFetcher = getDoneFetcher(actionResult.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n        abortStaleFetchLoads(loadId);\n        // If we are currently in a navigation loading state and this fetcher is\n        // more recent than the navigation, we want the newer data so abort the\n        // navigation and complete it with the fetcher data\n        if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n            invariant(pendingAction, \"Expected pending action\");\n            pendingNavigationController && pendingNavigationController.abort();\n            completeNavigation(state.navigation.location, {\n                matches,\n                loaderData,\n                errors,\n                fetchers: new Map(state.fetchers)\n            });\n        } else {\n            // otherwise just update with the fetcher data, preserving any existing\n            // loaderData for loaders that did not need to reload.  We have to\n            // manually merge here since we aren't going through completeNavigation\n            updateState({\n                errors,\n                loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),\n                fetchers: new Map(state.fetchers)\n            });\n            isRevalidationRequired = false;\n        }\n    }\n    // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n    async function handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission) {\n        let existingFetcher = state.fetchers.get(key);\n        updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : undefined), {\n            flushSync\n        });\n        // Call the loader for this fetcher route match\n        let abortController = new AbortController();\n        let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\n        fetchControllers.set(key, abortController);\n        let originatingLoadId = incrementingLoadId;\n        let result = await callLoaderOrAction(\"loader\", fetchRequest, match, matches, manifest, mapRouteProperties, basename);\n        // Deferred isn't supported for fetcher loads, await everything and treat it\n        // as a normal load.  resolveDeferredData will return undefined if this\n        // fetcher gets aborted, so we just leave result untouched and short circuit\n        // below if that happens\n        if (isDeferredResult(result)) {\n            result = await resolveDeferredData(result, fetchRequest.signal, true) || result;\n        }\n        // We can delete this so long as we weren't aborted by our our own fetcher\n        // re-load which would have put _new_ controller is in fetchControllers\n        if (fetchControllers.get(key) === abortController) {\n            fetchControllers.delete(key);\n        }\n        if (fetchRequest.signal.aborted) {\n            return;\n        }\n        if (deletedFetchers.has(key)) {\n            updateFetcherState(key, getDoneFetcher(undefined));\n            return;\n        }\n        // If the loader threw a redirect Response, start a new REPLACE navigation\n        if (isRedirectResult(result)) {\n            if (pendingNavigationLoadId > originatingLoadId) {\n                // A new navigation was kicked off after our loader started, so that\n                // should take precedence over this redirect navigation\n                updateFetcherState(key, getDoneFetcher(undefined));\n                return;\n            } else {\n                fetchRedirectIds.add(key);\n                await startRedirectNavigation(state, result);\n                return;\n            }\n        }\n        // Process any non-redirect errors thrown\n        if (isErrorResult(result)) {\n            setFetcherError(key, routeId, result.error);\n            return;\n        }\n        invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\n        // Put the fetcher back into an idle state\n        updateFetcherState(key, getDoneFetcher(result.data));\n    }\n    /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we've processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */ async function startRedirectNavigation(state, redirect, _temp2) {\n        let { submission, fetcherSubmission, replace } = _temp2 === void 0 ? {} : _temp2;\n        if (redirect.revalidate) {\n            isRevalidationRequired = true;\n        }\n        let redirectLocation = createLocation(state.location, redirect.location, {\n            _isRedirect: true\n        });\n        invariant(redirectLocation, \"Expected a location on the redirect navigation\");\n        if (isBrowser) {\n            let isDocumentReload = false;\n            if (redirect.reloadDocument) {\n                // Hard reload if the response contained X-Remix-Reload-Document\n                isDocumentReload = true;\n            } else if (ABSOLUTE_URL_REGEX.test(redirect.location)) {\n                const url = init.history.createURL(redirect.location);\n                isDocumentReload = // Hard reload if it's an absolute URL to a new origin\n                url.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename\n                stripBasename(url.pathname, basename) == null;\n            }\n            if (isDocumentReload) {\n                if (replace) {\n                    routerWindow.location.replace(redirect.location);\n                } else {\n                    routerWindow.location.assign(redirect.location);\n                }\n                return;\n            }\n        }\n        // There's no need to abort on redirects, since we don't detect the\n        // redirect until the action/loaders have settled\n        pendingNavigationController = null;\n        let redirectHistoryAction = replace === true ? Action.Replace : Action.Push;\n        // Use the incoming submission if provided, fallback on the active one in\n        // state.navigation\n        let { formMethod, formAction, formEncType } = state.navigation;\n        if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n            submission = getSubmissionFromNavigation(state.navigation);\n        }\n        // If this was a 307/308 submission we want to preserve the HTTP method and\n        // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n        // redirected location\n        let activeSubmission = submission || fetcherSubmission;\n        if (redirectPreserveMethodStatusCodes.has(redirect.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\n            await startNavigation(redirectHistoryAction, redirectLocation, {\n                submission: _extends({}, activeSubmission, {\n                    formAction: redirect.location\n                }),\n                // Preserve this flag across redirects\n                preventScrollReset: pendingPreventScrollReset\n            });\n        } else {\n            // If we have a navigation submission, we will preserve it through the\n            // redirect navigation\n            let overrideNavigation = getLoadingNavigation(redirectLocation, submission);\n            await startNavigation(redirectHistoryAction, redirectLocation, {\n                overrideNavigation,\n                // Send fetcher submissions through for shouldRevalidate\n                fetcherSubmission,\n                // Preserve this flag across redirects\n                preventScrollReset: pendingPreventScrollReset\n            });\n        }\n    }\n    async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {\n        // Call all navigation loaders and revalidating fetcher loaders in parallel,\n        // then slice off the results into separate arrays so we can handle them\n        // accordingly\n        let results = await Promise.all([\n            ...matchesToLoad.map((match)=>callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties, basename)),\n            ...fetchersToLoad.map((f)=>{\n                if (f.matches && f.match && f.controller) {\n                    return callLoaderOrAction(\"loader\", createClientSideRequest(init.history, f.path, f.controller.signal), f.match, f.matches, manifest, mapRouteProperties, basename);\n                } else {\n                    let error = {\n                        type: ResultType.error,\n                        error: getInternalRouterError(404, {\n                            pathname: f.path\n                        })\n                    };\n                    return error;\n                }\n            })\n        ]);\n        let loaderResults = results.slice(0, matchesToLoad.length);\n        let fetcherResults = results.slice(matchesToLoad.length);\n        await Promise.all([\n            resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(()=>request.signal), false, state.loaderData),\n            resolveDeferredResults(currentMatches, fetchersToLoad.map((f)=>f.match), fetcherResults, fetchersToLoad.map((f)=>f.controller ? f.controller.signal : null), true)\n        ]);\n        return {\n            results,\n            loaderResults,\n            fetcherResults\n        };\n    }\n    function interruptActiveLoads() {\n        // Every interruption triggers a revalidation\n        isRevalidationRequired = true;\n        // Cancel pending route-level deferreds and mark cancelled routes for\n        // revalidation\n        cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n        // Abort in-flight fetcher loads\n        fetchLoadMatches.forEach((_, key)=>{\n            if (fetchControllers.has(key)) {\n                cancelledFetcherLoads.push(key);\n                abortFetcher(key);\n            }\n        });\n    }\n    function updateFetcherState(key, fetcher, opts) {\n        if (opts === void 0) {\n            opts = {};\n        }\n        state.fetchers.set(key, fetcher);\n        updateState({\n            fetchers: new Map(state.fetchers)\n        }, {\n            flushSync: (opts && opts.flushSync) === true\n        });\n    }\n    function setFetcherError(key, routeId, error, opts) {\n        if (opts === void 0) {\n            opts = {};\n        }\n        let boundaryMatch = findNearestBoundary(state.matches, routeId);\n        deleteFetcher(key);\n        updateState({\n            errors: {\n                [boundaryMatch.route.id]: error\n            },\n            fetchers: new Map(state.fetchers)\n        }, {\n            flushSync: (opts && opts.flushSync) === true\n        });\n    }\n    function getFetcher(key) {\n        if (future.v7_fetcherPersist) {\n            activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n            // If this fetcher was previously marked for deletion, unmark it since we\n            // have a new instance\n            if (deletedFetchers.has(key)) {\n                deletedFetchers.delete(key);\n            }\n        }\n        return state.fetchers.get(key) || IDLE_FETCHER;\n    }\n    function deleteFetcher(key) {\n        let fetcher = state.fetchers.get(key);\n        // Don't abort the controller if this is a deletion of a fetcher.submit()\n        // in it's loading phase since - we don't want to abort the corresponding\n        // revalidation and want them to complete and land\n        if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) {\n            abortFetcher(key);\n        }\n        fetchLoadMatches.delete(key);\n        fetchReloadIds.delete(key);\n        fetchRedirectIds.delete(key);\n        deletedFetchers.delete(key);\n        state.fetchers.delete(key);\n    }\n    function deleteFetcherAndUpdateState(key) {\n        if (future.v7_fetcherPersist) {\n            let count = (activeFetchers.get(key) || 0) - 1;\n            if (count <= 0) {\n                activeFetchers.delete(key);\n                deletedFetchers.add(key);\n            } else {\n                activeFetchers.set(key, count);\n            }\n        } else {\n            deleteFetcher(key);\n        }\n        updateState({\n            fetchers: new Map(state.fetchers)\n        });\n    }\n    function abortFetcher(key) {\n        let controller = fetchControllers.get(key);\n        invariant(controller, \"Expected fetch controller: \" + key);\n        controller.abort();\n        fetchControllers.delete(key);\n    }\n    function markFetchersDone(keys) {\n        for (let key of keys){\n            let fetcher = getFetcher(key);\n            let doneFetcher = getDoneFetcher(fetcher.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n    }\n    function markFetchRedirectsDone() {\n        let doneKeys = [];\n        let updatedFetchers = false;\n        for (let key of fetchRedirectIds){\n            let fetcher = state.fetchers.get(key);\n            invariant(fetcher, \"Expected fetcher: \" + key);\n            if (fetcher.state === \"loading\") {\n                fetchRedirectIds.delete(key);\n                doneKeys.push(key);\n                updatedFetchers = true;\n            }\n        }\n        markFetchersDone(doneKeys);\n        return updatedFetchers;\n    }\n    function abortStaleFetchLoads(landedId) {\n        let yeetedKeys = [];\n        for (let [key, id] of fetchReloadIds){\n            if (id < landedId) {\n                let fetcher = state.fetchers.get(key);\n                invariant(fetcher, \"Expected fetcher: \" + key);\n                if (fetcher.state === \"loading\") {\n                    abortFetcher(key);\n                    fetchReloadIds.delete(key);\n                    yeetedKeys.push(key);\n                }\n            }\n        }\n        markFetchersDone(yeetedKeys);\n        return yeetedKeys.length > 0;\n    }\n    function getBlocker(key, fn) {\n        let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n        if (blockerFunctions.get(key) !== fn) {\n            blockerFunctions.set(key, fn);\n        }\n        return blocker;\n    }\n    function deleteBlocker(key) {\n        state.blockers.delete(key);\n        blockerFunctions.delete(key);\n    }\n    // Utility function to update blockers, ensuring valid state transitions\n    function updateBlocker(key, newBlocker) {\n        let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n        // Poor mans state machine :)\n        // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\n        invariant(blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\", \"Invalid blocker state transition: \" + blocker.state + \" -> \" + newBlocker.state);\n        let blockers = new Map(state.blockers);\n        blockers.set(key, newBlocker);\n        updateState({\n            blockers\n        });\n    }\n    function shouldBlockNavigation(_ref2) {\n        let { currentLocation, nextLocation, historyAction } = _ref2;\n        if (blockerFunctions.size === 0) {\n            return;\n        }\n        // We ony support a single active blocker at the moment since we don't have\n        // any compelling use cases for multi-blocker yet\n        if (blockerFunctions.size > 1) {\n            warning(false, \"A router only supports one blocker at a time\");\n        }\n        let entries = Array.from(blockerFunctions.entries());\n        let [blockerKey, blockerFunction] = entries[entries.length - 1];\n        let blocker = state.blockers.get(blockerKey);\n        if (blocker && blocker.state === \"proceeding\") {\n            // If the blocker is currently proceeding, we don't need to re-check\n            // it and can let this navigation continue\n            return;\n        }\n        // At this point, we know we're unblocked/blocked so we need to check the\n        // user-provided blocker function\n        if (blockerFunction({\n            currentLocation,\n            nextLocation,\n            historyAction\n        })) {\n            return blockerKey;\n        }\n    }\n    function cancelActiveDeferreds(predicate) {\n        let cancelledRouteIds = [];\n        activeDeferreds.forEach((dfd, routeId)=>{\n            if (!predicate || predicate(routeId)) {\n                // Cancel the deferred - but do not remove from activeDeferreds here -\n                // we rely on the subscribers to do that so our tests can assert proper\n                // cleanup via _internalActiveDeferreds\n                dfd.cancel();\n                cancelledRouteIds.push(routeId);\n                activeDeferreds.delete(routeId);\n            }\n        });\n        return cancelledRouteIds;\n    }\n    // Opt in to capturing and reporting scroll positions during navigations,\n    // used by the <ScrollRestoration> component\n    function enableScrollRestoration(positions, getPosition, getKey) {\n        savedScrollPositions = positions;\n        getScrollPosition = getPosition;\n        getScrollRestorationKey = getKey || null;\n        // Perform initial hydration scroll restoration, since we miss the boat on\n        // the initial updateState() because we've not yet rendered <ScrollRestoration/>\n        // and therefore have no savedScrollPositions available\n        if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n            initialScrollRestored = true;\n            let y = getSavedScrollPosition(state.location, state.matches);\n            if (y != null) {\n                updateState({\n                    restoreScrollPosition: y\n                });\n            }\n        }\n        return ()=>{\n            savedScrollPositions = null;\n            getScrollPosition = null;\n            getScrollRestorationKey = null;\n        };\n    }\n    function getScrollKey(location, matches) {\n        if (getScrollRestorationKey) {\n            let key = getScrollRestorationKey(location, matches.map((m)=>convertRouteMatchToUiMatch(m, state.loaderData)));\n            return key || location.key;\n        }\n        return location.key;\n    }\n    function saveScrollPosition(location, matches) {\n        if (savedScrollPositions && getScrollPosition) {\n            let key = getScrollKey(location, matches);\n            savedScrollPositions[key] = getScrollPosition();\n        }\n    }\n    function getSavedScrollPosition(location, matches) {\n        if (savedScrollPositions) {\n            let key = getScrollKey(location, matches);\n            let y = savedScrollPositions[key];\n            if (typeof y === \"number\") {\n                return y;\n            }\n        }\n        return null;\n    }\n    function _internalSetRoutes(newRoutes) {\n        manifest = {};\n        inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, undefined, manifest);\n    }\n    router = {\n        get basename () {\n            return basename;\n        },\n        get state () {\n            return state;\n        },\n        get routes () {\n            return dataRoutes;\n        },\n        get window () {\n            return routerWindow;\n        },\n        initialize,\n        subscribe,\n        enableScrollRestoration,\n        navigate,\n        fetch,\n        revalidate,\n        // Passthrough to history-aware createHref used by useHref so we get proper\n        // hash-aware URLs in DOM paths\n        createHref: (to)=>init.history.createHref(to),\n        encodeLocation: (to)=>init.history.encodeLocation(to),\n        getFetcher,\n        deleteFetcher: deleteFetcherAndUpdateState,\n        dispose,\n        getBlocker,\n        deleteBlocker,\n        _internalFetchControllers: fetchControllers,\n        _internalActiveDeferreds: activeDeferreds,\n        // TODO: Remove setRoutes, it's temporary to avoid dealing with\n        // updating the tree while validating the update algorithm.\n        _internalSetRoutes\n    };\n    return router;\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\nconst UNSAFE_DEFERRED_SYMBOL = Symbol(\"deferred\");\nfunction createStaticHandler(routes, opts) {\n    invariant(routes.length > 0, \"You must provide a non-empty routes array to createStaticHandler\");\n    let manifest = {};\n    let basename = (opts ? opts.basename : null) || \"/\";\n    let mapRouteProperties;\n    if (opts != null && opts.mapRouteProperties) {\n        mapRouteProperties = opts.mapRouteProperties;\n    } else if (opts != null && opts.detectErrorBoundary) {\n        // If they are still using the deprecated version, wrap it with the new API\n        let detectErrorBoundary = opts.detectErrorBoundary;\n        mapRouteProperties = (route)=>({\n                hasErrorBoundary: detectErrorBoundary(route)\n            });\n    } else {\n        mapRouteProperties = defaultMapRouteProperties;\n    }\n    let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, undefined, manifest);\n    /**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   */ async function query(request, _temp3) {\n        let { requestContext } = _temp3 === void 0 ? {} : _temp3;\n        let url = new URL(request.url);\n        let method = request.method;\n        let location = createLocation(\"\", createPath(url), null, \"default\");\n        let matches = matchRoutes(dataRoutes, location, basename);\n        // SSR supports HEAD requests while SPA doesn't\n        if (!isValidMethod(method) && method !== \"HEAD\") {\n            let error = getInternalRouterError(405, {\n                method\n            });\n            let { matches: methodNotAllowedMatches, route } = getShortCircuitMatches(dataRoutes);\n            return {\n                basename,\n                location,\n                matches: methodNotAllowedMatches,\n                loaderData: {},\n                actionData: null,\n                errors: {\n                    [route.id]: error\n                },\n                statusCode: error.status,\n                loaderHeaders: {},\n                actionHeaders: {},\n                activeDeferreds: null\n            };\n        } else if (!matches) {\n            let error = getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n            let { matches: notFoundMatches, route } = getShortCircuitMatches(dataRoutes);\n            return {\n                basename,\n                location,\n                matches: notFoundMatches,\n                loaderData: {},\n                actionData: null,\n                errors: {\n                    [route.id]: error\n                },\n                statusCode: error.status,\n                loaderHeaders: {},\n                actionHeaders: {},\n                activeDeferreds: null\n            };\n        }\n        let result = await queryImpl(request, location, matches, requestContext);\n        if (isResponse(result)) {\n            return result;\n        }\n        // When returning StaticHandlerContext, we patch back in the location here\n        // since we need it for React Context.  But this helps keep our submit and\n        // loadRouteData operating on a Request instead of a Location\n        return _extends({\n            location,\n            basename\n        }, result);\n    }\n    /**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   */ async function queryRoute(request, _temp4) {\n        let { routeId, requestContext } = _temp4 === void 0 ? {} : _temp4;\n        let url = new URL(request.url);\n        let method = request.method;\n        let location = createLocation(\"\", createPath(url), null, \"default\");\n        let matches = matchRoutes(dataRoutes, location, basename);\n        // SSR supports HEAD requests while SPA doesn't\n        if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n            throw getInternalRouterError(405, {\n                method\n            });\n        } else if (!matches) {\n            throw getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n        }\n        let match = routeId ? matches.find((m)=>m.route.id === routeId) : getTargetMatch(matches, location);\n        if (routeId && !match) {\n            throw getInternalRouterError(403, {\n                pathname: location.pathname,\n                routeId\n            });\n        } else if (!match) {\n            // This should never hit I don't think?\n            throw getInternalRouterError(404, {\n                pathname: location.pathname\n            });\n        }\n        let result = await queryImpl(request, location, matches, requestContext, match);\n        if (isResponse(result)) {\n            return result;\n        }\n        let error = result.errors ? Object.values(result.errors)[0] : undefined;\n        if (error !== undefined) {\n            // If we got back result.errors, that means the loader/action threw\n            // _something_ that wasn't a Response, but it's not guaranteed/required\n            // to be an `instanceof Error` either, so we have to use throw here to\n            // preserve the \"error\" state outside of queryImpl.\n            throw error;\n        }\n        // Pick off the right state value to return\n        if (result.actionData) {\n            return Object.values(result.actionData)[0];\n        }\n        if (result.loaderData) {\n            var _result$activeDeferre;\n            let data = Object.values(result.loaderData)[0];\n            if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {\n                data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];\n            }\n            return data;\n        }\n        return undefined;\n    }\n    async function queryImpl(request, location, matches, requestContext, routeMatch) {\n        invariant(request.signal, \"query()/queryRoute() requests must contain an AbortController signal\");\n        try {\n            if (isMutationMethod(request.method.toLowerCase())) {\n                let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);\n                return result;\n            }\n            let result = await loadRouteData(request, matches, requestContext, routeMatch);\n            return isResponse(result) ? result : _extends({}, result, {\n                actionData: null,\n                actionHeaders: {}\n            });\n        } catch (e) {\n            // If the user threw/returned a Response in callLoaderOrAction, we throw\n            // it to bail out and then return or throw here based on whether the user\n            // returned or threw\n            if (isQueryRouteResponse(e)) {\n                if (e.type === ResultType.error) {\n                    throw e.response;\n                }\n                return e.response;\n            }\n            // Redirects are always returned since they don't propagate to catch\n            // boundaries\n            if (isRedirectResponse(e)) {\n                return e;\n            }\n            throw e;\n        }\n    }\n    async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {\n        let result;\n        if (!actionMatch.route.action && !actionMatch.route.lazy) {\n            let error = getInternalRouterError(405, {\n                method: request.method,\n                pathname: new URL(request.url).pathname,\n                routeId: actionMatch.route.id\n            });\n            if (isRouteRequest) {\n                throw error;\n            }\n            result = {\n                type: ResultType.error,\n                error\n            };\n        } else {\n            result = await callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties, basename, {\n                isStaticRequest: true,\n                isRouteRequest,\n                requestContext\n            });\n            if (request.signal.aborted) {\n                let method = isRouteRequest ? \"queryRoute\" : \"query\";\n                throw new Error(method + \"() call aborted: \" + request.method + \" \" + request.url);\n            }\n        }\n        if (isRedirectResult(result)) {\n            // Uhhhh - this should never happen, we should always throw these from\n            // callLoaderOrAction, but the type narrowing here keeps TS happy and we\n            // can get back on the \"throw all redirect responses\" train here should\n            // this ever happen :/\n            throw new Response(null, {\n                status: result.status,\n                headers: {\n                    Location: result.location\n                }\n            });\n        }\n        if (isDeferredResult(result)) {\n            let error = getInternalRouterError(400, {\n                type: \"defer-action\"\n            });\n            if (isRouteRequest) {\n                throw error;\n            }\n            result = {\n                type: ResultType.error,\n                error\n            };\n        }\n        if (isRouteRequest) {\n            // Note: This should only be non-Response values if we get here, since\n            // isRouteRequest should throw any Response received in callLoaderOrAction\n            if (isErrorResult(result)) {\n                throw result.error;\n            }\n            return {\n                matches: [\n                    actionMatch\n                ],\n                loaderData: {},\n                actionData: {\n                    [actionMatch.route.id]: result.data\n                },\n                errors: null,\n                // Note: statusCode + headers are unused here since queryRoute will\n                // return the raw Response or value\n                statusCode: 200,\n                loaderHeaders: {},\n                actionHeaders: {},\n                activeDeferreds: null\n            };\n        }\n        if (isErrorResult(result)) {\n            // Store off the pending error - we use it to determine which loaders\n            // to call and will commit it when we complete the navigation\n            let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n            let context = await loadRouteData(request, matches, requestContext, undefined, {\n                [boundaryMatch.route.id]: result.error\n            });\n            // action status codes take precedence over loader status codes\n            return _extends({}, context, {\n                statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,\n                actionData: null,\n                actionHeaders: _extends({}, result.headers ? {\n                    [actionMatch.route.id]: result.headers\n                } : {})\n            });\n        }\n        // Create a GET request for the loaders\n        let loaderRequest = new Request(request.url, {\n            headers: request.headers,\n            redirect: request.redirect,\n            signal: request.signal\n        });\n        let context = await loadRouteData(loaderRequest, matches, requestContext);\n        return _extends({}, context, result.statusCode ? {\n            statusCode: result.statusCode\n        } : {}, {\n            actionData: {\n                [actionMatch.route.id]: result.data\n            },\n            actionHeaders: _extends({}, result.headers ? {\n                [actionMatch.route.id]: result.headers\n            } : {})\n        });\n    }\n    async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {\n        let isRouteRequest = routeMatch != null;\n        // Short circuit if we have no loaders to run (queryRoute())\n        if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy)) {\n            throw getInternalRouterError(400, {\n                method: request.method,\n                pathname: new URL(request.url).pathname,\n                routeId: routeMatch == null ? void 0 : routeMatch.route.id\n            });\n        }\n        let requestMatches = routeMatch ? [\n            routeMatch\n        ] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]);\n        let matchesToLoad = requestMatches.filter((m)=>m.route.loader || m.route.lazy);\n        // Short circuit if we have no loaders to run (query())\n        if (matchesToLoad.length === 0) {\n            return {\n                matches,\n                // Add a null for all matched routes for proper revalidation on the client\n                loaderData: matches.reduce((acc, m)=>Object.assign(acc, {\n                        [m.route.id]: null\n                    }), {}),\n                errors: pendingActionError || null,\n                statusCode: 200,\n                loaderHeaders: {},\n                activeDeferreds: null\n            };\n        }\n        let results = await Promise.all([\n            ...matchesToLoad.map((match)=>callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties, basename, {\n                    isStaticRequest: true,\n                    isRouteRequest,\n                    requestContext\n                }))\n        ]);\n        if (request.signal.aborted) {\n            let method = isRouteRequest ? \"queryRoute\" : \"query\";\n            throw new Error(method + \"() call aborted: \" + request.method + \" \" + request.url);\n        }\n        // Process and commit output from loaders\n        let activeDeferreds = new Map();\n        let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds);\n        // Add a null for any non-loader matches for proper revalidation on the client\n        let executedLoaders = new Set(matchesToLoad.map((match)=>match.route.id));\n        matches.forEach((match)=>{\n            if (!executedLoaders.has(match.route.id)) {\n                context.loaderData[match.route.id] = null;\n            }\n        });\n        return _extends({}, context, {\n            matches,\n            activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null\n        });\n    }\n    return {\n        dataRoutes,\n        query,\n        queryRoute\n    };\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */ function getStaticContextFromError(routes, context, error) {\n    let newContext = _extends({}, context, {\n        statusCode: 500,\n        errors: {\n            [context._deepestRenderedBoundaryId || routes[0].id]: error\n        }\n    });\n    return newContext;\n}\nfunction isSubmissionNavigation(opts) {\n    return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== undefined);\n}\nfunction normalizeTo(location, matches, basename, prependBasename, to, fromRouteId, relative) {\n    let contextualMatches;\n    let activeRouteMatch;\n    if (fromRouteId) {\n        // Grab matches up to the calling route so our route-relative logic is\n        // relative to the correct source route\n        contextualMatches = [];\n        for (let match of matches){\n            contextualMatches.push(match);\n            if (match.route.id === fromRouteId) {\n                activeRouteMatch = match;\n                break;\n            }\n        }\n    } else {\n        contextualMatches = matches;\n        activeRouteMatch = matches[matches.length - 1];\n    }\n    // Resolve the relative path\n    let path = resolveTo(to ? to : \".\", getPathContributingMatches(contextualMatches).map((m)=>m.pathnameBase), stripBasename(location.pathname, basename) || location.pathname, relative === \"path\");\n    // When `to` is not specified we inherit search/hash from the current\n    // location, unlike when to=\".\" and we just inherit the path.\n    // See https://github.com/remix-run/remix/issues/927\n    if (to == null) {\n        path.search = location.search;\n        path.hash = location.hash;\n    }\n    // Add an ?index param for matched index routes if we don't already have one\n    if ((to == null || to === \"\" || to === \".\") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {\n        path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n    }\n    // If we're operating within a basename, prepend it to the pathname.  If\n    // this is a root navigation, then just use the raw basename which allows\n    // the basename to have full control over the presence of a trailing slash\n    // on root actions\n    if (prependBasename && basename !== \"/\") {\n        path.pathname = path.pathname === \"/\" ? basename : joinPaths([\n            basename,\n            path.pathname\n        ]);\n    }\n    return createPath(path);\n}\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {\n    // Return location verbatim on non-submission navigations\n    if (!opts || !isSubmissionNavigation(opts)) {\n        return {\n            path\n        };\n    }\n    if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n        return {\n            path,\n            error: getInternalRouterError(405, {\n                method: opts.formMethod\n            })\n        };\n    }\n    let getInvalidBodyError = ()=>({\n            path,\n            error: getInternalRouterError(400, {\n                type: \"invalid-body\"\n            })\n        });\n    // Create a Submission on non-GET navigations\n    let rawFormMethod = opts.formMethod || \"get\";\n    let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();\n    let formAction = stripHashFromPath(path);\n    if (opts.body !== undefined) {\n        if (opts.formEncType === \"text/plain\") {\n            // text only support POST/PUT/PATCH/DELETE submissions\n            if (!isMutationMethod(formMethod)) {\n                return getInvalidBodyError();\n            }\n            let text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n            Array.from(opts.body.entries()).reduce((acc, _ref3)=>{\n                let [name, value] = _ref3;\n                return \"\" + acc + name + \"=\" + value + \"\\n\";\n            }, \"\") : String(opts.body);\n            return {\n                path,\n                submission: {\n                    formMethod,\n                    formAction,\n                    formEncType: opts.formEncType,\n                    formData: undefined,\n                    json: undefined,\n                    text\n                }\n            };\n        } else if (opts.formEncType === \"application/json\") {\n            // json only supports POST/PUT/PATCH/DELETE submissions\n            if (!isMutationMethod(formMethod)) {\n                return getInvalidBodyError();\n            }\n            try {\n                let json = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n                return {\n                    path,\n                    submission: {\n                        formMethod,\n                        formAction,\n                        formEncType: opts.formEncType,\n                        formData: undefined,\n                        json,\n                        text: undefined\n                    }\n                };\n            } catch (e) {\n                return getInvalidBodyError();\n            }\n        }\n    }\n    invariant(typeof FormData === \"function\", \"FormData is not available in this environment\");\n    let searchParams;\n    let formData;\n    if (opts.formData) {\n        searchParams = convertFormDataToSearchParams(opts.formData);\n        formData = opts.formData;\n    } else if (opts.body instanceof FormData) {\n        searchParams = convertFormDataToSearchParams(opts.body);\n        formData = opts.body;\n    } else if (opts.body instanceof URLSearchParams) {\n        searchParams = opts.body;\n        formData = convertSearchParamsToFormData(searchParams);\n    } else if (opts.body == null) {\n        searchParams = new URLSearchParams();\n        formData = new FormData();\n    } else {\n        try {\n            searchParams = new URLSearchParams(opts.body);\n            formData = convertSearchParamsToFormData(searchParams);\n        } catch (e) {\n            return getInvalidBodyError();\n        }\n    }\n    let submission = {\n        formMethod,\n        formAction,\n        formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n        formData,\n        json: undefined,\n        text: undefined\n    };\n    if (isMutationMethod(submission.formMethod)) {\n        return {\n            path,\n            submission\n        };\n    }\n    // Flatten submission onto URLSearchParams for GET submissions\n    let parsedPath = parsePath(path);\n    // On GET navigation submissions we can drop the ?index param from the\n    // resulting location since all loaders will run.  But fetcher GET submissions\n    // only run a single loader so we need to preserve any incoming ?index params\n    if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n        searchParams.append(\"index\", \"\");\n    }\n    parsedPath.search = \"?\" + searchParams;\n    return {\n        path: createPath(parsedPath),\n        submission\n    };\n}\n// Filter out all routes below any caught error as they aren't going to\n// render so we don't need to load them\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId) {\n    let boundaryMatches = matches;\n    if (boundaryId) {\n        let index = matches.findIndex((m)=>m.route.id === boundaryId);\n        if (index >= 0) {\n            boundaryMatches = matches.slice(0, index);\n        }\n    }\n    return boundaryMatches;\n}\nfunction getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {\n    let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined;\n    let currentUrl = history.createURL(state.location);\n    let nextUrl = history.createURL(location);\n    // Pick navigation matches that are net-new or qualify for revalidation\n    let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;\n    let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\n    let navigationMatches = boundaryMatches.filter((match, index)=>{\n        if (match.route.lazy) {\n            // We haven't loaded this route yet so we don't know if it's got a loader!\n            return true;\n        }\n        if (match.route.loader == null) {\n            return false;\n        }\n        // Always call the loader on new route instances and pending defer cancellations\n        if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some((id)=>id === match.route.id)) {\n            return true;\n        }\n        // This is the default implementation for when we revalidate.  If the route\n        // provides it's own implementation, then we give them full control but\n        // provide this value so they can leverage it if needed after they check\n        // their own specific use cases\n        let currentRouteMatch = state.matches[index];\n        let nextRouteMatch = match;\n        return shouldRevalidateLoader(match, _extends({\n            currentUrl,\n            currentParams: currentRouteMatch.params,\n            nextUrl,\n            nextParams: nextRouteMatch.params\n        }, submission, {\n            actionResult,\n            defaultShouldRevalidate: // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n            isRevalidationRequired || // Clicked the same link, resubmitted a GET form\n            currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders\n            currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)\n        }));\n    });\n    // Pick fetcher.loads that need to be revalidated\n    let revalidatingFetchers = [];\n    fetchLoadMatches.forEach((f, key)=>{\n        // Don't revalidate if fetcher won't be present in the subsequent render\n        if (!matches.some((m)=>m.route.id === f.routeId) || deletedFetchers.has(key)) {\n            return;\n        }\n        let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n        // If the fetcher path no longer matches, push it in with null matches so\n        // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n        // currently only a use-case for Remix HMR where the route tree can change\n        // at runtime and remove a route previously loaded via a fetcher\n        if (!fetcherMatches) {\n            revalidatingFetchers.push({\n                key,\n                routeId: f.routeId,\n                path: f.path,\n                matches: null,\n                match: null,\n                controller: null\n            });\n            return;\n        }\n        // Revalidating fetchers are decoupled from the route matches since they\n        // load from a static href.  They revalidate based on explicit revalidation\n        // (submission, useRevalidator, or X-Remix-Revalidate)\n        let fetcher = state.fetchers.get(key);\n        let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n        let shouldRevalidate = false;\n        if (fetchRedirectIds.has(key)) {\n            // Never trigger a revalidation of an actively redirecting fetcher\n            shouldRevalidate = false;\n        } else if (cancelledFetcherLoads.includes(key)) {\n            // Always revalidate if the fetcher was cancelled\n            shouldRevalidate = true;\n        } else if (fetcher && fetcher.state !== \"idle\" && fetcher.data === undefined) {\n            // If the fetcher hasn't ever completed loading yet, then this isn't a\n            // revalidation, it would just be a brand new load if an explicit\n            // revalidation is required\n            shouldRevalidate = isRevalidationRequired;\n        } else {\n            // Otherwise fall back on any user-defined shouldRevalidate, defaulting\n            // to explicit revalidations only\n            shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({\n                currentUrl,\n                currentParams: state.matches[state.matches.length - 1].params,\n                nextUrl,\n                nextParams: matches[matches.length - 1].params\n            }, submission, {\n                actionResult,\n                defaultShouldRevalidate: isRevalidationRequired\n            }));\n        }\n        if (shouldRevalidate) {\n            revalidatingFetchers.push({\n                key,\n                routeId: f.routeId,\n                path: f.path,\n                matches: fetcherMatches,\n                match: fetcherMatch,\n                controller: new AbortController()\n            });\n        }\n    });\n    return [\n        navigationMatches,\n        revalidatingFetchers\n    ];\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n    let isNew = // [a] -> [a, b]\n    !currentMatch || // [a, b] -> [a, c]\n    match.route.id !== currentMatch.route.id;\n    // Handle the case that we don't have data for a re-used route, potentially\n    // from a prior error or from a cancelled pending deferred\n    let isMissingData = currentLoaderData[match.route.id] === undefined;\n    // Always load if this is a net-new route or we don't yet have data\n    return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n    let currentPath = currentMatch.route.path;\n    return(// param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname || // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]);\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n    if (loaderMatch.route.shouldRevalidate) {\n        let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n        if (typeof routeChoice === \"boolean\") {\n            return routeChoice;\n        }\n    }\n    return arg.defaultShouldRevalidate;\n}\n/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */ async function loadLazyRouteModule(route, mapRouteProperties, manifest) {\n    if (!route.lazy) {\n        return;\n    }\n    let lazyRoute = await route.lazy();\n    // If the lazy route function was executed and removed by another parallel\n    // call then we can return - first lazy() to finish wins because the return\n    // value of lazy is expected to be static\n    if (!route.lazy) {\n        return;\n    }\n    let routeToUpdate = manifest[route.id];\n    invariant(routeToUpdate, \"No route found in manifest\");\n    // Update the route in place.  This should be safe because there's no way\n    // we could yet be sitting on this route as we can't get there without\n    // resolving lazy() first.\n    //\n    // This is different than the HMR \"update\" use-case where we may actively be\n    // on the route being updated.  The main concern boils down to \"does this\n    // mutation affect any ongoing navigations or any current state.matches\n    // values?\".  If not, it should be safe to update in place.\n    let routeUpdates = {};\n    for(let lazyRouteProperty in lazyRoute){\n        let staticRouteValue = routeToUpdate[lazyRouteProperty];\n        let isPropertyStaticallyDefined = staticRouteValue !== undefined && // This property isn't static since it should always be updated based\n        // on the route updates\n        lazyRouteProperty !== \"hasErrorBoundary\";\n        warning(!isPropertyStaticallyDefined, 'Route \"' + routeToUpdate.id + '\" has a static property \"' + lazyRouteProperty + '\" ' + \"defined but its lazy function is also returning a value for this property. \" + ('The lazy route property \"' + lazyRouteProperty + '\" will be ignored.'));\n        if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {\n            routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];\n        }\n    }\n    // Mutate the route with the provided updates.  Do this first so we pass\n    // the updated version to mapRouteProperties\n    Object.assign(routeToUpdate, routeUpdates);\n    // Mutate the `hasErrorBoundary` property on the route based on the route\n    // updates and remove the `lazy` function so we don't resolve the lazy\n    // route again.\n    Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {\n        lazy: undefined\n    }));\n}\nasync function callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties, basename, opts) {\n    if (opts === void 0) {\n        opts = {};\n    }\n    let resultType;\n    let result;\n    let onReject;\n    let runHandler = (handler)=>{\n        // Setup a promise we can race against so that abort signals short circuit\n        let reject;\n        let abortPromise = new Promise((_, r)=>reject = r);\n        onReject = ()=>reject();\n        request.signal.addEventListener(\"abort\", onReject);\n        return Promise.race([\n            handler({\n                request,\n                params: match.params,\n                context: opts.requestContext\n            }),\n            abortPromise\n        ]);\n    };\n    try {\n        let handler = match.route[type];\n        if (match.route.lazy) {\n            if (handler) {\n                // Run statically defined handler in parallel with lazy()\n                let handlerError;\n                let values = await Promise.all([\n                    // If the handler throws, don't let it immediately bubble out,\n                    // since we need to let the lazy() execution finish so we know if this\n                    // route has a boundary that can handle the error\n                    runHandler(handler).catch((e)=>{\n                        handlerError = e;\n                    }),\n                    loadLazyRouteModule(match.route, mapRouteProperties, manifest)\n                ]);\n                if (handlerError) {\n                    throw handlerError;\n                }\n                result = values[0];\n            } else {\n                // Load lazy route module, then run any returned handler\n                await loadLazyRouteModule(match.route, mapRouteProperties, manifest);\n                handler = match.route[type];\n                if (handler) {\n                    // Handler still run even if we got interrupted to maintain consistency\n                    // with un-abortable behavior of handler execution on non-lazy or\n                    // previously-lazy-loaded routes\n                    result = await runHandler(handler);\n                } else if (type === \"action\") {\n                    let url = new URL(request.url);\n                    let pathname = url.pathname + url.search;\n                    throw getInternalRouterError(405, {\n                        method: request.method,\n                        pathname,\n                        routeId: match.route.id\n                    });\n                } else {\n                    // lazy() route has no loader to run.  Short circuit here so we don't\n                    // hit the invariant below that errors on returning undefined.\n                    return {\n                        type: ResultType.data,\n                        data: undefined\n                    };\n                }\n            }\n        } else if (!handler) {\n            let url = new URL(request.url);\n            let pathname = url.pathname + url.search;\n            throw getInternalRouterError(404, {\n                pathname\n            });\n        } else {\n            result = await runHandler(handler);\n        }\n        invariant(result !== undefined, \"You defined \" + (type === \"action\" ? \"an action\" : \"a loader\") + \" for route \" + ('\"' + match.route.id + \"\\\" but didn't return anything from your `\" + type + \"` \") + \"function. Please return a value or `null`.\");\n    } catch (e) {\n        resultType = ResultType.error;\n        result = e;\n    } finally{\n        if (onReject) {\n            request.signal.removeEventListener(\"abort\", onReject);\n        }\n    }\n    if (isResponse(result)) {\n        let status = result.status;\n        // Process redirects\n        if (redirectStatusCodes.has(status)) {\n            let location = result.headers.get(\"Location\");\n            invariant(location, \"Redirects returned/thrown from loaders/actions must have a Location header\");\n            // Support relative routing in internal redirects\n            if (!ABSOLUTE_URL_REGEX.test(location)) {\n                location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, true, location);\n            } else if (!opts.isStaticRequest) {\n                // Strip off the protocol+origin for same-origin + same-basename absolute\n                // redirects. If this is a static request, we can let it go back to the\n                // browser as-is\n                let currentUrl = new URL(request.url);\n                let url = location.startsWith(\"//\") ? new URL(currentUrl.protocol + location) : new URL(location);\n                let isSameBasename = stripBasename(url.pathname, basename) != null;\n                if (url.origin === currentUrl.origin && isSameBasename) {\n                    location = url.pathname + url.search + url.hash;\n                }\n            }\n            // Don't process redirects in the router during static requests requests.\n            // Instead, throw the Response and let the server handle it with an HTTP\n            // redirect.  We also update the Location header in place in this flow so\n            // basename and relative routing is taken into account\n            if (opts.isStaticRequest) {\n                result.headers.set(\"Location\", location);\n                throw result;\n            }\n            return {\n                type: ResultType.redirect,\n                status,\n                location,\n                revalidate: result.headers.get(\"X-Remix-Revalidate\") !== null,\n                reloadDocument: result.headers.get(\"X-Remix-Reload-Document\") !== null\n            };\n        }\n        // For SSR single-route requests, we want to hand Responses back directly\n        // without unwrapping.  We do this with the QueryRouteResponse wrapper\n        // interface so we can know whether it was returned or thrown\n        if (opts.isRouteRequest) {\n            let queryRouteResponse = {\n                type: resultType === ResultType.error ? ResultType.error : ResultType.data,\n                response: result\n            };\n            throw queryRouteResponse;\n        }\n        let data;\n        let contentType = result.headers.get(\"Content-Type\");\n        // Check between word boundaries instead of startsWith() due to the last\n        // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n        if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n            data = await result.json();\n        } else {\n            data = await result.text();\n        }\n        if (resultType === ResultType.error) {\n            return {\n                type: resultType,\n                error: new ErrorResponseImpl(status, result.statusText, data),\n                headers: result.headers\n            };\n        }\n        return {\n            type: ResultType.data,\n            data,\n            statusCode: result.status,\n            headers: result.headers\n        };\n    }\n    if (resultType === ResultType.error) {\n        return {\n            type: resultType,\n            error: result\n        };\n    }\n    if (isDeferredData(result)) {\n        var _result$init, _result$init2;\n        return {\n            type: ResultType.deferred,\n            deferredData: result,\n            statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,\n            headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)\n        };\n    }\n    return {\n        type: ResultType.data,\n        data: result\n    };\n}\n// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction createClientSideRequest(history, location, signal, submission) {\n    let url = history.createURL(stripHashFromPath(location)).toString();\n    let init = {\n        signal\n    };\n    if (submission && isMutationMethod(submission.formMethod)) {\n        let { formMethod, formEncType } = submission;\n        // Didn't think we needed this but it turns out unlike other methods, patch\n        // won't be properly normalized to uppercase and results in a 405 error.\n        // See: https://fetch.spec.whatwg.org/#concept-method\n        init.method = formMethod.toUpperCase();\n        if (formEncType === \"application/json\") {\n            init.headers = new Headers({\n                \"Content-Type\": formEncType\n            });\n            init.body = JSON.stringify(submission.json);\n        } else if (formEncType === \"text/plain\") {\n            // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n            init.body = submission.text;\n        } else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) {\n            // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n            init.body = convertFormDataToSearchParams(submission.formData);\n        } else {\n            // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n            init.body = submission.formData;\n        }\n    }\n    return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n    let searchParams = new URLSearchParams();\n    for (let [key, value] of formData.entries()){\n        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n        searchParams.append(key, typeof value === \"string\" ? value : value.name);\n    }\n    return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n    let formData = new FormData();\n    for (let [key, value] of searchParams.entries()){\n        formData.append(key, value);\n    }\n    return formData;\n}\nfunction processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {\n    // Fill in loaderData/errors from our loaders\n    let loaderData = {};\n    let errors = null;\n    let statusCode;\n    let foundError = false;\n    let loaderHeaders = {};\n    // Process loader results into state.loaderData/state.errors\n    results.forEach((result, index)=>{\n        let id = matchesToLoad[index].route.id;\n        invariant(!isRedirectResult(result), \"Cannot handle redirect results in processLoaderData\");\n        if (isErrorResult(result)) {\n            // Look upwards from the matched route for the closest ancestor\n            // error boundary, defaulting to the root match\n            let boundaryMatch = findNearestBoundary(matches, id);\n            let error = result.error;\n            // If we have a pending action error, we report it at the highest-route\n            // that throws a loader error, and then clear it out to indicate that\n            // it was consumed\n            if (pendingError) {\n                error = Object.values(pendingError)[0];\n                pendingError = undefined;\n            }\n            errors = errors || {};\n            // Prefer higher error values if lower errors bubble to the same boundary\n            if (errors[boundaryMatch.route.id] == null) {\n                errors[boundaryMatch.route.id] = error;\n            }\n            // Clear our any prior loaderData for the throwing route\n            loaderData[id] = undefined;\n            // Once we find our first (highest) error, we set the status code and\n            // prevent deeper status codes from overriding\n            if (!foundError) {\n                foundError = true;\n                statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n            }\n            if (result.headers) {\n                loaderHeaders[id] = result.headers;\n            }\n        } else {\n            if (isDeferredResult(result)) {\n                activeDeferreds.set(id, result.deferredData);\n                loaderData[id] = result.deferredData.data;\n            } else {\n                loaderData[id] = result.data;\n            }\n            // Error status codes always override success status codes, but if all\n            // loaders are successful we take the deepest status code.\n            if (result.statusCode != null && result.statusCode !== 200 && !foundError) {\n                statusCode = result.statusCode;\n            }\n            if (result.headers) {\n                loaderHeaders[id] = result.headers;\n            }\n        }\n    });\n    // If we didn't consume the pending action error (i.e., all loaders\n    // resolved), then consume it here.  Also clear out any loaderData for the\n    // throwing route\n    if (pendingError) {\n        errors = pendingError;\n        loaderData[Object.keys(pendingError)[0]] = undefined;\n    }\n    return {\n        loaderData,\n        errors,\n        statusCode: statusCode || 200,\n        loaderHeaders\n    };\n}\nfunction processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {\n    let { loaderData, errors } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);\n    // Process results from our revalidating fetchers\n    for(let index = 0; index < revalidatingFetchers.length; index++){\n        let { key, match, controller } = revalidatingFetchers[index];\n        invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, \"Did not find corresponding fetcher result\");\n        let result = fetcherResults[index];\n        // Process fetcher non-redirect errors\n        if (controller && controller.signal.aborted) {\n            continue;\n        } else if (isErrorResult(result)) {\n            let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);\n            if (!(errors && errors[boundaryMatch.route.id])) {\n                errors = _extends({}, errors, {\n                    [boundaryMatch.route.id]: result.error\n                });\n            }\n            state.fetchers.delete(key);\n        } else if (isRedirectResult(result)) {\n            // Should never get here, redirects should get processed above, but we\n            // keep this to type narrow to a success result in the else\n            invariant(false, \"Unhandled fetcher revalidation redirect\");\n        } else if (isDeferredResult(result)) {\n            // Should never get here, deferred data should be awaited for fetchers\n            // in resolveDeferredResults\n            invariant(false, \"Unhandled fetcher deferred data\");\n        } else {\n            let doneFetcher = getDoneFetcher(result.data);\n            state.fetchers.set(key, doneFetcher);\n        }\n    }\n    return {\n        loaderData,\n        errors\n    };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n    let mergedLoaderData = _extends({}, newLoaderData);\n    for (let match of matches){\n        let id = match.route.id;\n        if (newLoaderData.hasOwnProperty(id)) {\n            if (newLoaderData[id] !== undefined) {\n                mergedLoaderData[id] = newLoaderData[id];\n            }\n        } else if (loaderData[id] !== undefined && match.route.loader) {\n            // Preserve existing keys not included in newLoaderData and where a loader\n            // wasn't removed by HMR\n            mergedLoaderData[id] = loaderData[id];\n        }\n        if (errors && errors.hasOwnProperty(id)) {\n            break;\n        }\n    }\n    return mergedLoaderData;\n}\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(matches, routeId) {\n    let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m)=>m.route.id === routeId) + 1) : [\n        ...matches\n    ];\n    return eligibleMatches.reverse().find((m)=>m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n    // Prefer a root layout route if present, otherwise shim in a route object\n    let route = routes.length === 1 ? routes[0] : routes.find((r)=>r.index || !r.path || r.path === \"/\") || {\n        id: \"__shim-error-route__\"\n    };\n    return {\n        matches: [\n            {\n                params: {},\n                pathname: \"\",\n                pathnameBase: \"\",\n                route\n            }\n        ],\n        route\n    };\n}\nfunction getInternalRouterError(status, _temp5) {\n    let { pathname, routeId, method, type } = _temp5 === void 0 ? {} : _temp5;\n    let statusText = \"Unknown Server Error\";\n    let errorMessage = \"Unknown @remix-run/router error\";\n    if (status === 400) {\n        statusText = \"Bad Request\";\n        if (method && pathname && routeId) {\n            errorMessage = \"You made a \" + method + ' request to \"' + pathname + '\" but ' + ('did not provide a `loader` for route \"' + routeId + '\", ') + \"so there is no way to handle the request.\";\n        } else if (type === \"defer-action\") {\n            errorMessage = \"defer() is not supported in actions\";\n        } else if (type === \"invalid-body\") {\n            errorMessage = \"Unable to encode submission body\";\n        }\n    } else if (status === 403) {\n        statusText = \"Forbidden\";\n        errorMessage = 'Route \"' + routeId + '\" does not match URL \"' + pathname + '\"';\n    } else if (status === 404) {\n        statusText = \"Not Found\";\n        errorMessage = 'No route matches URL \"' + pathname + '\"';\n    } else if (status === 405) {\n        statusText = \"Method Not Allowed\";\n        if (method && pathname && routeId) {\n            errorMessage = \"You made a \" + method.toUpperCase() + ' request to \"' + pathname + '\" but ' + ('did not provide an `action` for route \"' + routeId + '\", ') + \"so there is no way to handle the request.\";\n        } else if (method) {\n            errorMessage = 'Invalid request method \"' + method.toUpperCase() + '\"';\n        }\n    }\n    return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);\n}\n// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(results) {\n    for(let i = results.length - 1; i >= 0; i--){\n        let result = results[i];\n        if (isRedirectResult(result)) {\n            return {\n                result,\n                idx: i\n            };\n        }\n    }\n}\nfunction stripHashFromPath(path) {\n    let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n    return createPath(_extends({}, parsedPath, {\n        hash: \"\"\n    }));\n}\nfunction isHashChangeOnly(a, b) {\n    if (a.pathname !== b.pathname || a.search !== b.search) {\n        return false;\n    }\n    if (a.hash === \"\") {\n        // /page -> /page#hash\n        return b.hash !== \"\";\n    } else if (a.hash === b.hash) {\n        // /page#hash -> /page#hash\n        return true;\n    } else if (b.hash !== \"\") {\n        // /page#hash -> /page#other\n        return true;\n    }\n    // If the hash is removed the browser will re-perform a request to the server\n    // /page#hash -> /page\n    return false;\n}\nfunction isDeferredResult(result) {\n    return result.type === ResultType.deferred;\n}\nfunction isErrorResult(result) {\n    return result.type === ResultType.error;\n}\nfunction isRedirectResult(result) {\n    return (result && result.type) === ResultType.redirect;\n}\nfunction isDeferredData(value) {\n    let deferred = value;\n    return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nfunction isResponse(value) {\n    return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isRedirectResponse(result) {\n    if (!isResponse(result)) {\n        return false;\n    }\n    let status = result.status;\n    let location = result.headers.get(\"Location\");\n    return status >= 300 && status <= 399 && location != null;\n}\nfunction isQueryRouteResponse(obj) {\n    return obj && isResponse(obj.response) && (obj.type === ResultType.data || obj.type === ResultType.error);\n}\nfunction isValidMethod(method) {\n    return validRequestMethods.has(method.toLowerCase());\n}\nfunction isMutationMethod(method) {\n    return validMutationMethods.has(method.toLowerCase());\n}\nasync function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {\n    for(let index = 0; index < results.length; index++){\n        let result = results[index];\n        let match = matchesToLoad[index];\n        // If we don't have a match, then we can have a deferred result to do\n        // anything with.  This is for revalidating fetchers where the route was\n        // removed during HMR\n        if (!match) {\n            continue;\n        }\n        let currentMatch = currentMatches.find((m)=>m.route.id === match.route.id);\n        let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n        if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n            // Note: we do not have to touch activeDeferreds here since we race them\n            // against the signal in resolveDeferredData and they'll get aborted\n            // there if needed\n            let signal = signals[index];\n            invariant(signal, \"Expected an AbortSignal for revalidating fetcher deferred result\");\n            await resolveDeferredData(result, signal, isFetcher).then((result)=>{\n                if (result) {\n                    results[index] = result || results[index];\n                }\n            });\n        }\n    }\n}\nasync function resolveDeferredData(result, signal, unwrap) {\n    if (unwrap === void 0) {\n        unwrap = false;\n    }\n    let aborted = await result.deferredData.resolveData(signal);\n    if (aborted) {\n        return;\n    }\n    if (unwrap) {\n        try {\n            return {\n                type: ResultType.data,\n                data: result.deferredData.unwrappedData\n            };\n        } catch (e) {\n            // Handle any TrackedPromise._error values encountered while unwrapping\n            return {\n                type: ResultType.error,\n                error: e\n            };\n        }\n    }\n    return {\n        type: ResultType.data,\n        data: result.deferredData.data\n    };\n}\nfunction hasNakedIndexQuery(search) {\n    return new URLSearchParams(search).getAll(\"index\").some((v)=>v === \"\");\n}\nfunction getTargetMatch(matches, location) {\n    let search = typeof location === \"string\" ? parsePath(location).search : location.search;\n    if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\n        // Return the leaf index route when index is present\n        return matches[matches.length - 1];\n    }\n    // Otherwise grab the deepest \"path contributing\" match (ignoring index and\n    // pathless layout routes)\n    let pathMatches = getPathContributingMatches(matches);\n    return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n    let { formMethod, formAction, formEncType, text, formData, json } = navigation;\n    if (!formMethod || !formAction || !formEncType) {\n        return;\n    }\n    if (text != null) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData: undefined,\n            json: undefined,\n            text\n        };\n    } else if (formData != null) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData,\n            json: undefined,\n            text: undefined\n        };\n    } else if (json !== undefined) {\n        return {\n            formMethod,\n            formAction,\n            formEncType,\n            formData: undefined,\n            json,\n            text: undefined\n        };\n    }\n}\nfunction getLoadingNavigation(location, submission) {\n    if (submission) {\n        let navigation = {\n            state: \"loading\",\n            location,\n            formMethod: submission.formMethod,\n            formAction: submission.formAction,\n            formEncType: submission.formEncType,\n            formData: submission.formData,\n            json: submission.json,\n            text: submission.text\n        };\n        return navigation;\n    } else {\n        let navigation = {\n            state: \"loading\",\n            location,\n            formMethod: undefined,\n            formAction: undefined,\n            formEncType: undefined,\n            formData: undefined,\n            json: undefined,\n            text: undefined\n        };\n        return navigation;\n    }\n}\nfunction getSubmittingNavigation(location, submission) {\n    let navigation = {\n        state: \"submitting\",\n        location,\n        formMethod: submission.formMethod,\n        formAction: submission.formAction,\n        formEncType: submission.formEncType,\n        formData: submission.formData,\n        json: submission.json,\n        text: submission.text\n    };\n    return navigation;\n}\nfunction getLoadingFetcher(submission, data) {\n    if (submission) {\n        let fetcher = {\n            state: \"loading\",\n            formMethod: submission.formMethod,\n            formAction: submission.formAction,\n            formEncType: submission.formEncType,\n            formData: submission.formData,\n            json: submission.json,\n            text: submission.text,\n            data\n        };\n        return fetcher;\n    } else {\n        let fetcher = {\n            state: \"loading\",\n            formMethod: undefined,\n            formAction: undefined,\n            formEncType: undefined,\n            formData: undefined,\n            json: undefined,\n            text: undefined,\n            data\n        };\n        return fetcher;\n    }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n    let fetcher = {\n        state: \"submitting\",\n        formMethod: submission.formMethod,\n        formAction: submission.formAction,\n        formEncType: submission.formEncType,\n        formData: submission.formData,\n        json: submission.json,\n        text: submission.text,\n        data: existingFetcher ? existingFetcher.data : undefined\n    };\n    return fetcher;\n}\nfunction getDoneFetcher(data) {\n    let fetcher = {\n        state: \"idle\",\n        formMethod: undefined,\n        formAction: undefined,\n        formEncType: undefined,\n        formData: undefined,\n        json: undefined,\n        text: undefined,\n        data\n    };\n    return fetcher;\n}\nfunction restoreAppliedTransitions(_window, transitions) {\n    try {\n        let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);\n        if (sessionPositions) {\n            let json = JSON.parse(sessionPositions);\n            for (let [k, v] of Object.entries(json || {})){\n                if (v && Array.isArray(v)) {\n                    transitions.set(k, new Set(v || []));\n                }\n            }\n        }\n    } catch (e) {\n    // no-op, use default empty object\n    }\n}\nfunction persistAppliedTransitions(_window, transitions) {\n    if (transitions.size > 0) {\n        let json = {};\n        for (let [k, v] of transitions){\n            json[k] = [\n                ...v\n            ];\n        }\n        try {\n            _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json));\n        } catch (error) {\n            warning(false, \"Failed to save applied view transitions in sessionStorage (\" + error + \").\");\n        }\n    }\n}\n//#endregion\n //# sourceMappingURL=router.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlbWl4LXJ1bi9yb3V0ZXIvZGlzdC9yb3V0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7OztDQVNDLEdBQ0QsU0FBU0E7SUFDUEEsV0FBV0MsT0FBT0MsTUFBTSxHQUFHRCxPQUFPQyxNQUFNLENBQUNDLElBQUksS0FBSyxTQUFVQyxNQUFNO1FBQ2hFLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7WUFDekMsSUFBSUcsU0FBU0YsU0FBUyxDQUFDRCxFQUFFO1lBQ3pCLElBQUssSUFBSUksT0FBT0QsT0FBUTtnQkFDdEIsSUFBSVAsT0FBT1MsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osUUFBUUMsTUFBTTtvQkFDckRMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7Z0JBQzNCO1lBQ0Y7UUFDRjtRQUNBLE9BQU9MO0lBQ1Q7SUFDQSxPQUFPSixTQUFTYSxLQUFLLENBQUMsSUFBSSxFQUFFUDtBQUM5QjtBQUVBLGdGQUFnRjtBQUNoRiw2QkFBNkI7QUFDN0IsZ0ZBQWdGO0FBQ2hGOztDQUVDLEdBQ0QsSUFBSVE7QUFDSCxVQUFVQSxNQUFNO0lBQ2Y7Ozs7OztHQU1DLEdBQ0RBLE1BQU0sQ0FBQyxNQUFNLEdBQUc7SUFDaEI7Ozs7R0FJQyxHQUNEQSxNQUFNLENBQUMsT0FBTyxHQUFHO0lBQ2pCOzs7R0FHQyxHQUNEQSxNQUFNLENBQUMsVUFBVSxHQUFHO0FBQ3RCLEdBQUdBLFVBQVdBLENBQUFBLFNBQVMsQ0FBQztBQUN4QixNQUFNQyxvQkFBb0I7QUFDMUI7OztDQUdDLEdBQ0QsU0FBU0Msb0JBQW9CQyxPQUFPO0lBQ2xDLElBQUlBLFlBQVksS0FBSyxHQUFHO1FBQ3RCQSxVQUFVLENBQUM7SUFDYjtJQUNBLElBQUksRUFDRkMsaUJBQWlCO1FBQUM7S0FBSSxFQUN0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RUFBRSxJQUFJblQsT0FBT29CLE9BQU8sQ0FBQ2dQLFFBQVEsQ0FBQyxHQUFJO2dCQUM3QyxJQUFJK0MsS0FBS2hDLE1BQU1DLE9BQU8sQ0FBQytCLElBQUk7b0JBQ3pCaVgsWUFBWXpaLEdBQUcsQ0FBQ3lDLEdBQUcsSUFBSTVMLElBQUkyTCxLQUFLLEVBQUU7Z0JBQ3BDO1lBQ0Y7UUFDRjtJQUNGLEVBQUUsT0FBT3JOLEdBQUc7SUFDVixrQ0FBa0M7SUFDcEM7QUFDRjtBQUNBLFNBQVNrVSwwQkFBMEJtUSxPQUFPLEVBQUVDLFdBQVc7SUFDckQsSUFBSUEsWUFBWTdXLElBQUksR0FBRyxHQUFHO1FBQ3hCLElBQUluRCxPQUFPLENBQUM7UUFDWixLQUFLLElBQUksQ0FBQ2dELEdBQUdELEVBQUUsSUFBSWlYLFlBQWE7WUFDOUJoYSxJQUFJLENBQUNnRCxFQUFFLEdBQUc7bUJBQUlEO2FBQUU7UUFDbEI7UUFDQSxJQUFJO1lBQ0ZnWCxRQUFRRyxjQUFjLENBQUNFLE9BQU8sQ0FBQzVVLHlCQUF5QmxULEtBQUtDLFNBQVMsQ0FBQ3lOO1FBQ3pFLEVBQUUsT0FBT3BKLE9BQU87WUFDZHhFLFFBQVEsT0FBTyxnRUFBZ0V3RSxRQUFRO1FBQ3pGO0lBQ0Y7QUFDRjtBQUNBLFlBQVk7QUFFNHdCLENBQ3h4QixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tYXJpbmFtay8uL25vZGVfbW9kdWxlcy9AcmVtaXgtcnVuL3JvdXRlci9kaXN0L3JvdXRlci5qcz81MDM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQHJlbWl4LXJ1bi9yb3V0ZXIgdjEuMTMuMVxuICpcbiAqIENvcHlyaWdodCAoYykgUmVtaXggU29mdHdhcmUgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRS5tZCBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduID8gT2JqZWN0LmFzc2lnbi5iaW5kKCkgOiBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9O1xuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBUeXBlcyBhbmQgQ29uc3RhbnRzXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLyoqXG4gKiBBY3Rpb25zIHJlcHJlc2VudCB0aGUgdHlwZSBvZiBjaGFuZ2UgdG8gYSBsb2NhdGlvbiB2YWx1ZS5cbiAqL1xudmFyIEFjdGlvbjtcbihmdW5jdGlvbiAoQWN0aW9uKSB7XG4gIC8qKlxuICAgKiBBIFBPUCBpbmRpY2F0ZXMgYSBjaGFuZ2UgdG8gYW4gYXJiaXRyYXJ5IGluZGV4IGluIHRoZSBoaXN0b3J5IHN0YWNrLCBzdWNoXG4gICAqIGFzIGEgYmFjayBvciBmb3J3YXJkIG5hdmlnYXRpb24uIEl0IGRvZXMgbm90IGRlc2NyaWJlIHRoZSBkaXJlY3Rpb24gb2YgdGhlXG4gICAqIG5hdmlnYXRpb24sIG9ubHkgdGhhdCB0aGUgY3VycmVudCBpbmRleCBjaGFuZ2VkLlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGlzIHRoZSBkZWZhdWx0IGFjdGlvbiBmb3IgbmV3bHkgY3JlYXRlZCBoaXN0b3J5IG9iamVjdHMuXG4gICAqL1xuICBBY3Rpb25bXCJQb3BcIl0gPSBcIlBPUFwiO1xuICAvKipcbiAgICogQSBQVVNIIGluZGljYXRlcyBhIG5ldyBlbnRyeSBiZWluZyBhZGRlZCB0byB0aGUgaGlzdG9yeSBzdGFjaywgc3VjaCBhcyB3aGVuXG4gICAqIGEgbGluayBpcyBjbGlja2VkIGFuZCBhIG5ldyBwYWdlIGxvYWRzLiBXaGVuIHRoaXMgaGFwcGVucywgYWxsIHN1YnNlcXVlbnRcbiAgICogZW50cmllcyBpbiB0aGUgc3RhY2sgYXJlIGxvc3QuXG4gICAqL1xuICBBY3Rpb25bXCJQdXNoXCJdID0gXCJQVVNIXCI7XG4gIC8qKlxuICAgKiBBIFJFUExBQ0UgaW5kaWNhdGVzIHRoZSBlbnRyeSBhdCB0aGUgY3VycmVudCBpbmRleCBpbiB0aGUgaGlzdG9yeSBzdGFja1xuICAgKiBiZWluZyByZXBsYWNlZCBieSBhIG5ldyBvbmUuXG4gICAqL1xuICBBY3Rpb25bXCJSZXBsYWNlXCJdID0gXCJSRVBMQUNFXCI7XG59KShBY3Rpb24gfHwgKEFjdGlvbiA9IHt9KSk7XG5jb25zdCBQb3BTdGF0ZUV2ZW50VHlwZSA9IFwicG9wc3RhdGVcIjtcbi8qKlxuICogTWVtb3J5IGhpc3Rvcnkgc3RvcmVzIHRoZSBjdXJyZW50IGxvY2F0aW9uIGluIG1lbW9yeS4gSXQgaXMgZGVzaWduZWQgZm9yIHVzZVxuICogaW4gc3RhdGVmdWwgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRzIGxpa2UgdGVzdHMgYW5kIFJlYWN0IE5hdGl2ZS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgbGV0IHtcbiAgICBpbml0aWFsRW50cmllcyA9IFtcIi9cIl0sXG4gICAgaW5pdGlhbEluZGV4LFxuICAgIHY1Q29tcGF0ID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGxldCBlbnRyaWVzOyAvLyBEZWNsYXJlIHNvIHdlIGNhbiBhY2Nlc3MgZnJvbSBjcmVhdGVNZW1vcnlMb2NhdGlvblxuICBlbnRyaWVzID0gaW5pdGlhbEVudHJpZXMubWFwKChlbnRyeSwgaW5kZXgpID0+IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKGVudHJ5LCB0eXBlb2YgZW50cnkgPT09IFwic3RyaW5nXCIgPyBudWxsIDogZW50cnkuc3RhdGUsIGluZGV4ID09PSAwID8gXCJkZWZhdWx0XCIgOiB1bmRlZmluZWQpKTtcbiAgbGV0IGluZGV4ID0gY2xhbXBJbmRleChpbml0aWFsSW5kZXggPT0gbnVsbCA/IGVudHJpZXMubGVuZ3RoIC0gMSA6IGluaXRpYWxJbmRleCk7XG4gIGxldCBhY3Rpb24gPSBBY3Rpb24uUG9wO1xuICBsZXQgbGlzdGVuZXIgPSBudWxsO1xuICBmdW5jdGlvbiBjbGFtcEluZGV4KG4pIHtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobiwgMCksIGVudHJpZXMubGVuZ3RoIC0gMSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xuICAgIHJldHVybiBlbnRyaWVzW2luZGV4XTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVNZW1vcnlMb2NhdGlvbih0bywgc3RhdGUsIGtleSkge1xuICAgIGlmIChzdGF0ZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzdGF0ZSA9IG51bGw7XG4gICAgfVxuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKGVudHJpZXMgPyBnZXRDdXJyZW50TG9jYXRpb24oKS5wYXRobmFtZSA6IFwiL1wiLCB0bywgc3RhdGUsIGtleSk7XG4gICAgd2FybmluZyhsb2NhdGlvbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09IFwiL1wiLCBcInJlbGF0aXZlIHBhdGhuYW1lcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBtZW1vcnkgaGlzdG9yeTogXCIgKyBKU09OLnN0cmluZ2lmeSh0bykpO1xuICAgIHJldHVybiBsb2NhdGlvbjtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVIcmVmKHRvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSB7XG4gICAgZ2V0IGluZGV4KCkge1xuICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH0sXG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0Q3VycmVudExvY2F0aW9uKCk7XG4gICAgfSxcbiAgICBjcmVhdGVIcmVmLFxuICAgIGNyZWF0ZVVSTCh0bykge1xuICAgICAgcmV0dXJuIG5ldyBVUkwoY3JlYXRlSHJlZih0byksIFwiaHR0cDovL2xvY2FsaG9zdFwiKTtcbiAgICB9LFxuICAgIGVuY29kZUxvY2F0aW9uKHRvKSB7XG4gICAgICBsZXQgcGF0aCA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0bztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGhuYW1lOiBwYXRoLnBhdGhuYW1lIHx8IFwiXCIsXG4gICAgICAgIHNlYXJjaDogcGF0aC5zZWFyY2ggfHwgXCJcIixcbiAgICAgICAgaGFzaDogcGF0aC5oYXNoIHx8IFwiXCJcbiAgICAgIH07XG4gICAgfSxcbiAgICBwdXNoKHRvLCBzdGF0ZSkge1xuICAgICAgYWN0aW9uID0gQWN0aW9uLlB1c2g7XG4gICAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTWVtb3J5TG9jYXRpb24odG8sIHN0YXRlKTtcbiAgICAgIGluZGV4ICs9IDE7XG4gICAgICBlbnRyaWVzLnNwbGljZShpbmRleCwgZW50cmllcy5sZW5ndGgsIG5leHRMb2NhdGlvbik7XG4gICAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgICAgbGlzdGVuZXIoe1xuICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICAgIGRlbHRhOiAxXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVwbGFjZSh0bywgc3RhdGUpIHtcbiAgICAgIGFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGNyZWF0ZU1lbW9yeUxvY2F0aW9uKHRvLCBzdGF0ZSk7XG4gICAgICBlbnRyaWVzW2luZGV4XSA9IG5leHRMb2NhdGlvbjtcbiAgICAgIGlmICh2NUNvbXBhdCAmJiBsaXN0ZW5lcikge1xuICAgICAgICBsaXN0ZW5lcih7XG4gICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb24sXG4gICAgICAgICAgZGVsdGE6IDBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnbyhkZWx0YSkge1xuICAgICAgYWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgICAgIGxldCBuZXh0SW5kZXggPSBjbGFtcEluZGV4KGluZGV4ICsgZGVsdGEpO1xuICAgICAgbGV0IG5leHRMb2NhdGlvbiA9IGVudHJpZXNbbmV4dEluZGV4XTtcbiAgICAgIGluZGV4ID0gbmV4dEluZGV4O1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgbG9jYXRpb246IG5leHRMb2NhdGlvbixcbiAgICAgICAgICBkZWx0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGxpc3Rlbihmbikge1xuICAgICAgbGlzdGVuZXIgPSBmbjtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGxpc3RlbmVyID0gbnVsbDtcbiAgICAgIH07XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGlzdG9yeTtcbn1cbi8qKlxuICogQnJvd3NlciBoaXN0b3J5IHN0b3JlcyB0aGUgbG9jYXRpb24gaW4gcmVndWxhciBVUkxzLiBUaGlzIGlzIHRoZSBzdGFuZGFyZCBmb3JcbiAqIG1vc3Qgd2ViIGFwcHMsIGJ1dCBpdCByZXF1aXJlcyBzb21lIGNvbmZpZ3VyYXRpb24gb24gdGhlIHNlcnZlciB0byBlbnN1cmUgeW91XG4gKiBzZXJ2ZSB0aGUgc2FtZSBhcHAgYXQgbXVsdGlwbGUgVVJMcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vaGlzdG9yeS90cmVlL21haW4vZG9jcy9hcGktcmVmZXJlbmNlLm1kI2NyZWF0ZWJyb3dzZXJoaXN0b3J5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJyb3dzZXJIaXN0b3J5KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVCcm93c2VyTG9jYXRpb24od2luZG93LCBnbG9iYWxIaXN0b3J5KSB7XG4gICAgbGV0IHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgc2VhcmNoLFxuICAgICAgaGFzaFxuICAgIH0gPSB3aW5kb3cubG9jYXRpb247XG4gICAgcmV0dXJuIGNyZWF0ZUxvY2F0aW9uKFwiXCIsIHtcbiAgICAgIHBhdGhuYW1lLFxuICAgICAgc2VhcmNoLFxuICAgICAgaGFzaFxuICAgIH0sXG4gICAgLy8gc3RhdGUgZGVmYXVsdHMgdG8gYG51bGxgIGJlY2F1c2UgYHdpbmRvdy5oaXN0b3J5LnN0YXRlYCBkb2VzXG4gICAgZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLnVzciB8fCBudWxsLCBnbG9iYWxIaXN0b3J5LnN0YXRlICYmIGdsb2JhbEhpc3Rvcnkuc3RhdGUua2V5IHx8IFwiZGVmYXVsdFwiKTtcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVCcm93c2VySHJlZih3aW5kb3csIHRvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gIH1cbiAgcmV0dXJuIGdldFVybEJhc2VkSGlzdG9yeShjcmVhdGVCcm93c2VyTG9jYXRpb24sIGNyZWF0ZUJyb3dzZXJIcmVmLCBudWxsLCBvcHRpb25zKTtcbn1cbi8qKlxuICogSGFzaCBoaXN0b3J5IHN0b3JlcyB0aGUgbG9jYXRpb24gaW4gd2luZG93LmxvY2F0aW9uLmhhc2guIFRoaXMgbWFrZXMgaXQgaWRlYWxcbiAqIGZvciBzaXR1YXRpb25zIHdoZXJlIHlvdSBkb24ndCB3YW50IHRvIHNlbmQgdGhlIGxvY2F0aW9uIHRvIHRoZSBzZXJ2ZXIgZm9yXG4gKiBzb21lIHJlYXNvbiwgZWl0aGVyIGJlY2F1c2UgeW91IGRvIGNhbm5vdCBjb25maWd1cmUgaXQgb3IgdGhlIFVSTCBzcGFjZSBpc1xuICogcmVzZXJ2ZWQgZm9yIHNvbWV0aGluZyBlbHNlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3JlbWl4LXJ1bi9oaXN0b3J5L3RyZWUvbWFpbi9kb2NzL2FwaS1yZWZlcmVuY2UubWQjY3JlYXRlaGFzaGhpc3RvcnlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSGFzaEhpc3Rvcnkob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZUhhc2hMb2NhdGlvbih3aW5kb3csIGdsb2JhbEhpc3RvcnkpIHtcbiAgICBsZXQge1xuICAgICAgcGF0aG5hbWUgPSBcIi9cIixcbiAgICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgICBoYXNoID0gXCJcIlxuICAgIH0gPSBwYXJzZVBhdGgod2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyKDEpKTtcbiAgICAvLyBIYXNoIFVSTCBzaG91bGQgYWx3YXlzIGhhdmUgYSBsZWFkaW5nIC8ganVzdCBsaWtlIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZVxuICAgIC8vIGRvZXMsIHNvIGlmIGFuIGFwcCBlbmRzIHVwIGF0IGEgcm91dGUgbGlrZSAvI3NvbWV0aGluZyB0aGVuIHdlIGFkZCBhXG4gICAgLy8gbGVhZGluZyBzbGFzaCBzbyBhbGwgb2Ygb3VyIHBhdGgtbWF0Y2hpbmcgYmVoYXZlcyB0aGUgc2FtZSBhcyBpZiBpdCB3b3VsZFxuICAgIC8vIGluIGEgYnJvd3NlciByb3V0ZXIuICBUaGlzIGlzIHBhcnRpY3VsYXJseSBpbXBvcnRhbnQgd2hlbiB0aGVyZSBleGlzdHMgYVxuICAgIC8vIHJvb3Qgc3BsYXQgcm91dGUgKDxSb3V0ZSBwYXRoPVwiKlwiPikgc2luY2UgdGhhdCBtYXRjaGVzIGludGVybmFsbHkgYWdhaW5zdFxuICAgIC8vIFwiLypcIiBhbmQgd2UnZCBleHBlY3QgLyNzb21ldGhpbmcgdG8gNDA0IGluIGEgaGFzaCByb3V0ZXIgYXBwLlxuICAgIGlmICghcGF0aG5hbWUuc3RhcnRzV2l0aChcIi9cIikgJiYgIXBhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuXCIpKSB7XG4gICAgICBwYXRobmFtZSA9IFwiL1wiICsgcGF0aG5hbWU7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVMb2NhdGlvbihcIlwiLCB7XG4gICAgICBwYXRobmFtZSxcbiAgICAgIHNlYXJjaCxcbiAgICAgIGhhc2hcbiAgICB9LFxuICAgIC8vIHN0YXRlIGRlZmF1bHRzIHRvIGBudWxsYCBiZWNhdXNlIGB3aW5kb3cuaGlzdG9yeS5zdGF0ZWAgZG9lc1xuICAgIGdsb2JhbEhpc3Rvcnkuc3RhdGUgJiYgZ2xvYmFsSGlzdG9yeS5zdGF0ZS51c3IgfHwgbnVsbCwgZ2xvYmFsSGlzdG9yeS5zdGF0ZSAmJiBnbG9iYWxIaXN0b3J5LnN0YXRlLmtleSB8fCBcImRlZmF1bHRcIik7XG4gIH1cbiAgZnVuY3Rpb24gY3JlYXRlSGFzaEhyZWYod2luZG93LCB0bykge1xuICAgIGxldCBiYXNlID0gd2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJiYXNlXCIpO1xuICAgIGxldCBocmVmID0gXCJcIjtcbiAgICBpZiAoYmFzZSAmJiBiYXNlLmdldEF0dHJpYnV0ZShcImhyZWZcIikpIHtcbiAgICAgIGxldCB1cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICAgIGxldCBoYXNoSW5kZXggPSB1cmwuaW5kZXhPZihcIiNcIik7XG4gICAgICBocmVmID0gaGFzaEluZGV4ID09PSAtMSA/IHVybCA6IHVybC5zbGljZSgwLCBoYXNoSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gaHJlZiArIFwiI1wiICsgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0bykpO1xuICB9XG4gIGZ1bmN0aW9uIHZhbGlkYXRlSGFzaExvY2F0aW9uKGxvY2F0aW9uLCB0bykge1xuICAgIHdhcm5pbmcobG9jYXRpb24ucGF0aG5hbWUuY2hhckF0KDApID09PSBcIi9cIiwgXCJyZWxhdGl2ZSBwYXRobmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gaGFzaCBoaXN0b3J5LnB1c2goXCIgKyBKU09OLnN0cmluZ2lmeSh0bykgKyBcIilcIik7XG4gIH1cbiAgcmV0dXJuIGdldFVybEJhc2VkSGlzdG9yeShjcmVhdGVIYXNoTG9jYXRpb24sIGNyZWF0ZUhhc2hIcmVmLCB2YWxpZGF0ZUhhc2hMb2NhdGlvbiwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiBpbnZhcmlhbnQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKHZhbHVlID09PSBmYWxzZSB8fCB2YWx1ZSA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm5pbmcoY29uZCwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmQpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIHRyeSB7XG4gICAgICAvLyBXZWxjb21lIHRvIGRlYnVnZ2luZyBoaXN0b3J5IVxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2UsIHNvIHlvdSBjYW4gbW9yZSBlYXNpbHlcbiAgICAgIC8vIGZpbmQgdGhlIHNvdXJjZSBmb3IgYSB3YXJuaW5nIHRoYXQgYXBwZWFycyBpbiB0aGUgY29uc29sZSBieVxuICAgICAgLy8gZW5hYmxpbmcgXCJwYXVzZSBvbiBleGNlcHRpb25zXCIgaW4geW91ciBKYXZhU2NyaXB0IGRlYnVnZ2VyLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIsIDgpO1xufVxuLyoqXG4gKiBGb3IgYnJvd3Nlci1iYXNlZCBoaXN0b3JpZXMsIHdlIGNvbWJpbmUgdGhlIHN0YXRlIGFuZCBrZXkgaW50byBhbiBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCkge1xuICByZXR1cm4ge1xuICAgIHVzcjogbG9jYXRpb24uc3RhdGUsXG4gICAga2V5OiBsb2NhdGlvbi5rZXksXG4gICAgaWR4OiBpbmRleFxuICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgTG9jYXRpb24gb2JqZWN0IHdpdGggYSB1bmlxdWUga2V5IGZyb20gdGhlIGdpdmVuIFBhdGhcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9jYXRpb24oY3VycmVudCwgdG8sIHN0YXRlLCBrZXkpIHtcbiAgaWYgKHN0YXRlID09PSB2b2lkIDApIHtcbiAgICBzdGF0ZSA9IG51bGw7XG4gIH1cbiAgbGV0IGxvY2F0aW9uID0gX2V4dGVuZHMoe1xuICAgIHBhdGhuYW1lOiB0eXBlb2YgY3VycmVudCA9PT0gXCJzdHJpbmdcIiA/IGN1cnJlbnQgOiBjdXJyZW50LnBhdGhuYW1lLFxuICAgIHNlYXJjaDogXCJcIixcbiAgICBoYXNoOiBcIlwiXG4gIH0sIHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykgOiB0bywge1xuICAgIHN0YXRlLFxuICAgIC8vIFRPRE86IFRoaXMgY291bGQgYmUgY2xlYW5lZCB1cC4gIHB1c2gvcmVwbGFjZSBzaG91bGQgcHJvYmFibHkganVzdCB0YWtlXG4gICAgLy8gZnVsbCBMb2NhdGlvbnMgbm93IGFuZCBhdm9pZCB0aGUgbmVlZCB0byBydW4gdGhyb3VnaCB0aGlzIGZsb3cgYXQgYWxsXG4gICAgLy8gQnV0IHRoYXQncyBhIHByZXR0eSBiaWcgcmVmYWN0b3IgdG8gdGhlIGN1cnJlbnQgdGVzdCBzdWl0ZSBzbyBnb2luZyB0b1xuICAgIC8vIGtlZXAgYXMgaXMgZm9yIHRoZSB0aW1lIGJlaW5nIGFuZCBqdXN0IGxldCBhbnkgaW5jb21pbmcga2V5cyB0YWtlIHByZWNlZGVuY2VcbiAgICBrZXk6IHRvICYmIHRvLmtleSB8fCBrZXkgfHwgY3JlYXRlS2V5KClcbiAgfSk7XG4gIHJldHVybiBsb2NhdGlvbjtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmluZyBVUkwgcGF0aCBmcm9tIHRoZSBnaXZlbiBwYXRobmFtZSwgc2VhcmNoLCBhbmQgaGFzaCBjb21wb25lbnRzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXRoKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBwYXRobmFtZSA9IFwiL1wiLFxuICAgIHNlYXJjaCA9IFwiXCIsXG4gICAgaGFzaCA9IFwiXCJcbiAgfSA9IF9yZWY7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoICE9PSBcIj9cIikgcGF0aG5hbWUgKz0gc2VhcmNoLmNoYXJBdCgwKSA9PT0gXCI/XCIgPyBzZWFyY2ggOiBcIj9cIiArIHNlYXJjaDtcbiAgaWYgKGhhc2ggJiYgaGFzaCAhPT0gXCIjXCIpIHBhdGhuYW1lICs9IGhhc2guY2hhckF0KDApID09PSBcIiNcIiA/IGhhc2ggOiBcIiNcIiArIGhhc2g7XG4gIHJldHVybiBwYXRobmFtZTtcbn1cbi8qKlxuICogUGFyc2VzIGEgc3RyaW5nIFVSTCBwYXRoIGludG8gaXRzIHNlcGFyYXRlIHBhdGhuYW1lLCBzZWFyY2gsIGFuZCBoYXNoIGNvbXBvbmVudHMuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIGxldCBwYXJzZWRQYXRoID0ge307XG4gIGlmIChwYXRoKSB7XG4gICAgbGV0IGhhc2hJbmRleCA9IHBhdGguaW5kZXhPZihcIiNcIik7XG4gICAgaWYgKGhhc2hJbmRleCA+PSAwKSB7XG4gICAgICBwYXJzZWRQYXRoLmhhc2ggPSBwYXRoLnN1YnN0cihoYXNoSW5kZXgpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIGhhc2hJbmRleCk7XG4gICAgfVxuICAgIGxldCBzZWFyY2hJbmRleCA9IHBhdGguaW5kZXhPZihcIj9cIik7XG4gICAgaWYgKHNlYXJjaEluZGV4ID49IDApIHtcbiAgICAgIHBhcnNlZFBhdGguc2VhcmNoID0gcGF0aC5zdWJzdHIoc2VhcmNoSW5kZXgpO1xuICAgICAgcGF0aCA9IHBhdGguc3Vic3RyKDAsIHNlYXJjaEluZGV4KTtcbiAgICB9XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHBhcnNlZFBhdGgucGF0aG5hbWUgPSBwYXRoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyc2VkUGF0aDtcbn1cbmZ1bmN0aW9uIGdldFVybEJhc2VkSGlzdG9yeShnZXRMb2NhdGlvbiwgY3JlYXRlSHJlZiwgdmFsaWRhdGVMb2NhdGlvbiwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGxldCB7XG4gICAgd2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcsXG4gICAgdjVDb21wYXQgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgbGV0IGdsb2JhbEhpc3RvcnkgPSB3aW5kb3cuaGlzdG9yeTtcbiAgbGV0IGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gIGxldCBsaXN0ZW5lciA9IG51bGw7XG4gIGxldCBpbmRleCA9IGdldEluZGV4KCk7XG4gIC8vIEluZGV4IHNob3VsZCBvbmx5IGJlIG51bGwgd2hlbiB3ZSBpbml0aWFsaXplLiBJZiBub3QsIGl0J3MgYmVjYXVzZSB0aGVcbiAgLy8gdXNlciBjYWxsZWQgaGlzdG9yeS5wdXNoU3RhdGUgb3IgaGlzdG9yeS5yZXBsYWNlU3RhdGUgZGlyZWN0bHksIGluIHdoaWNoXG4gIC8vIGNhc2Ugd2Ugc2hvdWxkIGxvZyBhIHdhcm5pbmcgYXMgaXQgd2lsbCByZXN1bHQgaW4gYnVncy5cbiAgaWYgKGluZGV4ID09IG51bGwpIHtcbiAgICBpbmRleCA9IDA7XG4gICAgZ2xvYmFsSGlzdG9yeS5yZXBsYWNlU3RhdGUoX2V4dGVuZHMoe30sIGdsb2JhbEhpc3Rvcnkuc3RhdGUsIHtcbiAgICAgIGlkeDogaW5kZXhcbiAgICB9KSwgXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SW5kZXgoKSB7XG4gICAgbGV0IHN0YXRlID0gZ2xvYmFsSGlzdG9yeS5zdGF0ZSB8fCB7XG4gICAgICBpZHg6IG51bGxcbiAgICB9O1xuICAgIHJldHVybiBzdGF0ZS5pZHg7XG4gIH1cbiAgZnVuY3Rpb24gaGFuZGxlUG9wKCkge1xuICAgIGFjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gICAgbGV0IG5leHRJbmRleCA9IGdldEluZGV4KCk7XG4gICAgbGV0IGRlbHRhID0gbmV4dEluZGV4ID09IG51bGwgPyBudWxsIDogbmV4dEluZGV4IC0gaW5kZXg7XG4gICAgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBsaXN0ZW5lcih7XG4gICAgICAgIGFjdGlvbixcbiAgICAgICAgbG9jYXRpb246IGhpc3RvcnkubG9jYXRpb24sXG4gICAgICAgIGRlbHRhXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHVzaCh0bywgc3RhdGUpIHtcbiAgICBhY3Rpb24gPSBBY3Rpb24uUHVzaDtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihoaXN0b3J5LmxvY2F0aW9uLCB0bywgc3RhdGUpO1xuICAgIGlmICh2YWxpZGF0ZUxvY2F0aW9uKSB2YWxpZGF0ZUxvY2F0aW9uKGxvY2F0aW9uLCB0byk7XG4gICAgaW5kZXggPSBnZXRJbmRleCgpICsgMTtcbiAgICBsZXQgaGlzdG9yeVN0YXRlID0gZ2V0SGlzdG9yeVN0YXRlKGxvY2F0aW9uLCBpbmRleCk7XG4gICAgbGV0IHVybCA9IGhpc3RvcnkuY3JlYXRlSHJlZihsb2NhdGlvbik7XG4gICAgLy8gdHJ5Li4uY2F0Y2ggYmVjYXVzZSBpT1MgbGltaXRzIHVzIHRvIDEwMCBwdXNoU3RhdGUgY2FsbHMgOi9cbiAgICB0cnkge1xuICAgICAgZ2xvYmFsSGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCBcIlwiLCB1cmwpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAvLyBJZiB0aGUgZXhjZXB0aW9uIGlzIGJlY2F1c2UgYHN0YXRlYCBjYW4ndCBiZSBzZXJpYWxpemVkLCBsZXQgdGhhdCB0aHJvd1xuICAgICAgLy8gb3V0d2FyZHMganVzdCBsaWtlIGEgcmVwbGFjZSBjYWxsIHdvdWxkIHNvIHRoZSBkZXYga25vd3MgdGhlIGNhdXNlXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9uYXYtaGlzdG9yeS1hcGlzLmh0bWwjc2hhcmVkLWhpc3RvcnktcHVzaC9yZXBsYWNlLXN0YXRlLXN0ZXBzXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zdHJ1Y3R1cmVkLWRhdGEuaHRtbCNzdHJ1Y3R1cmVkc2VyaWFsaXplaW50ZXJuYWxcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIERPTUV4Y2VwdGlvbiAmJiBlcnJvci5uYW1lID09PSBcIkRhdGFDbG9uZUVycm9yXCIpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgICAvLyBUaGV5IGFyZSBnb2luZyB0byBsb3NlIHN0YXRlIGhlcmUsIGJ1dCB0aGVyZSBpcyBubyByZWFsXG4gICAgICAvLyB3YXkgdG8gd2FybiB0aGVtIGFib3V0IGl0IHNpbmNlIHRoZSBwYWdlIHdpbGwgcmVmcmVzaC4uLlxuICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih1cmwpO1xuICAgIH1cbiAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbixcbiAgICAgICAgZGVsdGE6IDFcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiByZXBsYWNlKHRvLCBzdGF0ZSkge1xuICAgIGFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKGhpc3RvcnkubG9jYXRpb24sIHRvLCBzdGF0ZSk7XG4gICAgaWYgKHZhbGlkYXRlTG9jYXRpb24pIHZhbGlkYXRlTG9jYXRpb24obG9jYXRpb24sIHRvKTtcbiAgICBpbmRleCA9IGdldEluZGV4KCk7XG4gICAgbGV0IGhpc3RvcnlTdGF0ZSA9IGdldEhpc3RvcnlTdGF0ZShsb2NhdGlvbiwgaW5kZXgpO1xuICAgIGxldCB1cmwgPSBoaXN0b3J5LmNyZWF0ZUhyZWYobG9jYXRpb24pO1xuICAgIGdsb2JhbEhpc3RvcnkucmVwbGFjZVN0YXRlKGhpc3RvcnlTdGF0ZSwgXCJcIiwgdXJsKTtcbiAgICBpZiAodjVDb21wYXQgJiYgbGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVyKHtcbiAgICAgICAgYWN0aW9uLFxuICAgICAgICBsb2NhdGlvbjogaGlzdG9yeS5sb2NhdGlvbixcbiAgICAgICAgZGVsdGE6IDBcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVVUkwodG8pIHtcbiAgICAvLyB3aW5kb3cubG9jYXRpb24ub3JpZ2luIGlzIFwibnVsbFwiICh0aGUgbGl0ZXJhbCBzdHJpbmcgdmFsdWUpIGluIEZpcmVmb3hcbiAgICAvLyB1bmRlciBjZXJ0YWluIGNvbmRpdGlvbnMsIG5vdGFibHkgd2hlbiBzZXJ2aW5nIGZyb20gYSBsb2NhbCBIVE1MIGZpbGVcbiAgICAvLyBTZWUgaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9ODc4Mjk3XG4gICAgbGV0IGJhc2UgPSB3aW5kb3cubG9jYXRpb24ub3JpZ2luICE9PSBcIm51bGxcIiA/IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gOiB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICBsZXQgaHJlZiA9IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHRvIDogY3JlYXRlUGF0aCh0byk7XG4gICAgaW52YXJpYW50KGJhc2UsIFwiTm8gd2luZG93LmxvY2F0aW9uLihvcmlnaW58aHJlZikgYXZhaWxhYmxlIHRvIGNyZWF0ZSBVUkwgZm9yIGhyZWY6IFwiICsgaHJlZik7XG4gICAgcmV0dXJuIG5ldyBVUkwoaHJlZiwgYmFzZSk7XG4gIH1cbiAgbGV0IGhpc3RvcnkgPSB7XG4gICAgZ2V0IGFjdGlvbigpIHtcbiAgICAgIHJldHVybiBhY3Rpb247XG4gICAgfSxcbiAgICBnZXQgbG9jYXRpb24oKSB7XG4gICAgICByZXR1cm4gZ2V0TG9jYXRpb24od2luZG93LCBnbG9iYWxIaXN0b3J5KTtcbiAgICB9LFxuICAgIGxpc3Rlbihmbikge1xuICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkEgaGlzdG9yeSBvbmx5IGFjY2VwdHMgb25lIGFjdGl2ZSBsaXN0ZW5lclwiKTtcbiAgICAgIH1cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnRUeXBlLCBoYW5kbGVQb3ApO1xuICAgICAgbGlzdGVuZXIgPSBmbjtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFBvcFN0YXRlRXZlbnRUeXBlLCBoYW5kbGVQb3ApO1xuICAgICAgICBsaXN0ZW5lciA9IG51bGw7XG4gICAgICB9O1xuICAgIH0sXG4gICAgY3JlYXRlSHJlZih0bykge1xuICAgICAgcmV0dXJuIGNyZWF0ZUhyZWYod2luZG93LCB0byk7XG4gICAgfSxcbiAgICBjcmVhdGVVUkwsXG4gICAgZW5jb2RlTG9jYXRpb24odG8pIHtcbiAgICAgIC8vIEVuY29kZSBhIExvY2F0aW9uIHRoZSBzYW1lIHdheSB3aW5kb3cubG9jYXRpb24gd291bGRcbiAgICAgIGxldCB1cmwgPSBjcmVhdGVVUkwodG8pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGF0aG5hbWU6IHVybC5wYXRobmFtZSxcbiAgICAgICAgc2VhcmNoOiB1cmwuc2VhcmNoLFxuICAgICAgICBoYXNoOiB1cmwuaGFzaFxuICAgICAgfTtcbiAgICB9LFxuICAgIHB1c2gsXG4gICAgcmVwbGFjZSxcbiAgICBnbyhuKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsSGlzdG9yeS5nbyhuKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoaXN0b3J5O1xufVxuLy8jZW5kcmVnaW9uXG5cbnZhciBSZXN1bHRUeXBlO1xuKGZ1bmN0aW9uIChSZXN1bHRUeXBlKSB7XG4gIFJlc3VsdFR5cGVbXCJkYXRhXCJdID0gXCJkYXRhXCI7XG4gIFJlc3VsdFR5cGVbXCJkZWZlcnJlZFwiXSA9IFwiZGVmZXJyZWRcIjtcbiAgUmVzdWx0VHlwZVtcInJlZGlyZWN0XCJdID0gXCJyZWRpcmVjdFwiO1xuICBSZXN1bHRUeXBlW1wiZXJyb3JcIl0gPSBcImVycm9yXCI7XG59KShSZXN1bHRUeXBlIHx8IChSZXN1bHRUeXBlID0ge30pKTtcbmNvbnN0IGltbXV0YWJsZVJvdXRlS2V5cyA9IG5ldyBTZXQoW1wibGF6eVwiLCBcImNhc2VTZW5zaXRpdmVcIiwgXCJwYXRoXCIsIFwiaWRcIiwgXCJpbmRleFwiLCBcImNoaWxkcmVuXCJdKTtcbmZ1bmN0aW9uIGlzSW5kZXhSb3V0ZShyb3V0ZSkge1xuICByZXR1cm4gcm91dGUuaW5kZXggPT09IHRydWU7XG59XG4vLyBXYWxrIHRoZSByb3V0ZSB0cmVlIGdlbmVyYXRpbmcgdW5pcXVlIElEcyB3aGVyZSBuZWNlc3NhcnksIHNvIHdlIGFyZSB3b3JraW5nXG4vLyBzb2xlbHkgd2l0aCBBZ25vc3RpY0RhdGFSb3V0ZU9iamVjdCdzIHdpdGhpbiB0aGUgUm91dGVyXG5mdW5jdGlvbiBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKHJvdXRlcywgbWFwUm91dGVQcm9wZXJ0aWVzLCBwYXJlbnRQYXRoLCBtYW5pZmVzdCkge1xuICBpZiAocGFyZW50UGF0aCA9PT0gdm9pZCAwKSB7XG4gICAgcGFyZW50UGF0aCA9IFtdO1xuICB9XG4gIGlmIChtYW5pZmVzdCA9PT0gdm9pZCAwKSB7XG4gICAgbWFuaWZlc3QgPSB7fTtcbiAgfVxuICByZXR1cm4gcm91dGVzLm1hcCgocm91dGUsIGluZGV4KSA9PiB7XG4gICAgbGV0IHRyZWVQYXRoID0gWy4uLnBhcmVudFBhdGgsIGluZGV4XTtcbiAgICBsZXQgaWQgPSB0eXBlb2Ygcm91dGUuaWQgPT09IFwic3RyaW5nXCIgPyByb3V0ZS5pZCA6IHRyZWVQYXRoLmpvaW4oXCItXCIpO1xuICAgIGludmFyaWFudChyb3V0ZS5pbmRleCAhPT0gdHJ1ZSB8fCAhcm91dGUuY2hpbGRyZW4sIFwiQ2Fubm90IHNwZWNpZnkgY2hpbGRyZW4gb24gYW4gaW5kZXggcm91dGVcIik7XG4gICAgaW52YXJpYW50KCFtYW5pZmVzdFtpZF0sIFwiRm91bmQgYSByb3V0ZSBpZCBjb2xsaXNpb24gb24gaWQgXFxcIlwiICsgaWQgKyBcIlxcXCIuICBSb3V0ZSBcIiArIFwiaWQncyBtdXN0IGJlIGdsb2JhbGx5IHVuaXF1ZSB3aXRoaW4gRGF0YSBSb3V0ZXIgdXNhZ2VzXCIpO1xuICAgIGlmIChpc0luZGV4Um91dGUocm91dGUpKSB7XG4gICAgICBsZXQgaW5kZXhSb3V0ZSA9IF9leHRlbmRzKHt9LCByb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzKHJvdXRlKSwge1xuICAgICAgICBpZFxuICAgICAgfSk7XG4gICAgICBtYW5pZmVzdFtpZF0gPSBpbmRleFJvdXRlO1xuICAgICAgcmV0dXJuIGluZGV4Um91dGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwYXRoT3JMYXlvdXRSb3V0ZSA9IF9leHRlbmRzKHt9LCByb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzKHJvdXRlKSwge1xuICAgICAgICBpZCxcbiAgICAgICAgY2hpbGRyZW46IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICBtYW5pZmVzdFtpZF0gPSBwYXRoT3JMYXlvdXRSb3V0ZTtcbiAgICAgIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgICAgICBwYXRoT3JMYXlvdXRSb3V0ZS5jaGlsZHJlbiA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMocm91dGUuY2hpbGRyZW4sIG1hcFJvdXRlUHJvcGVydGllcywgdHJlZVBhdGgsIG1hbmlmZXN0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXRoT3JMYXlvdXRSb3V0ZTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBNYXRjaGVzIHRoZSBnaXZlbiByb3V0ZXMgdG8gYSBsb2NhdGlvbiBhbmQgcmV0dXJucyB0aGUgbWF0Y2ggZGF0YS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL21hdGNoLXJvdXRlc1xuICovXG5mdW5jdGlvbiBtYXRjaFJvdXRlcyhyb3V0ZXMsIGxvY2F0aW9uQXJnLCBiYXNlbmFtZSkge1xuICBpZiAoYmFzZW5hbWUgPT09IHZvaWQgMCkge1xuICAgIGJhc2VuYW1lID0gXCIvXCI7XG4gIH1cbiAgbGV0IGxvY2F0aW9uID0gdHlwZW9mIGxvY2F0aW9uQXJnID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKGxvY2F0aW9uQXJnKSA6IGxvY2F0aW9uQXJnO1xuICBsZXQgcGF0aG5hbWUgPSBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lIHx8IFwiL1wiLCBiYXNlbmFtZSk7XG4gIGlmIChwYXRobmFtZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IGJyYW5jaGVzID0gZmxhdHRlblJvdXRlcyhyb3V0ZXMpO1xuICByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlcyk7XG4gIGxldCBtYXRjaGVzID0gbnVsbDtcbiAgZm9yIChsZXQgaSA9IDA7IG1hdGNoZXMgPT0gbnVsbCAmJiBpIDwgYnJhbmNoZXMubGVuZ3RoOyArK2kpIHtcbiAgICBtYXRjaGVzID0gbWF0Y2hSb3V0ZUJyYW5jaChicmFuY2hlc1tpXSxcbiAgICAvLyBJbmNvbWluZyBwYXRobmFtZXMgYXJlIGdlbmVyYWxseSBlbmNvZGVkIGZyb20gZWl0aGVyIHdpbmRvdy5sb2NhdGlvblxuICAgIC8vIG9yIGZyb20gcm91dGVyLm5hdmlnYXRlLCBidXQgd2Ugd2FudCB0byBtYXRjaCBhZ2FpbnN0IHRoZSB1bmVuY29kZWRcbiAgICAvLyBwYXRocyBpbiB0aGUgcm91dGUgZGVmaW5pdGlvbnMuICBNZW1vcnkgcm91dGVyIGxvY2F0aW9ucyB3b24ndCBiZVxuICAgIC8vIGVuY29kZWQgaGVyZSBidXQgdGhlcmUgYWxzbyBzaG91bGRuJ3QgYmUgYW55dGhpbmcgdG8gZGVjb2RlIHNvIHRoaXNcbiAgICAvLyBzaG91bGQgYmUgYSBzYWZlIG9wZXJhdGlvbi4gIFRoaXMgYXZvaWRzIG5lZWRpbmcgbWF0Y2hSb3V0ZXMgdG8gYmVcbiAgICAvLyBoaXN0b3J5LWF3YXJlLlxuICAgIHNhZmVseURlY29kZVVSSShwYXRobmFtZSkpO1xuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufVxuZnVuY3Rpb24gY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gobWF0Y2gsIGxvYWRlckRhdGEpIHtcbiAgbGV0IHtcbiAgICByb3V0ZSxcbiAgICBwYXRobmFtZSxcbiAgICBwYXJhbXNcbiAgfSA9IG1hdGNoO1xuICByZXR1cm4ge1xuICAgIGlkOiByb3V0ZS5pZCxcbiAgICBwYXRobmFtZSxcbiAgICBwYXJhbXMsXG4gICAgZGF0YTogbG9hZGVyRGF0YVtyb3V0ZS5pZF0sXG4gICAgaGFuZGxlOiByb3V0ZS5oYW5kbGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGZsYXR0ZW5Sb3V0ZXMocm91dGVzLCBicmFuY2hlcywgcGFyZW50c01ldGEsIHBhcmVudFBhdGgpIHtcbiAgaWYgKGJyYW5jaGVzID09PSB2b2lkIDApIHtcbiAgICBicmFuY2hlcyA9IFtdO1xuICB9XG4gIGlmIChwYXJlbnRzTWV0YSA9PT0gdm9pZCAwKSB7XG4gICAgcGFyZW50c01ldGEgPSBbXTtcbiAgfVxuICBpZiAocGFyZW50UGF0aCA9PT0gdm9pZCAwKSB7XG4gICAgcGFyZW50UGF0aCA9IFwiXCI7XG4gIH1cbiAgbGV0IGZsYXR0ZW5Sb3V0ZSA9IChyb3V0ZSwgaW5kZXgsIHJlbGF0aXZlUGF0aCkgPT4ge1xuICAgIGxldCBtZXRhID0ge1xuICAgICAgcmVsYXRpdmVQYXRoOiByZWxhdGl2ZVBhdGggPT09IHVuZGVmaW5lZCA/IHJvdXRlLnBhdGggfHwgXCJcIiA6IHJlbGF0aXZlUGF0aCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IHJvdXRlLmNhc2VTZW5zaXRpdmUgPT09IHRydWUsXG4gICAgICBjaGlsZHJlbkluZGV4OiBpbmRleCxcbiAgICAgIHJvdXRlXG4gICAgfTtcbiAgICBpZiAobWV0YS5yZWxhdGl2ZVBhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgIGludmFyaWFudChtZXRhLnJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKHBhcmVudFBhdGgpLCBcIkFic29sdXRlIHJvdXRlIHBhdGggXFxcIlwiICsgbWV0YS5yZWxhdGl2ZVBhdGggKyBcIlxcXCIgbmVzdGVkIHVuZGVyIHBhdGggXCIgKyAoXCJcXFwiXCIgKyBwYXJlbnRQYXRoICsgXCJcXFwiIGlzIG5vdCB2YWxpZC4gQW4gYWJzb2x1dGUgY2hpbGQgcm91dGUgcGF0aCBcIikgKyBcIm11c3Qgc3RhcnQgd2l0aCB0aGUgY29tYmluZWQgcGF0aCBvZiBhbGwgaXRzIHBhcmVudCByb3V0ZXMuXCIpO1xuICAgICAgbWV0YS5yZWxhdGl2ZVBhdGggPSBtZXRhLnJlbGF0aXZlUGF0aC5zbGljZShwYXJlbnRQYXRoLmxlbmd0aCk7XG4gICAgfVxuICAgIGxldCBwYXRoID0gam9pblBhdGhzKFtwYXJlbnRQYXRoLCBtZXRhLnJlbGF0aXZlUGF0aF0pO1xuICAgIGxldCByb3V0ZXNNZXRhID0gcGFyZW50c01ldGEuY29uY2F0KG1ldGEpO1xuICAgIC8vIEFkZCB0aGUgY2hpbGRyZW4gYmVmb3JlIGFkZGluZyB0aGlzIHJvdXRlIHRvIHRoZSBhcnJheSwgc28gd2UgdHJhdmVyc2UgdGhlXG4gICAgLy8gcm91dGUgdHJlZSBkZXB0aC1maXJzdCBhbmQgY2hpbGQgcm91dGVzIGFwcGVhciBiZWZvcmUgdGhlaXIgcGFyZW50cyBpblxuICAgIC8vIHRoZSBcImZsYXR0ZW5lZFwiIHZlcnNpb24uXG4gICAgaWYgKHJvdXRlLmNoaWxkcmVuICYmIHJvdXRlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGludmFyaWFudChcbiAgICAgIC8vIE91ciB0eXBlcyBrbm93IGJldHRlciwgYnV0IHJ1bnRpbWUgSlMgbWF5IG5vdCFcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIHJvdXRlLmluZGV4ICE9PSB0cnVlLCBcIkluZGV4IHJvdXRlcyBtdXN0IG5vdCBoYXZlIGNoaWxkIHJvdXRlcy4gUGxlYXNlIHJlbW92ZSBcIiArIChcImFsbCBjaGlsZCByb3V0ZXMgZnJvbSByb3V0ZSBwYXRoIFxcXCJcIiArIHBhdGggKyBcIlxcXCIuXCIpKTtcbiAgICAgIGZsYXR0ZW5Sb3V0ZXMocm91dGUuY2hpbGRyZW4sIGJyYW5jaGVzLCByb3V0ZXNNZXRhLCBwYXRoKTtcbiAgICB9XG4gICAgLy8gUm91dGVzIHdpdGhvdXQgYSBwYXRoIHNob3VsZG4ndCBldmVyIG1hdGNoIGJ5IHRoZW1zZWx2ZXMgdW5sZXNzIHRoZXkgYXJlXG4gICAgLy8gaW5kZXggcm91dGVzLCBzbyBkb24ndCBhZGQgdGhlbSB0byB0aGUgbGlzdCBvZiBwb3NzaWJsZSBicmFuY2hlcy5cbiAgICBpZiAocm91dGUucGF0aCA9PSBudWxsICYmICFyb3V0ZS5pbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBicmFuY2hlcy5wdXNoKHtcbiAgICAgIHBhdGgsXG4gICAgICBzY29yZTogY29tcHV0ZVNjb3JlKHBhdGgsIHJvdXRlLmluZGV4KSxcbiAgICAgIHJvdXRlc01ldGFcbiAgICB9KTtcbiAgfTtcbiAgcm91dGVzLmZvckVhY2goKHJvdXRlLCBpbmRleCkgPT4ge1xuICAgIHZhciBfcm91dGUkcGF0aDtcbiAgICAvLyBjb2Fyc2UtZ3JhaW4gY2hlY2sgZm9yIG9wdGlvbmFsIHBhcmFtc1xuICAgIGlmIChyb3V0ZS5wYXRoID09PSBcIlwiIHx8ICEoKF9yb3V0ZSRwYXRoID0gcm91dGUucGF0aCkgIT0gbnVsbCAmJiBfcm91dGUkcGF0aC5pbmNsdWRlcyhcIj9cIikpKSB7XG4gICAgICBmbGF0dGVuUm91dGUocm91dGUsIGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgZXhwbG9kZWQgb2YgZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocm91dGUucGF0aCkpIHtcbiAgICAgICAgZmxhdHRlblJvdXRlKHJvdXRlLCBpbmRleCwgZXhwbG9kZWQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBicmFuY2hlcztcbn1cbi8qKlxuICogQ29tcHV0ZXMgYWxsIGNvbWJpbmF0aW9ucyBvZiBvcHRpb25hbCBwYXRoIHNlZ21lbnRzIGZvciBhIGdpdmVuIHBhdGgsXG4gKiBleGNsdWRpbmcgY29tYmluYXRpb25zIHRoYXQgYXJlIGFtYmlndW91cyBhbmQgb2YgbG93ZXIgcHJpb3JpdHkuXG4gKlxuICogRm9yIGV4YW1wbGUsIGAvb25lLzp0d28/L3RocmVlLzpmb3VyPy86Zml2ZT9gIGV4cGxvZGVzIHRvOlxuICogLSBgL29uZS90aHJlZWBcbiAqIC0gYC9vbmUvOnR3by90aHJlZWBcbiAqIC0gYC9vbmUvdGhyZWUvOmZvdXJgXG4gKiAtIGAvb25lL3RocmVlLzpmaXZlYFxuICogLSBgL29uZS86dHdvL3RocmVlLzpmb3VyYFxuICogLSBgL29uZS86dHdvL3RocmVlLzpmaXZlYFxuICogLSBgL29uZS90aHJlZS86Zm91ci86Zml2ZWBcbiAqIC0gYC9vbmUvOnR3by90aHJlZS86Zm91ci86Zml2ZWBcbiAqL1xuZnVuY3Rpb24gZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocGF0aCkge1xuICBsZXQgc2VnbWVudHMgPSBwYXRoLnNwbGl0KFwiL1wiKTtcbiAgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFtdO1xuICBsZXQgW2ZpcnN0LCAuLi5yZXN0XSA9IHNlZ21lbnRzO1xuICAvLyBPcHRpb25hbCBwYXRoIHNlZ21lbnRzIGFyZSBkZW5vdGVkIGJ5IGEgdHJhaWxpbmcgYD9gXG4gIGxldCBpc09wdGlvbmFsID0gZmlyc3QuZW5kc1dpdGgoXCI/XCIpO1xuICAvLyBDb21wdXRlIHRoZSBjb3JyZXNwb25kaW5nIHJlcXVpcmVkIHNlZ21lbnQ6IGBmb28/YCAtPiBgZm9vYFxuICBsZXQgcmVxdWlyZWQgPSBmaXJzdC5yZXBsYWNlKC9cXD8kLywgXCJcIik7XG4gIGlmIChyZXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIEludGVwcmV0IGVtcHR5IHN0cmluZyBhcyBvbWl0dGluZyBhbiBvcHRpb25hbCBzZWdtZW50XG4gICAgLy8gYFtcIm9uZVwiLCBcIlwiLCBcInRocmVlXCJdYCBjb3JyZXNwb25kcyB0byBvbWl0dGluZyBgOnR3b2AgZnJvbSBgL29uZS86dHdvPy90aHJlZWAgLT4gYC9vbmUvdGhyZWVgXG4gICAgcmV0dXJuIGlzT3B0aW9uYWwgPyBbcmVxdWlyZWQsIFwiXCJdIDogW3JlcXVpcmVkXTtcbiAgfVxuICBsZXQgcmVzdEV4cGxvZGVkID0gZXhwbG9kZU9wdGlvbmFsU2VnbWVudHMocmVzdC5qb2luKFwiL1wiKSk7XG4gIGxldCByZXN1bHQgPSBbXTtcbiAgLy8gQWxsIGNoaWxkIHBhdGhzIHdpdGggdGhlIHByZWZpeC4gIERvIHRoaXMgZm9yIGFsbCBjaGlsZHJlbiBiZWZvcmUgdGhlXG4gIC8vIG9wdGlvbmFsIHZlcnNpb24gZm9yIGFsbCBjaGlsZHJlbiwgc28gd2UgZ2V0IGNvbnNpc3RlbnQgb3JkZXJpbmcgd2hlcmUgdGhlXG4gIC8vIHBhcmVudCBvcHRpb25hbCBhc3BlY3QgaXMgcHJlZmVycmVkIGFzIHJlcXVpcmVkLiAgT3RoZXJ3aXNlLCB3ZSBjYW4gZ2V0XG4gIC8vIGNoaWxkIHNlY3Rpb25zIGludGVyc3BlcnNlZCB3aGVyZSBkZWVwZXIgb3B0aW9uYWwgc2VnbWVudHMgYXJlIGhpZ2hlciB0aGFuXG4gIC8vIHBhcmVudCBvcHRpb25hbCBzZWdtZW50cywgd2hlcmUgZm9yIGV4YW1wbGUsIC86dHdvIHdvdWxkIGV4cGxvZGUgX2VhcmxpZXJfXG4gIC8vIHRoZW4gLzpvbmUuICBCeSBhbHdheXMgaW5jbHVkaW5nIHRoZSBwYXJlbnQgYXMgcmVxdWlyZWQgX2ZvciBhbGwgY2hpbGRyZW5fXG4gIC8vIGZpcnN0LCB3ZSBhdm9pZCB0aGlzIGlzc3VlXG4gIHJlc3VsdC5wdXNoKC4uLnJlc3RFeHBsb2RlZC5tYXAoc3VicGF0aCA9PiBzdWJwYXRoID09PSBcIlwiID8gcmVxdWlyZWQgOiBbcmVxdWlyZWQsIHN1YnBhdGhdLmpvaW4oXCIvXCIpKSk7XG4gIC8vIFRoZW4sIGlmIHRoaXMgaXMgYW4gb3B0aW9uYWwgdmFsdWUsIGFkZCBhbGwgY2hpbGQgdmVyc2lvbnMgd2l0aG91dFxuICBpZiAoaXNPcHRpb25hbCkge1xuICAgIHJlc3VsdC5wdXNoKC4uLnJlc3RFeHBsb2RlZCk7XG4gIH1cbiAgLy8gZm9yIGFic29sdXRlIHBhdGhzLCBlbnN1cmUgYC9gIGluc3RlYWQgb2YgZW1wdHkgc2VnbWVudFxuICByZXR1cm4gcmVzdWx0Lm1hcChleHBsb2RlZCA9PiBwYXRoLnN0YXJ0c1dpdGgoXCIvXCIpICYmIGV4cGxvZGVkID09PSBcIlwiID8gXCIvXCIgOiBleHBsb2RlZCk7XG59XG5mdW5jdGlvbiByYW5rUm91dGVCcmFuY2hlcyhicmFuY2hlcykge1xuICBicmFuY2hlcy5zb3J0KChhLCBiKSA9PiBhLnNjb3JlICE9PSBiLnNjb3JlID8gYi5zY29yZSAtIGEuc2NvcmUgLy8gSGlnaGVyIHNjb3JlIGZpcnN0XG4gIDogY29tcGFyZUluZGV4ZXMoYS5yb3V0ZXNNZXRhLm1hcChtZXRhID0+IG1ldGEuY2hpbGRyZW5JbmRleCksIGIucm91dGVzTWV0YS5tYXAobWV0YSA9PiBtZXRhLmNoaWxkcmVuSW5kZXgpKSk7XG59XG5jb25zdCBwYXJhbVJlID0gL146XFx3KyQvO1xuY29uc3QgZHluYW1pY1NlZ21lbnRWYWx1ZSA9IDM7XG5jb25zdCBpbmRleFJvdXRlVmFsdWUgPSAyO1xuY29uc3QgZW1wdHlTZWdtZW50VmFsdWUgPSAxO1xuY29uc3Qgc3RhdGljU2VnbWVudFZhbHVlID0gMTA7XG5jb25zdCBzcGxhdFBlbmFsdHkgPSAtMjtcbmNvbnN0IGlzU3BsYXQgPSBzID0+IHMgPT09IFwiKlwiO1xuZnVuY3Rpb24gY29tcHV0ZVNjb3JlKHBhdGgsIGluZGV4KSB7XG4gIGxldCBzZWdtZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICBsZXQgaW5pdGlhbFNjb3JlID0gc2VnbWVudHMubGVuZ3RoO1xuICBpZiAoc2VnbWVudHMuc29tZShpc1NwbGF0KSkge1xuICAgIGluaXRpYWxTY29yZSArPSBzcGxhdFBlbmFsdHk7XG4gIH1cbiAgaWYgKGluZGV4KSB7XG4gICAgaW5pdGlhbFNjb3JlICs9IGluZGV4Um91dGVWYWx1ZTtcbiAgfVxuICByZXR1cm4gc2VnbWVudHMuZmlsdGVyKHMgPT4gIWlzU3BsYXQocykpLnJlZHVjZSgoc2NvcmUsIHNlZ21lbnQpID0+IHNjb3JlICsgKHBhcmFtUmUudGVzdChzZWdtZW50KSA/IGR5bmFtaWNTZWdtZW50VmFsdWUgOiBzZWdtZW50ID09PSBcIlwiID8gZW1wdHlTZWdtZW50VmFsdWUgOiBzdGF0aWNTZWdtZW50VmFsdWUpLCBpbml0aWFsU2NvcmUpO1xufVxuZnVuY3Rpb24gY29tcGFyZUluZGV4ZXMoYSwgYikge1xuICBsZXQgc2libGluZ3MgPSBhLmxlbmd0aCA9PT0gYi5sZW5ndGggJiYgYS5zbGljZSgwLCAtMSkuZXZlcnkoKG4sIGkpID0+IG4gPT09IGJbaV0pO1xuICByZXR1cm4gc2libGluZ3MgP1xuICAvLyBJZiB0d28gcm91dGVzIGFyZSBzaWJsaW5ncywgd2Ugc2hvdWxkIHRyeSB0byBtYXRjaCB0aGUgZWFybGllciBzaWJsaW5nXG4gIC8vIGZpcnN0LiBUaGlzIGFsbG93cyBwZW9wbGUgdG8gaGF2ZSBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyIHRoZSBtYXRjaGluZ1xuICAvLyBiZWhhdmlvciBieSBzaW1wbHkgcHV0dGluZyByb3V0ZXMgd2l0aCBpZGVudGljYWwgcGF0aHMgaW4gdGhlIG9yZGVyIHRoZXlcbiAgLy8gd2FudCB0aGVtIHRyaWVkLlxuICBhW2EubGVuZ3RoIC0gMV0gLSBiW2IubGVuZ3RoIC0gMV0gOlxuICAvLyBPdGhlcndpc2UsIGl0IGRvZXNuJ3QgcmVhbGx5IG1ha2Ugc2Vuc2UgdG8gcmFuayBub24tc2libGluZ3MgYnkgaW5kZXgsXG4gIC8vIHNvIHRoZXkgc29ydCBlcXVhbGx5LlxuICAwO1xufVxuZnVuY3Rpb24gbWF0Y2hSb3V0ZUJyYW5jaChicmFuY2gsIHBhdGhuYW1lKSB7XG4gIGxldCB7XG4gICAgcm91dGVzTWV0YVxuICB9ID0gYnJhbmNoO1xuICBsZXQgbWF0Y2hlZFBhcmFtcyA9IHt9O1xuICBsZXQgbWF0Y2hlZFBhdGhuYW1lID0gXCIvXCI7XG4gIGxldCBtYXRjaGVzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm91dGVzTWV0YS5sZW5ndGg7ICsraSkge1xuICAgIGxldCBtZXRhID0gcm91dGVzTWV0YVtpXTtcbiAgICBsZXQgZW5kID0gaSA9PT0gcm91dGVzTWV0YS5sZW5ndGggLSAxO1xuICAgIGxldCByZW1haW5pbmdQYXRobmFtZSA9IG1hdGNoZWRQYXRobmFtZSA9PT0gXCIvXCIgPyBwYXRobmFtZSA6IHBhdGhuYW1lLnNsaWNlKG1hdGNoZWRQYXRobmFtZS5sZW5ndGgpIHx8IFwiL1wiO1xuICAgIGxldCBtYXRjaCA9IG1hdGNoUGF0aCh7XG4gICAgICBwYXRoOiBtZXRhLnJlbGF0aXZlUGF0aCxcbiAgICAgIGNhc2VTZW5zaXRpdmU6IG1ldGEuY2FzZVNlbnNpdGl2ZSxcbiAgICAgIGVuZFxuICAgIH0sIHJlbWFpbmluZ1BhdGhuYW1lKTtcbiAgICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcbiAgICBPYmplY3QuYXNzaWduKG1hdGNoZWRQYXJhbXMsIG1hdGNoLnBhcmFtcyk7XG4gICAgbGV0IHJvdXRlID0gbWV0YS5yb3V0ZTtcbiAgICBtYXRjaGVzLnB1c2goe1xuICAgICAgLy8gVE9ETzogQ2FuIHRoaXMgYXMgYmUgYXZvaWRlZD9cbiAgICAgIHBhcmFtczogbWF0Y2hlZFBhcmFtcyxcbiAgICAgIHBhdGhuYW1lOiBqb2luUGF0aHMoW21hdGNoZWRQYXRobmFtZSwgbWF0Y2gucGF0aG5hbWVdKSxcbiAgICAgIHBhdGhuYW1lQmFzZTogbm9ybWFsaXplUGF0aG5hbWUoam9pblBhdGhzKFttYXRjaGVkUGF0aG5hbWUsIG1hdGNoLnBhdGhuYW1lQmFzZV0pKSxcbiAgICAgIHJvdXRlXG4gICAgfSk7XG4gICAgaWYgKG1hdGNoLnBhdGhuYW1lQmFzZSAhPT0gXCIvXCIpIHtcbiAgICAgIG1hdGNoZWRQYXRobmFtZSA9IGpvaW5QYXRocyhbbWF0Y2hlZFBhdGhuYW1lLCBtYXRjaC5wYXRobmFtZUJhc2VdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG4vKipcbiAqIFJldHVybnMgYSBwYXRoIHdpdGggcGFyYW1zIGludGVycG9sYXRlZC5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL2dlbmVyYXRlLXBhdGhcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVQYXRoKG9yaWdpbmFsUGF0aCwgcGFyYW1zKSB7XG4gIGlmIChwYXJhbXMgPT09IHZvaWQgMCkge1xuICAgIHBhcmFtcyA9IHt9O1xuICB9XG4gIGxldCBwYXRoID0gb3JpZ2luYWxQYXRoO1xuICBpZiAocGF0aC5lbmRzV2l0aChcIipcIikgJiYgcGF0aCAhPT0gXCIqXCIgJiYgIXBhdGguZW5kc1dpdGgoXCIvKlwiKSkge1xuICAgIHdhcm5pbmcoZmFsc2UsIFwiUm91dGUgcGF0aCBcXFwiXCIgKyBwYXRoICsgXCJcXFwiIHdpbGwgYmUgdHJlYXRlZCBhcyBpZiBpdCB3ZXJlIFwiICsgKFwiXFxcIlwiICsgcGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKSArIFwiXFxcIiBiZWNhdXNlIHRoZSBgKmAgY2hhcmFjdGVyIG11c3QgXCIpICsgXCJhbHdheXMgZm9sbG93IGEgYC9gIGluIHRoZSBwYXR0ZXJuLiBUbyBnZXQgcmlkIG9mIHRoaXMgd2FybmluZywgXCIgKyAoXCJwbGVhc2UgY2hhbmdlIHRoZSByb3V0ZSBwYXRoIHRvIFxcXCJcIiArIHBhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIikgKyBcIlxcXCIuXCIpKTtcbiAgICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXCokLywgXCIvKlwiKTtcbiAgfVxuICAvLyBlbnN1cmUgYC9gIGlzIGFkZGVkIGF0IHRoZSBiZWdpbm5pbmcgaWYgdGhlIHBhdGggaXMgYWJzb2x1dGVcbiAgY29uc3QgcHJlZml4ID0gcGF0aC5zdGFydHNXaXRoKFwiL1wiKSA/IFwiL1wiIDogXCJcIjtcbiAgY29uc3Qgc3RyaW5naWZ5ID0gcCA9PiBwID09IG51bGwgPyBcIlwiIDogdHlwZW9mIHAgPT09IFwic3RyaW5nXCIgPyBwIDogU3RyaW5nKHApO1xuICBjb25zdCBzZWdtZW50cyA9IHBhdGguc3BsaXQoL1xcLysvKS5tYXAoKHNlZ21lbnQsIGluZGV4LCBhcnJheSkgPT4ge1xuICAgIGNvbnN0IGlzTGFzdFNlZ21lbnQgPSBpbmRleCA9PT0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICAvLyBvbmx5IGFwcGx5IHRoZSBzcGxhdCBpZiBpdCdzIHRoZSBsYXN0IHNlZ21lbnRcbiAgICBpZiAoaXNMYXN0U2VnbWVudCAmJiBzZWdtZW50ID09PSBcIipcIikge1xuICAgICAgY29uc3Qgc3RhciA9IFwiKlwiO1xuICAgICAgLy8gQXBwbHkgdGhlIHNwbGF0XG4gICAgICByZXR1cm4gc3RyaW5naWZ5KHBhcmFtc1tzdGFyXSk7XG4gICAgfVxuICAgIGNvbnN0IGtleU1hdGNoID0gc2VnbWVudC5tYXRjaCgvXjooXFx3KykoXFw/PykkLyk7XG4gICAgaWYgKGtleU1hdGNoKSB7XG4gICAgICBjb25zdCBbLCBrZXksIG9wdGlvbmFsXSA9IGtleU1hdGNoO1xuICAgICAgbGV0IHBhcmFtID0gcGFyYW1zW2tleV07XG4gICAgICBpbnZhcmlhbnQob3B0aW9uYWwgPT09IFwiP1wiIHx8IHBhcmFtICE9IG51bGwsIFwiTWlzc2luZyBcXFwiOlwiICsga2V5ICsgXCJcXFwiIHBhcmFtXCIpO1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeShwYXJhbSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBhbnkgb3B0aW9uYWwgbWFya2VycyBmcm9tIG9wdGlvbmFsIHN0YXRpYyBzZWdtZW50c1xuICAgIHJldHVybiBzZWdtZW50LnJlcGxhY2UoL1xcPyQvZywgXCJcIik7XG4gIH0pXG4gIC8vIFJlbW92ZSBlbXB0eSBzZWdtZW50c1xuICAuZmlsdGVyKHNlZ21lbnQgPT4gISFzZWdtZW50KTtcbiAgcmV0dXJuIHByZWZpeCArIHNlZ21lbnRzLmpvaW4oXCIvXCIpO1xufVxuLyoqXG4gKiBQZXJmb3JtcyBwYXR0ZXJuIG1hdGNoaW5nIG9uIGEgVVJMIHBhdGhuYW1lIGFuZCByZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0XG4gKiB0aGUgbWF0Y2guXG4gKlxuICogQHNlZSBodHRwczovL3JlYWN0cm91dGVyLmNvbS91dGlscy9tYXRjaC1wYXRoXG4gKi9cbmZ1bmN0aW9uIG1hdGNoUGF0aChwYXR0ZXJuLCBwYXRobmFtZSkge1xuICBpZiAodHlwZW9mIHBhdHRlcm4gPT09IFwic3RyaW5nXCIpIHtcbiAgICBwYXR0ZXJuID0ge1xuICAgICAgcGF0aDogcGF0dGVybixcbiAgICAgIGNhc2VTZW5zaXRpdmU6IGZhbHNlLFxuICAgICAgZW5kOiB0cnVlXG4gICAgfTtcbiAgfVxuICBsZXQgW21hdGNoZXIsIGNvbXBpbGVkUGFyYW1zXSA9IGNvbXBpbGVQYXRoKHBhdHRlcm4ucGF0aCwgcGF0dGVybi5jYXNlU2Vuc2l0aXZlLCBwYXR0ZXJuLmVuZCk7XG4gIGxldCBtYXRjaCA9IHBhdGhuYW1lLm1hdGNoKG1hdGNoZXIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcbiAgbGV0IG1hdGNoZWRQYXRobmFtZSA9IG1hdGNoWzBdO1xuICBsZXQgcGF0aG5hbWVCYXNlID0gbWF0Y2hlZFBhdGhuYW1lLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgbGV0IGNhcHR1cmVHcm91cHMgPSBtYXRjaC5zbGljZSgxKTtcbiAgbGV0IHBhcmFtcyA9IGNvbXBpbGVkUGFyYW1zLnJlZHVjZSgobWVtbywgX3JlZiwgaW5kZXgpID0+IHtcbiAgICBsZXQge1xuICAgICAgcGFyYW1OYW1lLFxuICAgICAgaXNPcHRpb25hbFxuICAgIH0gPSBfcmVmO1xuICAgIC8vIFdlIG5lZWQgdG8gY29tcHV0ZSB0aGUgcGF0aG5hbWVCYXNlIGhlcmUgdXNpbmcgdGhlIHJhdyBzcGxhdCB2YWx1ZVxuICAgIC8vIGluc3RlYWQgb2YgdXNpbmcgcGFyYW1zW1wiKlwiXSBsYXRlciBiZWNhdXNlIGl0IHdpbGwgYmUgZGVjb2RlZCB0aGVuXG4gICAgaWYgKHBhcmFtTmFtZSA9PT0gXCIqXCIpIHtcbiAgICAgIGxldCBzcGxhdFZhbHVlID0gY2FwdHVyZUdyb3Vwc1tpbmRleF0gfHwgXCJcIjtcbiAgICAgIHBhdGhuYW1lQmFzZSA9IG1hdGNoZWRQYXRobmFtZS5zbGljZSgwLCBtYXRjaGVkUGF0aG5hbWUubGVuZ3RoIC0gc3BsYXRWYWx1ZS5sZW5ndGgpLnJlcGxhY2UoLyguKVxcLyskLywgXCIkMVwiKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSBjYXB0dXJlR3JvdXBzW2luZGV4XTtcbiAgICBpZiAoaXNPcHRpb25hbCAmJiAhdmFsdWUpIHtcbiAgICAgIG1lbW9bcGFyYW1OYW1lXSA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVtb1twYXJhbU5hbWVdID0gc2FmZWx5RGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlIHx8IFwiXCIsIHBhcmFtTmFtZSk7XG4gICAgfVxuICAgIHJldHVybiBtZW1vO1xuICB9LCB7fSk7XG4gIHJldHVybiB7XG4gICAgcGFyYW1zLFxuICAgIHBhdGhuYW1lOiBtYXRjaGVkUGF0aG5hbWUsXG4gICAgcGF0aG5hbWVCYXNlLFxuICAgIHBhdHRlcm5cbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVQYXRoKHBhdGgsIGNhc2VTZW5zaXRpdmUsIGVuZCkge1xuICBpZiAoY2FzZVNlbnNpdGl2ZSA9PT0gdm9pZCAwKSB7XG4gICAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlO1xuICB9XG4gIGlmIChlbmQgPT09IHZvaWQgMCkge1xuICAgIGVuZCA9IHRydWU7XG4gIH1cbiAgd2FybmluZyhwYXRoID09PSBcIipcIiB8fCAhcGF0aC5lbmRzV2l0aChcIipcIikgfHwgcGF0aC5lbmRzV2l0aChcIi8qXCIpLCBcIlJvdXRlIHBhdGggXFxcIlwiICsgcGF0aCArIFwiXFxcIiB3aWxsIGJlIHRyZWF0ZWQgYXMgaWYgaXQgd2VyZSBcIiArIChcIlxcXCJcIiArIHBhdGgucmVwbGFjZSgvXFwqJC8sIFwiLypcIikgKyBcIlxcXCIgYmVjYXVzZSB0aGUgYCpgIGNoYXJhY3RlciBtdXN0IFwiKSArIFwiYWx3YXlzIGZvbGxvdyBhIGAvYCBpbiB0aGUgcGF0dGVybi4gVG8gZ2V0IHJpZCBvZiB0aGlzIHdhcm5pbmcsIFwiICsgKFwicGxlYXNlIGNoYW5nZSB0aGUgcm91dGUgcGF0aCB0byBcXFwiXCIgKyBwYXRoLnJlcGxhY2UoL1xcKiQvLCBcIi8qXCIpICsgXCJcXFwiLlwiKSk7XG4gIGxldCBwYXJhbXMgPSBbXTtcbiAgbGV0IHJlZ2V4cFNvdXJjZSA9IFwiXlwiICsgcGF0aC5yZXBsYWNlKC9cXC8qXFwqPyQvLCBcIlwiKSAvLyBJZ25vcmUgdHJhaWxpbmcgLyBhbmQgLyosIHdlJ2xsIGhhbmRsZSBpdCBiZWxvd1xuICAucmVwbGFjZSgvXlxcLyovLCBcIi9cIikgLy8gTWFrZSBzdXJlIGl0IGhhcyBhIGxlYWRpbmcgL1xuICAucmVwbGFjZSgvW1xcXFwuKiteJHt9fCgpW1xcXV0vZywgXCJcXFxcJCZcIikgLy8gRXNjYXBlIHNwZWNpYWwgcmVnZXggY2hhcnNcbiAgLnJlcGxhY2UoL1xcLzooXFx3KykoXFw/KT8vZywgKF8sIHBhcmFtTmFtZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgIHBhcmFtcy5wdXNoKHtcbiAgICAgIHBhcmFtTmFtZSxcbiAgICAgIGlzT3B0aW9uYWw6IGlzT3B0aW9uYWwgIT0gbnVsbFxuICAgIH0pO1xuICAgIHJldHVybiBpc09wdGlvbmFsID8gXCIvPyhbXlxcXFwvXSspP1wiIDogXCIvKFteXFxcXC9dKylcIjtcbiAgfSk7XG4gIGlmIChwYXRoLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgIHBhcmFtcy5wdXNoKHtcbiAgICAgIHBhcmFtTmFtZTogXCIqXCJcbiAgICB9KTtcbiAgICByZWdleHBTb3VyY2UgKz0gcGF0aCA9PT0gXCIqXCIgfHwgcGF0aCA9PT0gXCIvKlwiID8gXCIoLiopJFwiIC8vIEFscmVhZHkgbWF0Y2hlZCB0aGUgaW5pdGlhbCAvLCBqdXN0IG1hdGNoIHRoZSByZXN0XG4gICAgOiBcIig/OlxcXFwvKC4rKXxcXFxcLyopJFwiOyAvLyBEb24ndCBpbmNsdWRlIHRoZSAvIGluIHBhcmFtc1tcIipcIl1cbiAgfSBlbHNlIGlmIChlbmQpIHtcbiAgICAvLyBXaGVuIG1hdGNoaW5nIHRvIHRoZSBlbmQsIGlnbm9yZSB0cmFpbGluZyBzbGFzaGVzXG4gICAgcmVnZXhwU291cmNlICs9IFwiXFxcXC8qJFwiO1xuICB9IGVsc2UgaWYgKHBhdGggIT09IFwiXCIgJiYgcGF0aCAhPT0gXCIvXCIpIHtcbiAgICAvLyBJZiBvdXIgcGF0aCBpcyBub24tZW1wdHkgYW5kIGNvbnRhaW5zIGFueXRoaW5nIGJleW9uZCBhbiBpbml0aWFsIHNsYXNoLFxuICAgIC8vIHRoZW4gd2UgaGF2ZSBfc29tZV8gZm9ybSBvZiBwYXRoIGluIG91ciByZWdleCwgc28gd2Ugc2hvdWxkIGV4cGVjdCB0b1xuICAgIC8vIG1hdGNoIG9ubHkgaWYgd2UgZmluZCB0aGUgZW5kIG9mIHRoaXMgcGF0aCBzZWdtZW50LiAgTG9vayBmb3IgYW4gb3B0aW9uYWxcbiAgICAvLyBub24tY2FwdHVyZWQgdHJhaWxpbmcgc2xhc2ggKHRvIG1hdGNoIGEgcG9ydGlvbiBvZiB0aGUgVVJMKSBvciB0aGUgZW5kXG4gICAgLy8gb2YgdGhlIHBhdGggKGlmIHdlJ3ZlIG1hdGNoZWQgdG8gdGhlIGVuZCkuICBXZSB1c2VkIHRvIGRvIHRoaXMgd2l0aCBhXG4gICAgLy8gd29yZCBib3VuZGFyeSBidXQgdGhhdCBnaXZlcyBmYWxzZSBwb3NpdGl2ZXMgb24gcm91dGVzIGxpa2VcbiAgICAvLyAvdXNlci1wcmVmZXJlbmNlcyBzaW5jZSBgLWAgY291bnRzIGFzIGEgd29yZCBib3VuZGFyeS5cbiAgICByZWdleHBTb3VyY2UgKz0gXCIoPzooPz1cXFxcL3wkKSlcIjtcbiAgfSBlbHNlIDtcbiAgbGV0IG1hdGNoZXIgPSBuZXcgUmVnRXhwKHJlZ2V4cFNvdXJjZSwgY2FzZVNlbnNpdGl2ZSA/IHVuZGVmaW5lZCA6IFwiaVwiKTtcbiAgcmV0dXJuIFttYXRjaGVyLCBwYXJhbXNdO1xufVxuZnVuY3Rpb24gc2FmZWx5RGVjb2RlVVJJKHZhbHVlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSSh2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgd2FybmluZyhmYWxzZSwgXCJUaGUgVVJMIHBhdGggXFxcIlwiICsgdmFsdWUgKyBcIlxcXCIgY291bGQgbm90IGJlIGRlY29kZWQgYmVjYXVzZSBpdCBpcyBpcyBhIFwiICsgXCJtYWxmb3JtZWQgVVJMIHNlZ21lbnQuIFRoaXMgaXMgcHJvYmFibHkgZHVlIHRvIGEgYmFkIHBlcmNlbnQgXCIgKyAoXCJlbmNvZGluZyAoXCIgKyBlcnJvciArIFwiKS5cIikpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24gc2FmZWx5RGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlLCBwYXJhbU5hbWUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCBcIlRoZSB2YWx1ZSBmb3IgdGhlIFVSTCBwYXJhbSBcXFwiXCIgKyBwYXJhbU5hbWUgKyBcIlxcXCIgd2lsbCBub3QgYmUgZGVjb2RlZCBiZWNhdXNlXCIgKyAoXCIgdGhlIHN0cmluZyBcXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiBpcyBhIG1hbGZvcm1lZCBVUkwgc2VnbWVudC4gVGhpcyBpcyBwcm9iYWJseVwiKSArIChcIiBkdWUgdG8gYSBiYWQgcGVyY2VudCBlbmNvZGluZyAoXCIgKyBlcnJvciArIFwiKS5cIikpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzdHJpcEJhc2VuYW1lKHBhdGhuYW1lLCBiYXNlbmFtZSkge1xuICBpZiAoYmFzZW5hbWUgPT09IFwiL1wiKSByZXR1cm4gcGF0aG5hbWU7XG4gIGlmICghcGF0aG5hbWUudG9Mb3dlckNhc2UoKS5zdGFydHNXaXRoKGJhc2VuYW1lLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gV2Ugd2FudCB0byBsZWF2ZSB0cmFpbGluZyBzbGFzaCBiZWhhdmlvciBpbiB0aGUgdXNlcidzIGNvbnRyb2wsIHNvIGlmIHRoZXlcbiAgLy8gc3BlY2lmeSBhIGJhc2VuYW1lIHdpdGggYSB0cmFpbGluZyBzbGFzaCwgd2Ugc2hvdWxkIHN1cHBvcnQgaXRcbiAgbGV0IHN0YXJ0SW5kZXggPSBiYXNlbmFtZS5lbmRzV2l0aChcIi9cIikgPyBiYXNlbmFtZS5sZW5ndGggLSAxIDogYmFzZW5hbWUubGVuZ3RoO1xuICBsZXQgbmV4dENoYXIgPSBwYXRobmFtZS5jaGFyQXQoc3RhcnRJbmRleCk7XG4gIGlmIChuZXh0Q2hhciAmJiBuZXh0Q2hhciAhPT0gXCIvXCIpIHtcbiAgICAvLyBwYXRobmFtZSBkb2VzIG5vdCBzdGFydCB3aXRoIGJhc2VuYW1lL1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBwYXRobmFtZS5zbGljZShzdGFydEluZGV4KSB8fCBcIi9cIjtcbn1cbi8qKlxuICogUmV0dXJucyBhIHJlc29sdmVkIHBhdGggb2JqZWN0IHJlbGF0aXZlIHRvIHRoZSBnaXZlbiBwYXRobmFtZS5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vcmVhY3Ryb3V0ZXIuY29tL3V0aWxzL3Jlc29sdmUtcGF0aFxuICovXG5mdW5jdGlvbiByZXNvbHZlUGF0aCh0bywgZnJvbVBhdGhuYW1lKSB7XG4gIGlmIChmcm9tUGF0aG5hbWUgPT09IHZvaWQgMCkge1xuICAgIGZyb21QYXRobmFtZSA9IFwiL1wiO1xuICB9XG4gIGxldCB7XG4gICAgcGF0aG5hbWU6IHRvUGF0aG5hbWUsXG4gICAgc2VhcmNoID0gXCJcIixcbiAgICBoYXNoID0gXCJcIlxuICB9ID0gdHlwZW9mIHRvID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHRvKSA6IHRvO1xuICBsZXQgcGF0aG5hbWUgPSB0b1BhdGhuYW1lID8gdG9QYXRobmFtZS5zdGFydHNXaXRoKFwiL1wiKSA/IHRvUGF0aG5hbWUgOiByZXNvbHZlUGF0aG5hbWUodG9QYXRobmFtZSwgZnJvbVBhdGhuYW1lKSA6IGZyb21QYXRobmFtZTtcbiAgcmV0dXJuIHtcbiAgICBwYXRobmFtZSxcbiAgICBzZWFyY2g6IG5vcm1hbGl6ZVNlYXJjaChzZWFyY2gpLFxuICAgIGhhc2g6IG5vcm1hbGl6ZUhhc2goaGFzaClcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVQYXRobmFtZShyZWxhdGl2ZVBhdGgsIGZyb21QYXRobmFtZSkge1xuICBsZXQgc2VnbWVudHMgPSBmcm9tUGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5zcGxpdChcIi9cIik7XG4gIGxldCByZWxhdGl2ZVNlZ21lbnRzID0gcmVsYXRpdmVQYXRoLnNwbGl0KFwiL1wiKTtcbiAgcmVsYXRpdmVTZWdtZW50cy5mb3JFYWNoKHNlZ21lbnQgPT4ge1xuICAgIGlmIChzZWdtZW50ID09PSBcIi4uXCIpIHtcbiAgICAgIC8vIEtlZXAgdGhlIHJvb3QgXCJcIiBzZWdtZW50IHNvIHRoZSBwYXRobmFtZSBzdGFydHMgYXQgL1xuICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHNlZ21lbnRzLnBvcCgpO1xuICAgIH0gZWxzZSBpZiAoc2VnbWVudCAhPT0gXCIuXCIpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCA+IDEgPyBzZWdtZW50cy5qb2luKFwiL1wiKSA6IFwiL1wiO1xufVxuZnVuY3Rpb24gZ2V0SW52YWxpZFBhdGhFcnJvcihjaGFyLCBmaWVsZCwgZGVzdCwgcGF0aCkge1xuICByZXR1cm4gXCJDYW5ub3QgaW5jbHVkZSBhICdcIiArIGNoYXIgKyBcIicgY2hhcmFjdGVyIGluIGEgbWFudWFsbHkgc3BlY2lmaWVkIFwiICsgKFwiYHRvLlwiICsgZmllbGQgKyBcImAgZmllbGQgW1wiICsgSlNPTi5zdHJpbmdpZnkocGF0aCkgKyBcIl0uICBQbGVhc2Ugc2VwYXJhdGUgaXQgb3V0IHRvIHRoZSBcIikgKyAoXCJgdG8uXCIgKyBkZXN0ICsgXCJgIGZpZWxkLiBBbHRlcm5hdGl2ZWx5IHlvdSBtYXkgcHJvdmlkZSB0aGUgZnVsbCBwYXRoIGFzIFwiKSArIFwiYSBzdHJpbmcgaW4gPExpbmsgdG89XFxcIi4uLlxcXCI+IGFuZCB0aGUgcm91dGVyIHdpbGwgcGFyc2UgaXQgZm9yIHlvdS5cIjtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBXaGVuIHByb2Nlc3NpbmcgcmVsYXRpdmUgbmF2aWdhdGlvbiB3ZSB3YW50IHRvIGlnbm9yZSBhbmNlc3RvciByb3V0ZXMgdGhhdFxuICogZG8gbm90IGNvbnRyaWJ1dGUgdG8gdGhlIHBhdGgsIHN1Y2ggdGhhdCBpbmRleC9wYXRobGVzcyBsYXlvdXQgcm91dGVzIGRvbid0XG4gKiBpbnRlcmZlcmUuXG4gKlxuICogRm9yIGV4YW1wbGUsIHdoZW4gbW92aW5nIGEgcm91dGUgZWxlbWVudCBpbnRvIGFuIGluZGV4IHJvdXRlIGFuZC9vciBhXG4gKiBwYXRobGVzcyBsYXlvdXQgcm91dGUsIHJlbGF0aXZlIGxpbmsgYmVoYXZpb3IgY29udGFpbmVkIHdpdGhpbiBzaG91bGQgc3RheVxuICogdGhlIHNhbWUuICBCb3RoIG9mIHRoZSBmb2xsb3dpbmcgZXhhbXBsZXMgc2hvdWxkIGxpbmsgYmFjayB0byB0aGUgcm9vdDpcbiAqXG4gKiAgIDxSb3V0ZSBwYXRoPVwiL1wiPlxuICogICAgIDxSb3V0ZSBwYXRoPVwiYWNjb3VudHNcIiBlbGVtZW50PXs8TGluayB0bz1cIi4uXCJ9PlxuICogICA8L1JvdXRlPlxuICpcbiAqICAgPFJvdXRlIHBhdGg9XCIvXCI+XG4gKiAgICAgPFJvdXRlIHBhdGg9XCJhY2NvdW50c1wiPlxuICogICAgICAgPFJvdXRlIGVsZW1lbnQ9ezxBY2NvdW50c0xheW91dCAvPn0+ICAgICAgIC8vIDwtLSBEb2VzIG5vdCBjb250cmlidXRlXG4gKiAgICAgICAgIDxSb3V0ZSBpbmRleCBlbGVtZW50PXs8TGluayB0bz1cIi4uXCJ9IC8+ICAvLyA8LS0gRG9lcyBub3QgY29udHJpYnV0ZVxuICogICAgICAgPC9Sb3V0ZVxuICogICAgIDwvUm91dGU+XG4gKiAgIDwvUm91dGU+XG4gKi9cbmZ1bmN0aW9uIGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzKG1hdGNoZXMpIHtcbiAgcmV0dXJuIG1hdGNoZXMuZmlsdGVyKChtYXRjaCwgaW5kZXgpID0+IGluZGV4ID09PSAwIHx8IG1hdGNoLnJvdXRlLnBhdGggJiYgbWF0Y2gucm91dGUucGF0aC5sZW5ndGggPiAwKTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVRvKHRvQXJnLCByb3V0ZVBhdGhuYW1lcywgbG9jYXRpb25QYXRobmFtZSwgaXNQYXRoUmVsYXRpdmUpIHtcbiAgaWYgKGlzUGF0aFJlbGF0aXZlID09PSB2b2lkIDApIHtcbiAgICBpc1BhdGhSZWxhdGl2ZSA9IGZhbHNlO1xuICB9XG4gIGxldCB0bztcbiAgaWYgKHR5cGVvZiB0b0FyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHRvID0gcGFyc2VQYXRoKHRvQXJnKTtcbiAgfSBlbHNlIHtcbiAgICB0byA9IF9leHRlbmRzKHt9LCB0b0FyZyk7XG4gICAgaW52YXJpYW50KCF0by5wYXRobmFtZSB8fCAhdG8ucGF0aG5hbWUuaW5jbHVkZXMoXCI/XCIpLCBnZXRJbnZhbGlkUGF0aEVycm9yKFwiP1wiLCBcInBhdGhuYW1lXCIsIFwic2VhcmNoXCIsIHRvKSk7XG4gICAgaW52YXJpYW50KCF0by5wYXRobmFtZSB8fCAhdG8ucGF0aG5hbWUuaW5jbHVkZXMoXCIjXCIpLCBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInBhdGhuYW1lXCIsIFwiaGFzaFwiLCB0bykpO1xuICAgIGludmFyaWFudCghdG8uc2VhcmNoIHx8ICF0by5zZWFyY2guaW5jbHVkZXMoXCIjXCIpLCBnZXRJbnZhbGlkUGF0aEVycm9yKFwiI1wiLCBcInNlYXJjaFwiLCBcImhhc2hcIiwgdG8pKTtcbiAgfVxuICBsZXQgaXNFbXB0eVBhdGggPSB0b0FyZyA9PT0gXCJcIiB8fCB0by5wYXRobmFtZSA9PT0gXCJcIjtcbiAgbGV0IHRvUGF0aG5hbWUgPSBpc0VtcHR5UGF0aCA/IFwiL1wiIDogdG8ucGF0aG5hbWU7XG4gIGxldCBmcm9tO1xuICAvLyBSb3V0aW5nIGlzIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHBhdGhuYW1lIGlmIGV4cGxpY2l0bHkgcmVxdWVzdGVkLlxuICAvL1xuICAvLyBJZiBhIHBhdGhuYW1lIGlzIGV4cGxpY2l0bHkgcHJvdmlkZWQgaW4gYHRvYCwgaXQgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZVxuICAvLyByb3V0ZSBjb250ZXh0LiBUaGlzIGlzIGV4cGxhaW5lZCBpbiBgTm90ZSBvbiBgPExpbmsgdG8+YCB2YWx1ZXNgIGluIG91clxuICAvLyBtaWdyYXRpb24gZ3VpZGUgZnJvbSB2NSBhcyBhIG1lYW5zIG9mIGRpc2FtYmlndWF0aW9uIGJldHdlZW4gYHRvYCB2YWx1ZXNcbiAgLy8gdGhhdCBiZWdpbiB3aXRoIGAvYCBhbmQgdGhvc2UgdGhhdCBkbyBub3QuIEhvd2V2ZXIsIHRoaXMgaXMgcHJvYmxlbWF0aWMgZm9yXG4gIC8vIGB0b2AgdmFsdWVzIHRoYXQgZG8gbm90IHByb3ZpZGUgYSBwYXRobmFtZS4gYHRvYCBjYW4gc2ltcGx5IGJlIGEgc2VhcmNoIG9yXG4gIC8vIGhhc2ggc3RyaW5nLCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZCBhc3N1bWUgdGhhdCB0aGUgbmF2aWdhdGlvbiBpcyByZWxhdGl2ZVxuICAvLyB0byB0aGUgY3VycmVudCBsb2NhdGlvbidzIHBhdGhuYW1lIGFuZCAqbm90KiB0aGUgcm91dGUgcGF0aG5hbWUuXG4gIGlmICh0b1BhdGhuYW1lID09IG51bGwpIHtcbiAgICBmcm9tID0gbG9jYXRpb25QYXRobmFtZTtcbiAgfSBlbHNlIGlmIChpc1BhdGhSZWxhdGl2ZSkge1xuICAgIGxldCBmcm9tU2VnbWVudHMgPSByb3V0ZVBhdGhuYW1lc1tyb3V0ZVBhdGhuYW1lcy5sZW5ndGggLSAxXS5yZXBsYWNlKC9eXFwvLywgXCJcIikuc3BsaXQoXCIvXCIpO1xuICAgIGlmICh0b1BhdGhuYW1lLnN0YXJ0c1dpdGgoXCIuLlwiKSkge1xuICAgICAgbGV0IHRvU2VnbWVudHMgPSB0b1BhdGhuYW1lLnNwbGl0KFwiL1wiKTtcbiAgICAgIC8vIFdpdGggcmVsYXRpdmU9XCJwYXRoXCIsIGVhY2ggbGVhZGluZyAuLiBzZWdtZW50IG1lYW5zIFwiZ28gdXAgb25lIFVSTCBzZWdtZW50XCJcbiAgICAgIHdoaWxlICh0b1NlZ21lbnRzWzBdID09PSBcIi4uXCIpIHtcbiAgICAgICAgdG9TZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICBmcm9tU2VnbWVudHMucG9wKCk7XG4gICAgICB9XG4gICAgICB0by5wYXRobmFtZSA9IHRvU2VnbWVudHMuam9pbihcIi9cIik7XG4gICAgfVxuICAgIGZyb20gPSBcIi9cIiArIGZyb21TZWdtZW50cy5qb2luKFwiL1wiKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcm91dGVQYXRobmFtZUluZGV4ID0gcm91dGVQYXRobmFtZXMubGVuZ3RoIC0gMTtcbiAgICBpZiAodG9QYXRobmFtZS5zdGFydHNXaXRoKFwiLi5cIikpIHtcbiAgICAgIGxldCB0b1NlZ21lbnRzID0gdG9QYXRobmFtZS5zcGxpdChcIi9cIik7XG4gICAgICAvLyBXaXRoIHJlbGF0aXZlPVwicm91dGVcIiAodGhlIGRlZmF1bHQpLCBlYWNoIGxlYWRpbmcgLi4gc2VnbWVudCBtZWFuc1xuICAgICAgLy8gXCJnbyB1cCBvbmUgcm91dGVcIiBpbnN0ZWFkIG9mIFwiZ28gdXAgb25lIFVSTCBzZWdtZW50XCIuICBUaGlzIGlzIGEga2V5XG4gICAgICAvLyBkaWZmZXJlbmNlIGZyb20gaG93IDxhIGhyZWY+IHdvcmtzIGFuZCBhIG1ham9yIHJlYXNvbiB3ZSBjYWxsIHRoaXMgYVxuICAgICAgLy8gXCJ0b1wiIHZhbHVlIGluc3RlYWQgb2YgYSBcImhyZWZcIi5cbiAgICAgIHdoaWxlICh0b1NlZ21lbnRzWzBdID09PSBcIi4uXCIpIHtcbiAgICAgICAgdG9TZWdtZW50cy5zaGlmdCgpO1xuICAgICAgICByb3V0ZVBhdGhuYW1lSW5kZXggLT0gMTtcbiAgICAgIH1cbiAgICAgIHRvLnBhdGhuYW1lID0gdG9TZWdtZW50cy5qb2luKFwiL1wiKTtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUgYXJlIG1vcmUgXCIuLlwiIHNlZ21lbnRzIHRoYW4gcGFyZW50IHJvdXRlcywgcmVzb2x2ZSByZWxhdGl2ZSB0b1xuICAgIC8vIHRoZSByb290IC8gVVJMLlxuICAgIGZyb20gPSByb3V0ZVBhdGhuYW1lSW5kZXggPj0gMCA/IHJvdXRlUGF0aG5hbWVzW3JvdXRlUGF0aG5hbWVJbmRleF0gOiBcIi9cIjtcbiAgfVxuICBsZXQgcGF0aCA9IHJlc29sdmVQYXRoKHRvLCBmcm9tKTtcbiAgLy8gRW5zdXJlIHRoZSBwYXRobmFtZSBoYXMgYSB0cmFpbGluZyBzbGFzaCBpZiB0aGUgb3JpZ2luYWwgXCJ0b1wiIGhhZCBvbmVcbiAgbGV0IGhhc0V4cGxpY2l0VHJhaWxpbmdTbGFzaCA9IHRvUGF0aG5hbWUgJiYgdG9QYXRobmFtZSAhPT0gXCIvXCIgJiYgdG9QYXRobmFtZS5lbmRzV2l0aChcIi9cIik7XG4gIC8vIE9yIGlmIHRoaXMgd2FzIGEgbGluayB0byB0aGUgY3VycmVudCBwYXRoIHdoaWNoIGhhcyBhIHRyYWlsaW5nIHNsYXNoXG4gIGxldCBoYXNDdXJyZW50VHJhaWxpbmdTbGFzaCA9IChpc0VtcHR5UGF0aCB8fCB0b1BhdGhuYW1lID09PSBcIi5cIikgJiYgbG9jYXRpb25QYXRobmFtZS5lbmRzV2l0aChcIi9cIik7XG4gIGlmICghcGF0aC5wYXRobmFtZS5lbmRzV2l0aChcIi9cIikgJiYgKGhhc0V4cGxpY2l0VHJhaWxpbmdTbGFzaCB8fCBoYXNDdXJyZW50VHJhaWxpbmdTbGFzaCkpIHtcbiAgICBwYXRoLnBhdGhuYW1lICs9IFwiL1wiO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXRUb1BhdGhuYW1lKHRvKSB7XG4gIC8vIEVtcHR5IHN0cmluZ3Mgc2hvdWxkIGJlIHRyZWF0ZWQgdGhlIHNhbWUgYXMgLyBwYXRoc1xuICByZXR1cm4gdG8gPT09IFwiXCIgfHwgdG8ucGF0aG5hbWUgPT09IFwiXCIgPyBcIi9cIiA6IHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aCh0bykucGF0aG5hbWUgOiB0by5wYXRobmFtZTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgam9pblBhdGhzID0gcGF0aHMgPT4gcGF0aHMuam9pbihcIi9cIikucmVwbGFjZSgvXFwvXFwvKy9nLCBcIi9cIik7XG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IG5vcm1hbGl6ZVBhdGhuYW1lID0gcGF0aG5hbWUgPT4gcGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCBcIlwiKS5yZXBsYWNlKC9eXFwvKi8sIFwiL1wiKTtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgbm9ybWFsaXplU2VhcmNoID0gc2VhcmNoID0+ICFzZWFyY2ggfHwgc2VhcmNoID09PSBcIj9cIiA/IFwiXCIgOiBzZWFyY2guc3RhcnRzV2l0aChcIj9cIikgPyBzZWFyY2ggOiBcIj9cIiArIHNlYXJjaDtcbi8qKlxuICogQHByaXZhdGVcbiAqL1xuY29uc3Qgbm9ybWFsaXplSGFzaCA9IGhhc2ggPT4gIWhhc2ggfHwgaGFzaCA9PT0gXCIjXCIgPyBcIlwiIDogaGFzaC5zdGFydHNXaXRoKFwiI1wiKSA/IGhhc2ggOiBcIiNcIiArIGhhc2g7XG4vKipcbiAqIFRoaXMgaXMgYSBzaG9ydGN1dCBmb3IgY3JlYXRpbmcgYGFwcGxpY2F0aW9uL2pzb25gIHJlc3BvbnNlcy4gQ29udmVydHMgYGRhdGFgXG4gKiB0byBKU09OIGFuZCBzZXRzIHRoZSBgQ29udGVudC1UeXBlYCBoZWFkZXIuXG4gKi9cbmNvbnN0IGpzb24gPSBmdW5jdGlvbiBqc29uKGRhdGEsIGluaXQpIHtcbiAgaWYgKGluaXQgPT09IHZvaWQgMCkge1xuICAgIGluaXQgPSB7fTtcbiAgfVxuICBsZXQgcmVzcG9uc2VJbml0ID0gdHlwZW9mIGluaXQgPT09IFwibnVtYmVyXCIgPyB7XG4gICAgc3RhdHVzOiBpbml0XG4gIH0gOiBpbml0O1xuICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHJlc3BvbnNlSW5pdC5oZWFkZXJzKTtcbiAgaWYgKCFoZWFkZXJzLmhhcyhcIkNvbnRlbnQtVHlwZVwiKSkge1xuICAgIGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvbjsgY2hhcnNldD11dGYtOFwiKTtcbiAgfVxuICByZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KGRhdGEpLCBfZXh0ZW5kcyh7fSwgcmVzcG9uc2VJbml0LCB7XG4gICAgaGVhZGVyc1xuICB9KSk7XG59O1xuY2xhc3MgQWJvcnRlZERlZmVycmVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuY2xhc3MgRGVmZXJyZWREYXRhIHtcbiAgY29uc3RydWN0b3IoZGF0YSwgcmVzcG9uc2VJbml0KSB7XG4gICAgdGhpcy5wZW5kaW5nS2V5c1NldCA9IG5ldyBTZXQoKTtcbiAgICB0aGlzLnN1YnNjcmliZXJzID0gbmV3IFNldCgpO1xuICAgIHRoaXMuZGVmZXJyZWRLZXlzID0gW107XG4gICAgaW52YXJpYW50KGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoZGF0YSksIFwiZGVmZXIoKSBvbmx5IGFjY2VwdHMgcGxhaW4gb2JqZWN0c1wiKTtcbiAgICAvLyBTZXQgdXAgYW4gQWJvcnRDb250cm9sbGVyICsgUHJvbWlzZSB3ZSBjYW4gcmFjZSBhZ2FpbnN0IHRvIGV4aXQgZWFybHlcbiAgICAvLyBjYW5jZWxsYXRpb25cbiAgICBsZXQgcmVqZWN0O1xuICAgIHRoaXMuYWJvcnRQcm9taXNlID0gbmV3IFByb21pc2UoKF8sIHIpID0+IHJlamVjdCA9IHIpO1xuICAgIHRoaXMuY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICBsZXQgb25BYm9ydCA9ICgpID0+IHJlamVjdChuZXcgQWJvcnRlZERlZmVycmVkRXJyb3IoXCJEZWZlcnJlZCBkYXRhIGFib3J0ZWRcIikpO1xuICAgIHRoaXMudW5saXN0ZW5BYm9ydFNpZ25hbCA9ICgpID0+IHRoaXMuY29udHJvbGxlci5zaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgIHRoaXMuY29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIG9uQWJvcnQpO1xuICAgIHRoaXMuZGF0YSA9IE9iamVjdC5lbnRyaWVzKGRhdGEpLnJlZHVjZSgoYWNjLCBfcmVmMikgPT4ge1xuICAgICAgbGV0IFtrZXksIHZhbHVlXSA9IF9yZWYyO1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWNjLCB7XG4gICAgICAgIFtrZXldOiB0aGlzLnRyYWNrUHJvbWlzZShrZXksIHZhbHVlKVxuICAgICAgfSk7XG4gICAgfSwge30pO1xuICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgIC8vIEFsbCBpbmNvbWluZyB2YWx1ZXMgd2VyZSByZXNvbHZlZFxuICAgICAgdGhpcy51bmxpc3RlbkFib3J0U2lnbmFsKCk7XG4gICAgfVxuICAgIHRoaXMuaW5pdCA9IHJlc3BvbnNlSW5pdDtcbiAgfVxuICB0cmFja1Byb21pc2Uoa2V5LCB2YWx1ZSkge1xuICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgdGhpcy5kZWZlcnJlZEtleXMucHVzaChrZXkpO1xuICAgIHRoaXMucGVuZGluZ0tleXNTZXQuYWRkKGtleSk7XG4gICAgLy8gV2Ugc3RvcmUgYSBsaXR0bGUgd3JhcHBlciBwcm9taXNlIHRoYXQgd2lsbCBiZSBleHRlbmRlZCB3aXRoXG4gICAgLy8gX2RhdGEvX2Vycm9yIHByb3BzIHVwb24gcmVzb2x2ZS9yZWplY3RcbiAgICBsZXQgcHJvbWlzZSA9IFByb21pc2UucmFjZShbdmFsdWUsIHRoaXMuYWJvcnRQcm9taXNlXSkudGhlbihkYXRhID0+IHRoaXMub25TZXR0bGUocHJvbWlzZSwga2V5LCB1bmRlZmluZWQsIGRhdGEpLCBlcnJvciA9PiB0aGlzLm9uU2V0dGxlKHByb21pc2UsIGtleSwgZXJyb3IpKTtcbiAgICAvLyBSZWdpc3RlciByZWplY3Rpb24gbGlzdGVuZXJzIHRvIGF2b2lkIHVuY2F1Z2h0IHByb21pc2UgcmVqZWN0aW9ucyBvblxuICAgIC8vIGVycm9ycyBvciBhYm9ydGVkIGRlZmVycmVkIHZhbHVlc1xuICAgIHByb21pc2UuY2F0Y2goKCkgPT4ge30pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl90cmFja2VkXCIsIHtcbiAgICAgIGdldDogKCkgPT4gdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG4gIG9uU2V0dGxlKHByb21pc2UsIGtleSwgZXJyb3IsIGRhdGEpIHtcbiAgICBpZiAodGhpcy5jb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkICYmIGVycm9yIGluc3RhbmNlb2YgQWJvcnRlZERlZmVycmVkRXJyb3IpIHtcbiAgICAgIHRoaXMudW5saXN0ZW5BYm9ydFNpZ25hbCgpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2Vycm9yXCIsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiBlcnJvclxuICAgICAgfSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cbiAgICB0aGlzLnBlbmRpbmdLZXlzU2V0LmRlbGV0ZShrZXkpO1xuICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgIC8vIE5vdGhpbmcgbGVmdCB0byBhYm9ydCFcbiAgICAgIHRoaXMudW5saXN0ZW5BYm9ydFNpZ25hbCgpO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgcHJvbWlzZSB3YXMgcmVzb2x2ZWQvcmVqZWN0ZWQgd2l0aCB1bmRlZmluZWQsIHdlJ2xsIHRocm93IGFuIGVycm9yIGFzIHlvdVxuICAgIC8vIHNob3VsZCBhbHdheXMgcmVzb2x2ZSB3aXRoIGEgdmFsdWUgb3IgbnVsbFxuICAgIGlmIChlcnJvciA9PT0gdW5kZWZpbmVkICYmIGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgbGV0IHVuZGVmaW5lZEVycm9yID0gbmV3IEVycm9yKFwiRGVmZXJyZWQgZGF0YSBmb3Iga2V5IFxcXCJcIiArIGtleSArIFwiXFxcIiByZXNvbHZlZC9yZWplY3RlZCB3aXRoIGB1bmRlZmluZWRgLCBcIiArIFwieW91IG11c3QgcmVzb2x2ZS9yZWplY3Qgd2l0aCBhIHZhbHVlIG9yIGBudWxsYC5cIik7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvbWlzZSwgXCJfZXJyb3JcIiwge1xuICAgICAgICBnZXQ6ICgpID0+IHVuZGVmaW5lZEVycm9yXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZW1pdChmYWxzZSwga2V5KTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh1bmRlZmluZWRFcnJvcik7XG4gICAgfVxuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9taXNlLCBcIl9lcnJvclwiLCB7XG4gICAgICAgIGdldDogKCkgPT4gZXJyb3JcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbWl0KGZhbHNlLCBrZXkpO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb21pc2UsIFwiX2RhdGFcIiwge1xuICAgICAgZ2V0OiAoKSA9PiBkYXRhXG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KGZhbHNlLCBrZXkpO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIGVtaXQoYWJvcnRlZCwgc2V0dGxlZEtleSkge1xuICAgIHRoaXMuc3Vic2NyaWJlcnMuZm9yRWFjaChzdWJzY3JpYmVyID0+IHN1YnNjcmliZXIoYWJvcnRlZCwgc2V0dGxlZEtleSkpO1xuICB9XG4gIHN1YnNjcmliZShmbikge1xuICAgIHRoaXMuc3Vic2NyaWJlcnMuYWRkKGZuKTtcbiAgICByZXR1cm4gKCkgPT4gdGhpcy5zdWJzY3JpYmVycy5kZWxldGUoZm4pO1xuICB9XG4gIGNhbmNlbCgpIHtcbiAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB0aGlzLnBlbmRpbmdLZXlzU2V0LmZvckVhY2goKHYsIGspID0+IHRoaXMucGVuZGluZ0tleXNTZXQuZGVsZXRlKGspKTtcbiAgICB0aGlzLmVtaXQodHJ1ZSk7XG4gIH1cbiAgYXN5bmMgcmVzb2x2ZURhdGEoc2lnbmFsKSB7XG4gICAgbGV0IGFib3J0ZWQgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuZG9uZSkge1xuICAgICAgbGV0IG9uQWJvcnQgPSAoKSA9PiB0aGlzLmNhbmNlbCgpO1xuICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICAgIGFib3J0ZWQgPSBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmUoYWJvcnRlZCA9PiB7XG4gICAgICAgICAgc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcbiAgICAgICAgICBpZiAoYWJvcnRlZCB8fCB0aGlzLmRvbmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUoYWJvcnRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYWJvcnRlZDtcbiAgfVxuICBnZXQgZG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wZW5kaW5nS2V5c1NldC5zaXplID09PSAwO1xuICB9XG4gIGdldCB1bndyYXBwZWREYXRhKCkge1xuICAgIGludmFyaWFudCh0aGlzLmRhdGEgIT09IG51bGwgJiYgdGhpcy5kb25lLCBcIkNhbiBvbmx5IHVud3JhcCBkYXRhIG9uIGluaXRpYWxpemVkIGFuZCBzZXR0bGVkIGRlZmVycmVkc1wiKTtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy5kYXRhKS5yZWR1Y2UoKGFjYywgX3JlZjMpID0+IHtcbiAgICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmMztcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjYywge1xuICAgICAgICBba2V5XTogdW53cmFwVHJhY2tlZFByb21pc2UodmFsdWUpXG4gICAgICB9KTtcbiAgICB9LCB7fSk7XG4gIH1cbiAgZ2V0IHBlbmRpbmdLZXlzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucGVuZGluZ0tleXNTZXQpO1xuICB9XG59XG5mdW5jdGlvbiBpc1RyYWNrZWRQcm9taXNlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFByb21pc2UgJiYgdmFsdWUuX3RyYWNrZWQgPT09IHRydWU7XG59XG5mdW5jdGlvbiB1bndyYXBUcmFja2VkUHJvbWlzZSh2YWx1ZSkge1xuICBpZiAoIWlzVHJhY2tlZFByb21pc2UodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZS5fZXJyb3IpIHtcbiAgICB0aHJvdyB2YWx1ZS5fZXJyb3I7XG4gIH1cbiAgcmV0dXJuIHZhbHVlLl9kYXRhO1xufVxuY29uc3QgZGVmZXIgPSBmdW5jdGlvbiBkZWZlcihkYXRhLCBpbml0KSB7XG4gIGlmIChpbml0ID09PSB2b2lkIDApIHtcbiAgICBpbml0ID0ge307XG4gIH1cbiAgbGV0IHJlc3BvbnNlSW5pdCA9IHR5cGVvZiBpbml0ID09PSBcIm51bWJlclwiID8ge1xuICAgIHN0YXR1czogaW5pdFxuICB9IDogaW5pdDtcbiAgcmV0dXJuIG5ldyBEZWZlcnJlZERhdGEoZGF0YSwgcmVzcG9uc2VJbml0KTtcbn07XG4vKipcbiAqIEEgcmVkaXJlY3QgcmVzcG9uc2UuIFNldHMgdGhlIHN0YXR1cyBjb2RlIGFuZCB0aGUgYExvY2F0aW9uYCBoZWFkZXIuXG4gKiBEZWZhdWx0cyB0byBcIjMwMiBGb3VuZFwiLlxuICovXG5jb25zdCByZWRpcmVjdCA9IGZ1bmN0aW9uIHJlZGlyZWN0KHVybCwgaW5pdCkge1xuICBpZiAoaW5pdCA9PT0gdm9pZCAwKSB7XG4gICAgaW5pdCA9IDMwMjtcbiAgfVxuICBsZXQgcmVzcG9uc2VJbml0ID0gaW5pdDtcbiAgaWYgKHR5cGVvZiByZXNwb25zZUluaXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICByZXNwb25zZUluaXQgPSB7XG4gICAgICBzdGF0dXM6IHJlc3BvbnNlSW5pdFxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlc3BvbnNlSW5pdC5zdGF0dXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXNwb25zZUluaXQuc3RhdHVzID0gMzAyO1xuICB9XG4gIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMocmVzcG9uc2VJbml0LmhlYWRlcnMpO1xuICBoZWFkZXJzLnNldChcIkxvY2F0aW9uXCIsIHVybCk7XG4gIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwgX2V4dGVuZHMoe30sIHJlc3BvbnNlSW5pdCwge1xuICAgIGhlYWRlcnNcbiAgfSkpO1xufTtcbi8qKlxuICogQSByZWRpcmVjdCByZXNwb25zZSB0aGF0IHdpbGwgZm9yY2UgYSBkb2N1bWVudCByZWxvYWQgdG8gdGhlIG5ldyBsb2NhdGlvbi5cbiAqIFNldHMgdGhlIHN0YXR1cyBjb2RlIGFuZCB0aGUgYExvY2F0aW9uYCBoZWFkZXIuXG4gKiBEZWZhdWx0cyB0byBcIjMwMiBGb3VuZFwiLlxuICovXG5jb25zdCByZWRpcmVjdERvY3VtZW50ID0gKHVybCwgaW5pdCkgPT4ge1xuICBsZXQgcmVzcG9uc2UgPSByZWRpcmVjdCh1cmwsIGluaXQpO1xuICByZXNwb25zZS5oZWFkZXJzLnNldChcIlgtUmVtaXgtUmVsb2FkLURvY3VtZW50XCIsIFwidHJ1ZVwiKTtcbiAgcmV0dXJuIHJlc3BvbnNlO1xufTtcbi8qKlxuICogQHByaXZhdGVcbiAqIFV0aWxpdHkgY2xhc3Mgd2UgdXNlIHRvIGhvbGQgYXV0by11bndyYXBwZWQgNHh4LzV4eCBSZXNwb25zZSBib2RpZXNcbiAqXG4gKiBXZSBkb24ndCBleHBvcnQgdGhlIGNsYXNzIGZvciBwdWJsaWMgdXNlIHNpbmNlIGl0J3MgYW4gaW1wbGVtZW50YXRpb25cbiAqIGRldGFpbCwgYnV0IHdlIGV4cG9ydCB0aGUgaW50ZXJmYWNlIGFib3ZlIHNvIGZvbGtzIGNhbiBidWlsZCB0aGVpciBvd25cbiAqIGFic3RyYWN0aW9ucyBhcm91bmQgaW5zdGFuY2VzIHZpYSBpc1JvdXRlRXJyb3JSZXNwb25zZSgpXG4gKi9cbmNsYXNzIEVycm9yUmVzcG9uc2VJbXBsIHtcbiAgY29uc3RydWN0b3Ioc3RhdHVzLCBzdGF0dXNUZXh0LCBkYXRhLCBpbnRlcm5hbCkge1xuICAgIGlmIChpbnRlcm5hbCA9PT0gdm9pZCAwKSB7XG4gICAgICBpbnRlcm5hbCA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0IHx8IFwiXCI7XG4gICAgdGhpcy5pbnRlcm5hbCA9IGludGVybmFsO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICAgIHRoaXMuZXJyb3IgPSBkYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgYW4gRXJyb3JSZXNwb25zZSBnZW5lcmF0ZWQgZnJvbSBhIDR4eC81eHhcbiAqIFJlc3BvbnNlIHRocm93biBmcm9tIGFuIGFjdGlvbi9sb2FkZXJcbiAqL1xuZnVuY3Rpb24gaXNSb3V0ZUVycm9yUmVzcG9uc2UoZXJyb3IpIHtcbiAgcmV0dXJuIGVycm9yICE9IG51bGwgJiYgdHlwZW9mIGVycm9yLnN0YXR1cyA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgZXJyb3Iuc3RhdHVzVGV4dCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZXJyb3IuaW50ZXJuYWwgPT09IFwiYm9vbGVhblwiICYmIFwiZGF0YVwiIGluIGVycm9yO1xufVxuXG5jb25zdCB2YWxpZE11dGF0aW9uTWV0aG9kc0FyciA9IFtcInBvc3RcIiwgXCJwdXRcIiwgXCJwYXRjaFwiLCBcImRlbGV0ZVwiXTtcbmNvbnN0IHZhbGlkTXV0YXRpb25NZXRob2RzID0gbmV3IFNldCh2YWxpZE11dGF0aW9uTWV0aG9kc0Fycik7XG5jb25zdCB2YWxpZFJlcXVlc3RNZXRob2RzQXJyID0gW1wiZ2V0XCIsIC4uLnZhbGlkTXV0YXRpb25NZXRob2RzQXJyXTtcbmNvbnN0IHZhbGlkUmVxdWVzdE1ldGhvZHMgPSBuZXcgU2V0KHZhbGlkUmVxdWVzdE1ldGhvZHNBcnIpO1xuY29uc3QgcmVkaXJlY3RTdGF0dXNDb2RlcyA9IG5ldyBTZXQoWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XSk7XG5jb25zdCByZWRpcmVjdFByZXNlcnZlTWV0aG9kU3RhdHVzQ29kZXMgPSBuZXcgU2V0KFszMDcsIDMwOF0pO1xuY29uc3QgSURMRV9OQVZJR0FUSU9OID0ge1xuICBzdGF0ZTogXCJpZGxlXCIsXG4gIGxvY2F0aW9uOiB1bmRlZmluZWQsXG4gIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxuICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICBqc29uOiB1bmRlZmluZWQsXG4gIHRleHQ6IHVuZGVmaW5lZFxufTtcbmNvbnN0IElETEVfRkVUQ0hFUiA9IHtcbiAgc3RhdGU6IFwiaWRsZVwiLFxuICBkYXRhOiB1bmRlZmluZWQsXG4gIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgZm9ybUFjdGlvbjogdW5kZWZpbmVkLFxuICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICBqc29uOiB1bmRlZmluZWQsXG4gIHRleHQ6IHVuZGVmaW5lZFxufTtcbmNvbnN0IElETEVfQkxPQ0tFUiA9IHtcbiAgc3RhdGU6IFwidW5ibG9ja2VkXCIsXG4gIHByb2NlZWQ6IHVuZGVmaW5lZCxcbiAgcmVzZXQ6IHVuZGVmaW5lZCxcbiAgbG9jYXRpb246IHVuZGVmaW5lZFxufTtcbmNvbnN0IEFCU09MVVRFX1VSTF9SRUdFWCA9IC9eKD86W2Etel1bYS16MC05Ky4tXSo6fFxcL1xcLykvaTtcbmNvbnN0IGRlZmF1bHRNYXBSb3V0ZVByb3BlcnRpZXMgPSByb3V0ZSA9PiAoe1xuICBoYXNFcnJvckJvdW5kYXJ5OiBCb29sZWFuKHJvdXRlLmhhc0Vycm9yQm91bmRhcnkpXG59KTtcbmNvbnN0IFRSQU5TSVRJT05TX1NUT1JBR0VfS0VZID0gXCJyZW1peC1yb3V0ZXItdHJhbnNpdGlvbnNcIjtcbi8vI2VuZHJlZ2lvblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vI3JlZ2lvbiBjcmVhdGVSb3V0ZXJcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vKipcbiAqIENyZWF0ZSBhIHJvdXRlciBhbmQgbGlzdGVuIHRvIGhpc3RvcnkgUE9QIG5hdmlnYXRpb25zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlcihpbml0KSB7XG4gIGNvbnN0IHJvdXRlcldpbmRvdyA9IGluaXQud2luZG93ID8gaW5pdC53aW5kb3cgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdW5kZWZpbmVkO1xuICBjb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygcm91dGVyV2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiByb3V0ZXJXaW5kb3cuZG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIHJvdXRlcldpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSBcInVuZGVmaW5lZFwiO1xuICBjb25zdCBpc1NlcnZlciA9ICFpc0Jyb3dzZXI7XG4gIGludmFyaWFudChpbml0LnJvdXRlcy5sZW5ndGggPiAwLCBcIllvdSBtdXN0IHByb3ZpZGUgYSBub24tZW1wdHkgcm91dGVzIGFycmF5IHRvIGNyZWF0ZVJvdXRlclwiKTtcbiAgbGV0IG1hcFJvdXRlUHJvcGVydGllcztcbiAgaWYgKGluaXQubWFwUm91dGVQcm9wZXJ0aWVzKSB7XG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzID0gaW5pdC5tYXBSb3V0ZVByb3BlcnRpZXM7XG4gIH0gZWxzZSBpZiAoaW5pdC5kZXRlY3RFcnJvckJvdW5kYXJ5KSB7XG4gICAgLy8gSWYgdGhleSBhcmUgc3RpbGwgdXNpbmcgdGhlIGRlcHJlY2F0ZWQgdmVyc2lvbiwgd3JhcCBpdCB3aXRoIHRoZSBuZXcgQVBJXG4gICAgbGV0IGRldGVjdEVycm9yQm91bmRhcnkgPSBpbml0LmRldGVjdEVycm9yQm91bmRhcnk7XG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzID0gcm91dGUgPT4gKHtcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IGRldGVjdEVycm9yQm91bmRhcnkocm91dGUpXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzID0gZGVmYXVsdE1hcFJvdXRlUHJvcGVydGllcztcbiAgfVxuICAvLyBSb3V0ZXMga2V5ZWQgYnkgSURcbiAgbGV0IG1hbmlmZXN0ID0ge307XG4gIC8vIFJvdXRlcyBpbiB0cmVlIGZvcm1hdCBmb3IgbWF0Y2hpbmdcbiAgbGV0IGRhdGFSb3V0ZXMgPSBjb252ZXJ0Um91dGVzVG9EYXRhUm91dGVzKGluaXQucm91dGVzLCBtYXBSb3V0ZVByb3BlcnRpZXMsIHVuZGVmaW5lZCwgbWFuaWZlc3QpO1xuICBsZXQgaW5GbGlnaHREYXRhUm91dGVzO1xuICBsZXQgYmFzZW5hbWUgPSBpbml0LmJhc2VuYW1lIHx8IFwiL1wiO1xuICAvLyBDb25maWcgZHJpdmVuIGJlaGF2aW9yIGZsYWdzXG4gIGxldCBmdXR1cmUgPSBfZXh0ZW5kcyh7XG4gICAgdjdfZmV0Y2hlclBlcnNpc3Q6IGZhbHNlLFxuICAgIHY3X25vcm1hbGl6ZUZvcm1NZXRob2Q6IGZhbHNlLFxuICAgIHY3X3ByZXBlbmRCYXNlbmFtZTogZmFsc2VcbiAgfSwgaW5pdC5mdXR1cmUpO1xuICAvLyBDbGVhbnVwIGZ1bmN0aW9uIGZvciBoaXN0b3J5XG4gIGxldCB1bmxpc3Rlbkhpc3RvcnkgPSBudWxsO1xuICAvLyBFeHRlcm5hbGx5LXByb3ZpZGVkIGZ1bmN0aW9ucyB0byBjYWxsIG9uIGFsbCBzdGF0ZSBjaGFuZ2VzXG4gIGxldCBzdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbiAgLy8gRXh0ZXJuYWxseS1wcm92aWRlZCBvYmplY3QgdG8gaG9sZCBzY3JvbGwgcmVzdG9yYXRpb24gbG9jYXRpb25zIGR1cmluZyByb3V0aW5nXG4gIGxldCBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IG51bGw7XG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgZnVuY3Rpb24gdG8gZ2V0IHNjcm9sbCByZXN0b3JhdGlvbiBrZXlzXG4gIGxldCBnZXRTY3JvbGxSZXN0b3JhdGlvbktleSA9IG51bGw7XG4gIC8vIEV4dGVybmFsbHktcHJvdmlkZWQgZnVuY3Rpb24gdG8gZ2V0IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXG4gIGxldCBnZXRTY3JvbGxQb3NpdGlvbiA9IG51bGw7XG4gIC8vIE9uZS10aW1lIGZsYWcgdG8gY29udHJvbCB0aGUgaW5pdGlhbCBoeWRyYXRpb24gc2Nyb2xsIHJlc3RvcmF0aW9uLiAgQmVjYXVzZVxuICAvLyB3ZSBkb24ndCBnZXQgdGhlIHNhdmVkIHBvc2l0aW9ucyBmcm9tIDxTY3JvbGxSZXN0b3JhdGlvbiAvPiB1bnRpbCBfYWZ0ZXJfXG4gIC8vIHRoZSBpbml0aWFsIHJlbmRlciwgd2UgbmVlZCB0byBtYW51YWxseSB0cmlnZ2VyIGEgc2VwYXJhdGUgdXBkYXRlU3RhdGUgdG9cbiAgLy8gc2VuZCBhbG9uZyB0aGUgcmVzdG9yZVNjcm9sbFBvc2l0aW9uXG4gIC8vIFNldCB0byB0cnVlIGlmIHdlIGhhdmUgYGh5ZHJhdGlvbkRhdGFgIHNpbmNlIHdlIGFzc3VtZSB3ZSB3ZXJlIFNTUidkIGFuZCB0aGF0XG4gIC8vIFNTUiBkaWQgdGhlIGluaXRpYWwgc2Nyb2xsIHJlc3RvcmF0aW9uLlxuICBsZXQgaW5pdGlhbFNjcm9sbFJlc3RvcmVkID0gaW5pdC5oeWRyYXRpb25EYXRhICE9IG51bGw7XG4gIGxldCBpbml0aWFsTWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGluaXQuaGlzdG9yeS5sb2NhdGlvbiwgYmFzZW5hbWUpO1xuICBsZXQgaW5pdGlhbEVycm9ycyA9IG51bGw7XG4gIGlmIChpbml0aWFsTWF0Y2hlcyA9PSBudWxsKSB7XG4gICAgLy8gSWYgd2UgZG8gbm90IG1hdGNoIGEgdXNlci1wcm92aWRlZC1yb3V0ZSwgZmFsbCBiYWNrIHRvIHRoZSByb290XG4gICAgLy8gdG8gYWxsb3cgdGhlIGVycm9yIGJvdW5kYXJ5IHRvIHRha2Ugb3ZlclxuICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICBwYXRobmFtZTogaW5pdC5oaXN0b3J5LmxvY2F0aW9uLnBhdGhuYW1lXG4gICAgfSk7XG4gICAgbGV0IHtcbiAgICAgIG1hdGNoZXMsXG4gICAgICByb3V0ZVxuICAgIH0gPSBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKGRhdGFSb3V0ZXMpO1xuICAgIGluaXRpYWxNYXRjaGVzID0gbWF0Y2hlcztcbiAgICBpbml0aWFsRXJyb3JzID0ge1xuICAgICAgW3JvdXRlLmlkXTogZXJyb3JcbiAgICB9O1xuICB9XG4gIGxldCBpbml0aWFsaXplZCA9XG4gIC8vIEFsbCBpbml0aWFsTWF0Y2hlcyBuZWVkIHRvIGJlIGxvYWRlZCBiZWZvcmUgd2UncmUgcmVhZHkuICBJZiB3ZSBoYXZlIGxhenlcbiAgLy8gZnVuY3Rpb25zIGFyb3VuZCBzdGlsbCB0aGVuIHdlJ2xsIG5lZWQgdG8gcnVuIHRoZW0gaW4gaW5pdGlhbGl6ZSgpXG4gICFpbml0aWFsTWF0Y2hlcy5zb21lKG0gPT4gbS5yb3V0ZS5sYXp5KSAmJiAoXG4gIC8vIEFuZCB3ZSBoYXZlIHRvIGVpdGhlciBoYXZlIG5vIGxvYWRlcnMgb3IgaGF2ZSBiZWVuIHByb3ZpZGVkIGh5ZHJhdGlvbkRhdGFcbiAgIWluaXRpYWxNYXRjaGVzLnNvbWUobSA9PiBtLnJvdXRlLmxvYWRlcikgfHwgaW5pdC5oeWRyYXRpb25EYXRhICE9IG51bGwpO1xuICBsZXQgcm91dGVyO1xuICBsZXQgc3RhdGUgPSB7XG4gICAgaGlzdG9yeUFjdGlvbjogaW5pdC5oaXN0b3J5LmFjdGlvbixcbiAgICBsb2NhdGlvbjogaW5pdC5oaXN0b3J5LmxvY2F0aW9uLFxuICAgIG1hdGNoZXM6IGluaXRpYWxNYXRjaGVzLFxuICAgIGluaXRpYWxpemVkLFxuICAgIG5hdmlnYXRpb246IElETEVfTkFWSUdBVElPTixcbiAgICAvLyBEb24ndCByZXN0b3JlIG9uIGluaXRpYWwgdXBkYXRlU3RhdGUoKSBpZiB3ZSB3ZXJlIFNTUidkXG4gICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiBpbml0Lmh5ZHJhdGlvbkRhdGEgIT0gbnVsbCA/IGZhbHNlIDogbnVsbCxcbiAgICBwcmV2ZW50U2Nyb2xsUmVzZXQ6IGZhbHNlLFxuICAgIHJldmFsaWRhdGlvbjogXCJpZGxlXCIsXG4gICAgbG9hZGVyRGF0YTogaW5pdC5oeWRyYXRpb25EYXRhICYmIGluaXQuaHlkcmF0aW9uRGF0YS5sb2FkZXJEYXRhIHx8IHt9LFxuICAgIGFjdGlvbkRhdGE6IGluaXQuaHlkcmF0aW9uRGF0YSAmJiBpbml0Lmh5ZHJhdGlvbkRhdGEuYWN0aW9uRGF0YSB8fCBudWxsLFxuICAgIGVycm9yczogaW5pdC5oeWRyYXRpb25EYXRhICYmIGluaXQuaHlkcmF0aW9uRGF0YS5lcnJvcnMgfHwgaW5pdGlhbEVycm9ycyxcbiAgICBmZXRjaGVyczogbmV3IE1hcCgpLFxuICAgIGJsb2NrZXJzOiBuZXcgTWFwKClcbiAgfTtcbiAgLy8gLS0gU3RhdGVmdWwgaW50ZXJuYWwgdmFyaWFibGVzIHRvIG1hbmFnZSBuYXZpZ2F0aW9ucyAtLVxuICAvLyBDdXJyZW50IG5hdmlnYXRpb24gaW4gcHJvZ3Jlc3MgKHRvIGJlIGNvbW1pdHRlZCBpbiBjb21wbGV0ZU5hdmlnYXRpb24pXG4gIGxldCBwZW5kaW5nQWN0aW9uID0gQWN0aW9uLlBvcDtcbiAgLy8gU2hvdWxkIHRoZSBjdXJyZW50IG5hdmlnYXRpb24gcHJldmVudCB0aGUgc2Nyb2xsIHJlc2V0IGlmIHNjcm9sbCBjYW5ub3RcbiAgLy8gYmUgcmVzdG9yZWQ/XG4gIGxldCBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gZmFsc2U7XG4gIC8vIEFib3J0Q29udHJvbGxlciBmb3IgdGhlIGFjdGl2ZSBuYXZpZ2F0aW9uXG4gIGxldCBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXI7XG4gIC8vIFNob3VsZCB0aGUgY3VycmVudCBuYXZpZ2F0aW9uIGVuYWJsZSBkb2N1bWVudC5zdGFydFZpZXdUcmFuc2l0aW9uP1xuICBsZXQgcGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICAvLyBTdG9yZSBhcHBsaWVkIHZpZXcgdHJhbnNpdGlvbnMgc28gd2UgY2FuIGFwcGx5IHRoZW0gb24gUE9QXG4gIGxldCBhcHBsaWVkVmlld1RyYW5zaXRpb25zID0gbmV3IE1hcCgpO1xuICAvLyBDbGVhbnVwIGZ1bmN0aW9uIGZvciBwZXJzaXN0aW5nIGFwcGxpZWQgdHJhbnNpdGlvbnMgdG8gc2Vzc2lvblN0b3JhZ2VcbiAgbGV0IHJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lciA9IG51bGw7XG4gIC8vIFdlIHVzZSB0aGlzIHRvIGF2b2lkIHRvdWNoaW5nIGhpc3RvcnkgaW4gY29tcGxldGVOYXZpZ2F0aW9uIGlmIGFcbiAgLy8gcmV2YWxpZGF0aW9uIGlzIGVudGlyZWx5IHVuaW50ZXJydXB0ZWRcbiAgbGV0IGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9IGZhbHNlO1xuICAvLyBVc2UgdGhpcyBpbnRlcm5hbCBmbGFnIHRvIGZvcmNlIHJldmFsaWRhdGlvbiBvZiBhbGwgbG9hZGVyczpcbiAgLy8gIC0gc3VibWlzc2lvbnMgKGNvbXBsZXRlZCBvciBpbnRlcnJ1cHRlZClcbiAgLy8gIC0gdXNlUmV2YWxpZGF0b3IoKVxuICAvLyAgLSBYLVJlbWl4LVJldmFsaWRhdGUgKGZyb20gcmVkaXJlY3QpXG4gIGxldCBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XG4gIC8vIFVzZSB0aGlzIGludGVybmFsIGFycmF5IHRvIGNhcHR1cmUgcm91dGVzIHRoYXQgcmVxdWlyZSByZXZhbGlkYXRpb24gZHVlXG4gIC8vIHRvIGEgY2FuY2VsbGVkIGRlZmVycmVkIG9uIGFjdGlvbiBzdWJtaXNzaW9uXG4gIGxldCBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcyA9IFtdO1xuICAvLyBVc2UgdGhpcyBpbnRlcm5hbCBhcnJheSB0byBjYXB0dXJlIGZldGNoZXIgbG9hZHMgdGhhdCB3ZXJlIGNhbmNlbGxlZCBieSBhblxuICAvLyBhY3Rpb24gbmF2aWdhdGlvbiBhbmQgcmVxdWlyZSByZXZhbGlkYXRpb25cbiAgbGV0IGNhbmNlbGxlZEZldGNoZXJMb2FkcyA9IFtdO1xuICAvLyBBYm9ydENvbnRyb2xsZXJzIGZvciBhbnkgaW4tZmxpZ2h0IGZldGNoZXJzXG4gIGxldCBmZXRjaENvbnRyb2xsZXJzID0gbmV3IE1hcCgpO1xuICAvLyBUcmFjayBsb2FkcyBiYXNlZCBvbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBzdGFydGVkXG4gIGxldCBpbmNyZW1lbnRpbmdMb2FkSWQgPSAwO1xuICAvLyBUcmFjayB0aGUgb3V0c3RhbmRpbmcgcGVuZGluZyBuYXZpZ2F0aW9uIGRhdGEgbG9hZCB0byBiZSBjb21wYXJlZCBhZ2FpbnN0XG4gIC8vIHRoZSBnbG9iYWxseSBpbmNyZW1lbnRpbmcgbG9hZCB3aGVuIGEgZmV0Y2hlciBsb2FkIGxhbmRzIGFmdGVyIGEgY29tcGxldGVkXG4gIC8vIG5hdmlnYXRpb25cbiAgbGV0IHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID0gLTE7XG4gIC8vIEZldGNoZXJzIHRoYXQgdHJpZ2dlcmVkIGRhdGEgcmVsb2FkcyBhcyBhIHJlc3VsdCBvZiB0aGVpciBhY3Rpb25zXG4gIGxldCBmZXRjaFJlbG9hZElkcyA9IG5ldyBNYXAoKTtcbiAgLy8gRmV0Y2hlcnMgdGhhdCB0cmlnZ2VyZWQgcmVkaXJlY3QgbmF2aWdhdGlvbnNcbiAgbGV0IGZldGNoUmVkaXJlY3RJZHMgPSBuZXcgU2V0KCk7XG4gIC8vIE1vc3QgcmVjZW50IGhyZWYvbWF0Y2ggZm9yIGZldGNoZXIubG9hZCBjYWxscyBmb3IgZmV0Y2hlcnNcbiAgbGV0IGZldGNoTG9hZE1hdGNoZXMgPSBuZXcgTWFwKCk7XG4gIC8vIFJlZi1jb3VudCBtb3VudGVkIGZldGNoZXJzIHNvIHdlIGtub3cgd2hlbiBpdCdzIG9rIHRvIGNsZWFuIHRoZW0gdXBcbiAgbGV0IGFjdGl2ZUZldGNoZXJzID0gbmV3IE1hcCgpO1xuICAvLyBGZXRjaGVycyB0aGF0IGhhdmUgcmVxdWVzdGVkIGEgZGVsZXRlIHdoZW4gdXNpbmcgdjdfZmV0Y2hlclBlcnNpc3QsXG4gIC8vIHRoZXknbGwgYmUgb2ZmaWNpYWxseSByZW1vdmVkIGFmdGVyIHRoZXkgcmV0dXJuIHRvIGlkbGVcbiAgbGV0IGRlbGV0ZWRGZXRjaGVycyA9IG5ldyBTZXQoKTtcbiAgLy8gU3RvcmUgRGVmZXJyZWREYXRhIGluc3RhbmNlcyBmb3IgYWN0aXZlIHJvdXRlIG1hdGNoZXMuICBXaGVuIGFcbiAgLy8gcm91dGUgbG9hZGVyIHJldHVybnMgZGVmZXIoKSB3ZSBzdGljayBvbmUgaW4gaGVyZS4gIFRoZW4sIHdoZW4gYSBuZXN0ZWRcbiAgLy8gcHJvbWlzZSByZXNvbHZlcyB3ZSB1cGRhdGUgbG9hZGVyRGF0YS4gIElmIGEgbmV3IG5hdmlnYXRpb24gc3RhcnRzIHdlXG4gIC8vIGNhbmNlbCBhY3RpdmUgZGVmZXJyZWRzIGZvciBlbGltaW5hdGVkIHJvdXRlcy5cbiAgbGV0IGFjdGl2ZURlZmVycmVkcyA9IG5ldyBNYXAoKTtcbiAgLy8gU3RvcmUgYmxvY2tlciBmdW5jdGlvbnMgaW4gYSBzZXBhcmF0ZSBNYXAgb3V0c2lkZSBvZiByb3V0ZXIgc3RhdGUgc2luY2VcbiAgLy8gd2UgZG9uJ3QgbmVlZCB0byB1cGRhdGUgVUkgc3RhdGUgaWYgdGhleSBjaGFuZ2VcbiAgbGV0IGJsb2NrZXJGdW5jdGlvbnMgPSBuZXcgTWFwKCk7XG4gIC8vIEZsYWcgdG8gaWdub3JlIHRoZSBuZXh0IGhpc3RvcnkgdXBkYXRlLCBzbyB3ZSBjYW4gcmV2ZXJ0IHRoZSBVUkwgY2hhbmdlIG9uXG4gIC8vIGEgUE9QIG5hdmlnYXRpb24gdGhhdCB3YXMgYmxvY2tlZCBieSB0aGUgdXNlciB3aXRob3V0IHRvdWNoaW5nIHJvdXRlciBzdGF0ZVxuICBsZXQgaWdub3JlTmV4dEhpc3RvcnlVcGRhdGUgPSBmYWxzZTtcbiAgLy8gSW5pdGlhbGl6ZSB0aGUgcm91dGVyLCBhbGwgc2lkZSBlZmZlY3RzIHNob3VsZCBiZSBraWNrZWQgb2ZmIGZyb20gaGVyZS5cbiAgLy8gSW1wbGVtZW50ZWQgYXMgYSBGbHVlbnQgQVBJIGZvciBlYXNlIG9mOlxuICAvLyAgIGxldCByb3V0ZXIgPSBjcmVhdGVSb3V0ZXIoaW5pdCkuaW5pdGlhbGl6ZSgpO1xuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIC8vIElmIGhpc3RvcnkgaW5mb3JtcyB1cyBvZiBhIFBPUCBuYXZpZ2F0aW9uLCBzdGFydCB0aGUgbmF2aWdhdGlvbiBidXQgZG8gbm90IHVwZGF0ZVxuICAgIC8vIHN0YXRlLiAgV2UnbGwgdXBkYXRlIG91ciBvd24gc3RhdGUgb25jZSB0aGUgbmF2aWdhdGlvbiBjb21wbGV0ZXNcbiAgICB1bmxpc3Rlbkhpc3RvcnkgPSBpbml0Lmhpc3RvcnkubGlzdGVuKF9yZWYgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgYWN0aW9uOiBoaXN0b3J5QWN0aW9uLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgZGVsdGFcbiAgICAgIH0gPSBfcmVmO1xuICAgICAgLy8gSWdub3JlIHRoaXMgZXZlbnQgaWYgaXQgd2FzIGp1c3QgdXMgcmVzZXR0aW5nIHRoZSBVUkwgZnJvbSBhXG4gICAgICAvLyBibG9ja2VkIFBPUCBuYXZpZ2F0aW9uXG4gICAgICBpZiAoaWdub3JlTmV4dEhpc3RvcnlVcGRhdGUpIHtcbiAgICAgICAgaWdub3JlTmV4dEhpc3RvcnlVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2FybmluZyhibG9ja2VyRnVuY3Rpb25zLnNpemUgPT09IDAgfHwgZGVsdGEgIT0gbnVsbCwgXCJZb3UgYXJlIHRyeWluZyB0byB1c2UgYSBibG9ja2VyIG9uIGEgUE9QIG5hdmlnYXRpb24gdG8gYSBsb2NhdGlvbiBcIiArIFwidGhhdCB3YXMgbm90IGNyZWF0ZWQgYnkgQHJlbWl4LXJ1bi9yb3V0ZXIuIFRoaXMgd2lsbCBmYWlsIHNpbGVudGx5IGluIFwiICsgXCJwcm9kdWN0aW9uLiBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IGFyZSBuYXZpZ2F0aW5nIG91dHNpZGUgdGhlIHJvdXRlciBcIiArIFwidmlhIGB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGVgL2B3aW5kb3cubG9jYXRpb24uaGFzaGAgaW5zdGVhZCBvZiB1c2luZyBcIiArIFwicm91dGVyIG5hdmlnYXRpb24gQVBJcy4gIFRoaXMgY2FuIGFsc28gaGFwcGVuIGlmIHlvdSBhcmUgdXNpbmcgXCIgKyBcImNyZWF0ZUhhc2hSb3V0ZXIgYW5kIHRoZSB1c2VyIG1hbnVhbGx5IGNoYW5nZXMgdGhlIFVSTC5cIik7XG4gICAgICBsZXQgYmxvY2tlcktleSA9IHNob3VsZEJsb2NrTmF2aWdhdGlvbih7XG4gICAgICAgIGN1cnJlbnRMb2NhdGlvbjogc3RhdGUubG9jYXRpb24sXG4gICAgICAgIG5leHRMb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICAgIH0pO1xuICAgICAgaWYgKGJsb2NrZXJLZXkgJiYgZGVsdGEgIT0gbnVsbCkge1xuICAgICAgICAvLyBSZXN0b3JlIHRoZSBVUkwgdG8gbWF0Y2ggdGhlIGN1cnJlbnQgVUksIGJ1dCBkb24ndCB1cGRhdGUgcm91dGVyIHN0YXRlXG4gICAgICAgIGlnbm9yZU5leHRIaXN0b3J5VXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgaW5pdC5oaXN0b3J5LmdvKGRlbHRhICogLTEpO1xuICAgICAgICAvLyBQdXQgdGhlIGJsb2NrZXIgaW50byBhIGJsb2NrZWQgc3RhdGVcbiAgICAgICAgdXBkYXRlQmxvY2tlcihibG9ja2VyS2V5LCB7XG4gICAgICAgICAgc3RhdGU6IFwiYmxvY2tlZFwiLFxuICAgICAgICAgIGxvY2F0aW9uLFxuICAgICAgICAgIHByb2NlZWQoKSB7XG4gICAgICAgICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgICAgICAgc3RhdGU6IFwicHJvY2VlZGluZ1wiLFxuICAgICAgICAgICAgICBwcm9jZWVkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIHJlc2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgIGxvY2F0aW9uXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFJlLWRvIHRoZSBzYW1lIFBPUCBuYXZpZ2F0aW9uIHdlIGp1c3QgYmxvY2tlZFxuICAgICAgICAgICAgaW5pdC5oaXN0b3J5LmdvKGRlbHRhKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlc2V0KCkge1xuICAgICAgICAgICAgbGV0IGJsb2NrZXJzID0gbmV3IE1hcChzdGF0ZS5ibG9ja2Vycyk7XG4gICAgICAgICAgICBibG9ja2Vycy5zZXQoYmxvY2tlcktleSwgSURMRV9CTE9DS0VSKTtcbiAgICAgICAgICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgICAgICAgICAgYmxvY2tlcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbG9jYXRpb24pO1xuICAgIH0pO1xuICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgIC8vIEZJWE1FOiBUaGlzIGZlZWxzIGdyb3NzLiAgSG93IGNhbiB3ZSBjbGVhbnVwIHRoZSBsaW5lcyBiZXR3ZWVuXG4gICAgICAvLyBzY3JvbGxSZXN0b3JhdGlvbi9hcHBsaWVkVHJhbnNpdGlvbnMgcGVyc2lzdGFuY2U/XG4gICAgICByZXN0b3JlQXBwbGllZFRyYW5zaXRpb25zKHJvdXRlcldpbmRvdywgYXBwbGllZFZpZXdUcmFuc2l0aW9ucyk7XG4gICAgICBsZXQgX3NhdmVBcHBsaWVkVHJhbnNpdGlvbnMgPSAoKSA9PiBwZXJzaXN0QXBwbGllZFRyYW5zaXRpb25zKHJvdXRlcldpbmRvdywgYXBwbGllZFZpZXdUcmFuc2l0aW9ucyk7XG4gICAgICByb3V0ZXJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIF9zYXZlQXBwbGllZFRyYW5zaXRpb25zKTtcbiAgICAgIHJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lciA9ICgpID0+IHJvdXRlcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicGFnZWhpZGVcIiwgX3NhdmVBcHBsaWVkVHJhbnNpdGlvbnMpO1xuICAgIH1cbiAgICAvLyBLaWNrIG9mZiBpbml0aWFsIGRhdGEgbG9hZCBpZiBuZWVkZWQuICBVc2UgUG9wIHRvIGF2b2lkIG1vZGlmeWluZyBoaXN0b3J5XG4gICAgLy8gTm90ZSB3ZSBkb24ndCBkbyBhbnkgaGFuZGxpbmcgb2YgbGF6eSBoZXJlLiAgRm9yIFNQQSdzIGl0J2xsIGdldCBoYW5kbGVkXG4gICAgLy8gaW4gdGhlIG5vcm1hbCBuYXZpZ2F0aW9uIGZsb3cuICBGb3IgU1NSIGl0J3MgZXhwZWN0ZWQgdGhhdCBsYXp5IG1vZHVsZXMgYXJlXG4gICAgLy8gcmVzb2x2ZWQgcHJpb3IgdG8gcm91dGVyIGNyZWF0aW9uIHNpbmNlIHdlIGNhbid0IGdvIGludG8gYSBmYWxsYmFja0VsZW1lbnRcbiAgICAvLyBVSSBmb3IgU1NSJ2QgYXBwc1xuICAgIGlmICghc3RhdGUuaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHN0YXJ0TmF2aWdhdGlvbihBY3Rpb24uUG9wLCBzdGF0ZS5sb2NhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiByb3V0ZXI7XG4gIH1cbiAgLy8gQ2xlYW4gdXAgYSByb3V0ZXIgYW5kIGl0J3Mgc2lkZSBlZmZlY3RzXG4gIGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgaWYgKHVubGlzdGVuSGlzdG9yeSkge1xuICAgICAgdW5saXN0ZW5IaXN0b3J5KCk7XG4gICAgfVxuICAgIGlmIChyZW1vdmVQYWdlSGlkZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lcigpO1xuICAgIH1cbiAgICBzdWJzY3JpYmVycy5jbGVhcigpO1xuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBzdGF0ZS5mZXRjaGVycy5mb3JFYWNoKChfLCBrZXkpID0+IGRlbGV0ZUZldGNoZXIoa2V5KSk7XG4gICAgc3RhdGUuYmxvY2tlcnMuZm9yRWFjaCgoXywga2V5KSA9PiBkZWxldGVCbG9ja2VyKGtleSkpO1xuICB9XG4gIC8vIFN1YnNjcmliZSB0byBzdGF0ZSB1cGRhdGVzIGZvciB0aGUgcm91dGVyXG4gIGZ1bmN0aW9uIHN1YnNjcmliZShmbikge1xuICAgIHN1YnNjcmliZXJzLmFkZChmbik7XG4gICAgcmV0dXJuICgpID0+IHN1YnNjcmliZXJzLmRlbGV0ZShmbik7XG4gIH1cbiAgLy8gVXBkYXRlIG91ciBzdGF0ZSBhbmQgbm90aWZ5IHRoZSBjYWxsaW5nIGNvbnRleHQgb2YgdGhlIGNoYW5nZVxuICBmdW5jdGlvbiB1cGRhdGVTdGF0ZShuZXdTdGF0ZSwgb3B0cykge1xuICAgIGlmIChvcHRzID09PSB2b2lkIDApIHtcbiAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgc3RhdGUgPSBfZXh0ZW5kcyh7fSwgc3RhdGUsIG5ld1N0YXRlKTtcbiAgICAvLyBQcmVwIGZldGNoZXIgY2xlYW51cCBzbyB3ZSBjYW4gdGVsbCB0aGUgVUkgd2hpY2ggZmV0Y2hlciBkYXRhIGVudHJpZXNcbiAgICAvLyBjYW4gYmUgcmVtb3ZlZFxuICAgIGxldCBjb21wbGV0ZWRGZXRjaGVycyA9IFtdO1xuICAgIGxldCBkZWxldGVkRmV0Y2hlcnNLZXlzID0gW107XG4gICAgaWYgKGZ1dHVyZS52N19mZXRjaGVyUGVyc2lzdCkge1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuZm9yRWFjaCgoZmV0Y2hlciwga2V5KSA9PiB7XG4gICAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImlkbGVcIikge1xuICAgICAgICAgIGlmIChkZWxldGVkRmV0Y2hlcnMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIC8vIFVubW91bnRlZCBmcm9tIHRoZSBVSSBhbmQgY2FuIGJlIHRvdGFsbHkgcmVtb3ZlZFxuICAgICAgICAgICAgZGVsZXRlZEZldGNoZXJzS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJldHVybmVkIHRvIGlkbGUgYnV0IHN0aWxsIG1vdW50ZWQgaW4gdGhlIFVJLCBzbyBzZW1pLXJlbWFpbnMgZm9yXG4gICAgICAgICAgICAvLyByZXZhbGlkYXRpb25zIGFuZCBzdWNoXG4gICAgICAgICAgICBjb21wbGV0ZWRGZXRjaGVycy5wdXNoKGtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGEgbG9jYWwgY29weSBzbyB0aGF0IGlmIGZsdXNoU3luYyBpcyB1c2VkIGFuZCB3ZSBlbmQgdXBcbiAgICAvLyByZW1vdmluZyBhbmQgYWRkaW5nIGEgbmV3IHN1YnNjcmliZXIgZHVlIHRvIHRoZSB1c2VDYWxsYmFjayBkZXBlbmRlbmNpZXMsXG4gICAgLy8gd2UgZG9uJ3QgZ2V0IG91cnNlbHZlcyBpbnRvIGEgbG9vcCBjYWxsaW5nIHRoZSBuZXcgc3Vic2NyaWJlciBpbW1lZGlhdGVseVxuICAgIFsuLi5zdWJzY3JpYmVyc10uZm9yRWFjaChzdWJzY3JpYmVyID0+IHN1YnNjcmliZXIoc3RhdGUsIHtcbiAgICAgIGRlbGV0ZWRGZXRjaGVyczogZGVsZXRlZEZldGNoZXJzS2V5cyxcbiAgICAgIHVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uT3B0czogb3B0cy52aWV3VHJhbnNpdGlvbk9wdHMsXG4gICAgICB1bnN0YWJsZV9mbHVzaFN5bmM6IG9wdHMuZmx1c2hTeW5jID09PSB0cnVlXG4gICAgfSkpO1xuICAgIC8vIFJlbW92ZSBpZGxlIGZldGNoZXJzIGZyb20gc3RhdGUgc2luY2Ugd2Ugb25seSBjYXJlIGFib3V0IGluLWZsaWdodCBmZXRjaGVycy5cbiAgICBpZiAoZnV0dXJlLnY3X2ZldGNoZXJQZXJzaXN0KSB7XG4gICAgICBjb21wbGV0ZWRGZXRjaGVycy5mb3JFYWNoKGtleSA9PiBzdGF0ZS5mZXRjaGVycy5kZWxldGUoa2V5KSk7XG4gICAgICBkZWxldGVkRmV0Y2hlcnNLZXlzLmZvckVhY2goa2V5ID0+IGRlbGV0ZUZldGNoZXIoa2V5KSk7XG4gICAgfVxuICB9XG4gIC8vIENvbXBsZXRlIGEgbmF2aWdhdGlvbiByZXR1cm5pbmcgdGhlIHN0YXRlLm5hdmlnYXRpb24gYmFjayB0byB0aGUgSURMRV9OQVZJR0FUSU9OXG4gIC8vIGFuZCBzZXR0aW5nIHN0YXRlLltoaXN0b3J5QWN0aW9uL2xvY2F0aW9uL21hdGNoZXNdIHRvIHRoZSBuZXcgcm91dGUuXG4gIC8vIC0gTG9jYXRpb24gaXMgYSByZXF1aXJlZCBwYXJhbVxuICAvLyAtIE5hdmlnYXRpb24gd2lsbCBhbHdheXMgYmUgc2V0IHRvIElETEVfTkFWSUdBVElPTlxuICAvLyAtIENhbiBwYXNzIGFueSBvdGhlciBzdGF0ZSBpbiBuZXdTdGF0ZVxuICBmdW5jdGlvbiBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIG5ld1N0YXRlLCBfdGVtcCkge1xuICAgIHZhciBfbG9jYXRpb24kc3RhdGUsIF9sb2NhdGlvbiRzdGF0ZTI7XG4gICAgbGV0IHtcbiAgICAgIGZsdXNoU3luY1xuICAgIH0gPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDtcbiAgICAvLyBEZWR1Y2UgaWYgd2UncmUgaW4gYSBsb2FkaW5nL2FjdGlvblJlbG9hZCBzdGF0ZTpcbiAgICAvLyAtIFdlIGhhdmUgY29tbWl0dGVkIGFjdGlvbkRhdGEgaW4gdGhlIHN0b3JlXG4gICAgLy8gLSBUaGUgY3VycmVudCBuYXZpZ2F0aW9uIHdhcyBhIG11dGF0aW9uIHN1Ym1pc3Npb25cbiAgICAvLyAtIFdlJ3JlIHBhc3QgdGhlIHN1Ym1pdHRpbmcgc3RhdGUgYW5kIGludG8gdGhlIGxvYWRpbmcgc3RhdGVcbiAgICAvLyAtIFRoZSBsb2NhdGlvbiBiZWluZyBsb2FkZWQgaXMgbm90IHRoZSByZXN1bHQgb2YgYSByZWRpcmVjdFxuICAgIGxldCBpc0FjdGlvblJlbG9hZCA9IHN0YXRlLmFjdGlvbkRhdGEgIT0gbnVsbCAmJiBzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QgIT0gbnVsbCAmJiBpc011dGF0aW9uTWV0aG9kKHN0YXRlLm5hdmlnYXRpb24uZm9ybU1ldGhvZCkgJiYgc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIgJiYgKChfbG9jYXRpb24kc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sb2NhdGlvbiRzdGF0ZS5faXNSZWRpcmVjdCkgIT09IHRydWU7XG4gICAgbGV0IGFjdGlvbkRhdGE7XG4gICAgaWYgKG5ld1N0YXRlLmFjdGlvbkRhdGEpIHtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhuZXdTdGF0ZS5hY3Rpb25EYXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGFjdGlvbkRhdGEgPSBuZXdTdGF0ZS5hY3Rpb25EYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRW1wdHkgYWN0aW9uRGF0YSAtPiBjbGVhciBwcmlvciBhY3Rpb25EYXRhIGR1ZSB0byBhbiBhY3Rpb24gZXJyb3JcbiAgICAgICAgYWN0aW9uRGF0YSA9IG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0FjdGlvblJlbG9hZCkge1xuICAgICAgLy8gS2VlcCB0aGUgY3VycmVudCBkYXRhIGlmIHdlJ3JlIHdyYXBwaW5nIHVwIHRoZSBhY3Rpb24gcmVsb2FkXG4gICAgICBhY3Rpb25EYXRhID0gc3RhdGUuYWN0aW9uRGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2xlYXIgYWN0aW9uRGF0YSBvbiBhbnkgb3RoZXIgY29tcGxldGVkIG5hdmlnYXRpb25zXG4gICAgICBhY3Rpb25EYXRhID0gbnVsbDtcbiAgICB9XG4gICAgLy8gQWx3YXlzIHByZXNlcnZlIGFueSBleGlzdGluZyBsb2FkZXJEYXRhIGZyb20gcmUtdXNlZCByb3V0ZXNcbiAgICBsZXQgbG9hZGVyRGF0YSA9IG5ld1N0YXRlLmxvYWRlckRhdGEgPyBtZXJnZUxvYWRlckRhdGEoc3RhdGUubG9hZGVyRGF0YSwgbmV3U3RhdGUubG9hZGVyRGF0YSwgbmV3U3RhdGUubWF0Y2hlcyB8fCBbXSwgbmV3U3RhdGUuZXJyb3JzKSA6IHN0YXRlLmxvYWRlckRhdGE7XG4gICAgLy8gT24gYSBzdWNjZXNzZnVsIG5hdmlnYXRpb24gd2UgY2FuIGFzc3VtZSB3ZSBnb3QgdGhyb3VnaCBhbGwgYmxvY2tlcnNcbiAgICAvLyBzbyB3ZSBjYW4gc3RhcnQgZnJlc2hcbiAgICBsZXQgYmxvY2tlcnMgPSBzdGF0ZS5ibG9ja2VycztcbiAgICBpZiAoYmxvY2tlcnMuc2l6ZSA+IDApIHtcbiAgICAgIGJsb2NrZXJzID0gbmV3IE1hcChibG9ja2Vycyk7XG4gICAgICBibG9ja2Vycy5mb3JFYWNoKChfLCBrKSA9PiBibG9ja2Vycy5zZXQoaywgSURMRV9CTE9DS0VSKSk7XG4gICAgfVxuICAgIC8vIEFsd2F5cyByZXNwZWN0IHRoZSB1c2VyIGZsYWcuICBPdGhlcndpc2UgZG9uJ3QgcmVzZXQgb24gbXV0YXRpb25cbiAgICAvLyBzdWJtaXNzaW9uIG5hdmlnYXRpb25zIHVubGVzcyB0aGV5IHJlZGlyZWN0XG4gICAgbGV0IHByZXZlbnRTY3JvbGxSZXNldCA9IHBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQgPT09IHRydWUgfHwgc3RhdGUubmF2aWdhdGlvbi5mb3JtTWV0aG9kICE9IG51bGwgJiYgaXNNdXRhdGlvbk1ldGhvZChzdGF0ZS5uYXZpZ2F0aW9uLmZvcm1NZXRob2QpICYmICgoX2xvY2F0aW9uJHN0YXRlMiA9IGxvY2F0aW9uLnN0YXRlKSA9PSBudWxsID8gdm9pZCAwIDogX2xvY2F0aW9uJHN0YXRlMi5faXNSZWRpcmVjdCkgIT09IHRydWU7XG4gICAgaWYgKGluRmxpZ2h0RGF0YVJvdXRlcykge1xuICAgICAgZGF0YVJvdXRlcyA9IGluRmxpZ2h0RGF0YVJvdXRlcztcbiAgICAgIGluRmxpZ2h0RGF0YVJvdXRlcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbikgOyBlbHNlIGlmIChwZW5kaW5nQWN0aW9uID09PSBBY3Rpb24uUG9wKSA7IGVsc2UgaWYgKHBlbmRpbmdBY3Rpb24gPT09IEFjdGlvbi5QdXNoKSB7XG4gICAgICBpbml0Lmhpc3RvcnkucHVzaChsb2NhdGlvbiwgbG9jYXRpb24uc3RhdGUpO1xuICAgIH0gZWxzZSBpZiAocGVuZGluZ0FjdGlvbiA9PT0gQWN0aW9uLlJlcGxhY2UpIHtcbiAgICAgIGluaXQuaGlzdG9yeS5yZXBsYWNlKGxvY2F0aW9uLCBsb2NhdGlvbi5zdGF0ZSk7XG4gICAgfVxuICAgIGxldCB2aWV3VHJhbnNpdGlvbk9wdHM7XG4gICAgLy8gT24gUE9QLCBlbmFibGUgdHJhbnNpdGlvbnMgaWYgdGhleSB3ZXJlIGVuYWJsZWQgb24gdGhlIG9yaWdpbmFsIG5hdmlnYXRpb25cbiAgICBpZiAocGVuZGluZ0FjdGlvbiA9PT0gQWN0aW9uLlBvcCkge1xuICAgICAgLy8gRm9yd2FyZCB0YWtlcyBwcmVjZWRlbmNlIHNvIHRoZXkgYmVoYXZlIGxpa2UgdGhlIG9yaWdpbmFsIG5hdmlnYXRpb25cbiAgICAgIGxldCBwcmlvclBhdGhzID0gYXBwbGllZFZpZXdUcmFuc2l0aW9ucy5nZXQoc3RhdGUubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgaWYgKHByaW9yUGF0aHMgJiYgcHJpb3JQYXRocy5oYXMobG9jYXRpb24ucGF0aG5hbWUpKSB7XG4gICAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyA9IHtcbiAgICAgICAgICBjdXJyZW50TG9jYXRpb246IHN0YXRlLmxvY2F0aW9uLFxuICAgICAgICAgIG5leHRMb2NhdGlvbjogbG9jYXRpb25cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoYXBwbGllZFZpZXdUcmFuc2l0aW9ucy5oYXMobG9jYXRpb24ucGF0aG5hbWUpKSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBwcmV2aW91cyBmb3J3YXJkIG5hdiwgYXNzdW1lIHdlJ3JlIHBvcHBpbmcgYmFjayB0b1xuICAgICAgICAvLyB0aGUgbmV3IGxvY2F0aW9uIGFuZCBlbmFibGUgaWYgdGhhdCBsb2NhdGlvbiBwcmV2aW91c2x5IGVuYWJsZWRcbiAgICAgICAgdmlld1RyYW5zaXRpb25PcHRzID0ge1xuICAgICAgICAgIGN1cnJlbnRMb2NhdGlvbjogbG9jYXRpb24sXG4gICAgICAgICAgbmV4dExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvblxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGVuZGluZ1ZpZXdUcmFuc2l0aW9uRW5hYmxlZCkge1xuICAgICAgLy8gU3RvcmUgdGhlIGFwcGxpZWQgdHJhbnNpdGlvbiBvbiBQVVNIL1JFUExBQ0VcbiAgICAgIGxldCB0b1BhdGhzID0gYXBwbGllZFZpZXdUcmFuc2l0aW9ucy5nZXQoc3RhdGUubG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgaWYgKHRvUGF0aHMpIHtcbiAgICAgICAgdG9QYXRocy5hZGQobG9jYXRpb24ucGF0aG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG9QYXRocyA9IG5ldyBTZXQoW2xvY2F0aW9uLnBhdGhuYW1lXSk7XG4gICAgICAgIGFwcGxpZWRWaWV3VHJhbnNpdGlvbnMuc2V0KHN0YXRlLmxvY2F0aW9uLnBhdGhuYW1lLCB0b1BhdGhzKTtcbiAgICAgIH1cbiAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyA9IHtcbiAgICAgICAgY3VycmVudExvY2F0aW9uOiBzdGF0ZS5sb2NhdGlvbixcbiAgICAgICAgbmV4dExvY2F0aW9uOiBsb2NhdGlvblxuICAgICAgfTtcbiAgICB9XG4gICAgdXBkYXRlU3RhdGUoX2V4dGVuZHMoe30sIG5ld1N0YXRlLCB7XG4gICAgICBhY3Rpb25EYXRhLFxuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGhpc3RvcnlBY3Rpb246IHBlbmRpbmdBY3Rpb24sXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGluaXRpYWxpemVkOiB0cnVlLFxuICAgICAgbmF2aWdhdGlvbjogSURMRV9OQVZJR0FUSU9OLFxuICAgICAgcmV2YWxpZGF0aW9uOiBcImlkbGVcIixcbiAgICAgIHJlc3RvcmVTY3JvbGxQb3NpdGlvbjogZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihsb2NhdGlvbiwgbmV3U3RhdGUubWF0Y2hlcyB8fCBzdGF0ZS5tYXRjaGVzKSxcbiAgICAgIHByZXZlbnRTY3JvbGxSZXNldCxcbiAgICAgIGJsb2NrZXJzXG4gICAgfSksIHtcbiAgICAgIHZpZXdUcmFuc2l0aW9uT3B0cyxcbiAgICAgIGZsdXNoU3luYzogZmx1c2hTeW5jID09PSB0cnVlXG4gICAgfSk7XG4gICAgLy8gUmVzZXQgc3RhdGVmdWwgbmF2aWdhdGlvbiB2YXJzXG4gICAgcGVuZGluZ0FjdGlvbiA9IEFjdGlvbi5Qb3A7XG4gICAgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IGZhbHNlO1xuICAgIHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgPSBmYWxzZTtcbiAgICBpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24gPSBmYWxzZTtcbiAgICBpc1JldmFsaWRhdGlvblJlcXVpcmVkID0gZmFsc2U7XG4gICAgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMgPSBbXTtcbiAgICBjYW5jZWxsZWRGZXRjaGVyTG9hZHMgPSBbXTtcbiAgfVxuICAvLyBUcmlnZ2VyIGEgbmF2aWdhdGlvbiBldmVudCwgd2hpY2ggY2FuIGVpdGhlciBiZSBhIG51bWVyaWNhbCBQT1Agb3IgYSBQVVNIXG4gIC8vIHJlcGxhY2Ugd2l0aCBhbiBvcHRpb25hbCBzdWJtaXNzaW9uXG4gIGFzeW5jIGZ1bmN0aW9uIG5hdmlnYXRlKHRvLCBvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiB0byA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaW5pdC5oaXN0b3J5LmdvKHRvKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplVG8oc3RhdGUubG9jYXRpb24sIHN0YXRlLm1hdGNoZXMsIGJhc2VuYW1lLCBmdXR1cmUudjdfcHJlcGVuZEJhc2VuYW1lLCB0bywgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5mcm9tUm91dGVJZCwgb3B0cyA9PSBudWxsID8gdm9pZCAwIDogb3B0cy5yZWxhdGl2ZSk7XG4gICAgbGV0IHtcbiAgICAgIHBhdGgsXG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgZXJyb3JcbiAgICB9ID0gbm9ybWFsaXplTmF2aWdhdGVPcHRpb25zKGZ1dHVyZS52N19ub3JtYWxpemVGb3JtTWV0aG9kLCBmYWxzZSwgbm9ybWFsaXplZFBhdGgsIG9wdHMpO1xuICAgIGxldCBjdXJyZW50TG9jYXRpb24gPSBzdGF0ZS5sb2NhdGlvbjtcbiAgICBsZXQgbmV4dExvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oc3RhdGUubG9jYXRpb24sIHBhdGgsIG9wdHMgJiYgb3B0cy5zdGF0ZSk7XG4gICAgLy8gV2hlbiB1c2luZyBuYXZpZ2F0ZSBhcyBhIFBVU0gvUkVQTEFDRSB3ZSBhcmVuJ3QgcmVhZGluZyBhbiBhbHJlYWR5LWVuY29kZWRcbiAgICAvLyBVUkwgZnJvbSB3aW5kb3cubG9jYXRpb24sIHNvIHdlIG5lZWQgdG8gZW5jb2RlIGl0IGhlcmUgc28gdGhlIGJlaGF2aW9yXG4gICAgLy8gcmVtYWlucyB0aGUgc2FtZSBhcyBQT1AgYW5kIG5vbi1kYXRhLXJvdXRlciB1c2FnZXMuICBuZXcgVVJMKCkgZG9lcyBhbGxcbiAgICAvLyB0aGUgc2FtZSBlbmNvZGluZyB3ZSdkIGdldCBmcm9tIGEgaGlzdG9yeS5wdXNoU3RhdGUvd2luZG93LmxvY2F0aW9uIHJlYWRcbiAgICAvLyB3aXRob3V0IGhhdmluZyB0byB0b3VjaCBoaXN0b3J5XG4gICAgbmV4dExvY2F0aW9uID0gX2V4dGVuZHMoe30sIG5leHRMb2NhdGlvbiwgaW5pdC5oaXN0b3J5LmVuY29kZUxvY2F0aW9uKG5leHRMb2NhdGlvbikpO1xuICAgIGxldCB1c2VyUmVwbGFjZSA9IG9wdHMgJiYgb3B0cy5yZXBsYWNlICE9IG51bGwgPyBvcHRzLnJlcGxhY2UgOiB1bmRlZmluZWQ7XG4gICAgbGV0IGhpc3RvcnlBY3Rpb24gPSBBY3Rpb24uUHVzaDtcbiAgICBpZiAodXNlclJlcGxhY2UgPT09IHRydWUpIHtcbiAgICAgIGhpc3RvcnlBY3Rpb24gPSBBY3Rpb24uUmVwbGFjZTtcbiAgICB9IGVsc2UgaWYgKHVzZXJSZXBsYWNlID09PSBmYWxzZSkgOyBlbHNlIGlmIChzdWJtaXNzaW9uICE9IG51bGwgJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpICYmIHN1Ym1pc3Npb24uZm9ybUFjdGlvbiA9PT0gc3RhdGUubG9jYXRpb24ucGF0aG5hbWUgKyBzdGF0ZS5sb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgIC8vIEJ5IGRlZmF1bHQgb24gc3VibWlzc2lvbnMgdG8gdGhlIGN1cnJlbnQgbG9jYXRpb24gd2UgUkVQTEFDRSBzbyB0aGF0XG4gICAgICAvLyB1c2VycyBkb24ndCBoYXZlIHRvIGRvdWJsZS1jbGljayB0aGUgYmFjayBidXR0b24gdG8gZ2V0IHRvIHRoZSBwcmlvclxuICAgICAgLy8gbG9jYXRpb24uICBJZiB0aGUgdXNlciByZWRpcmVjdHMgdG8gYSBkaWZmZXJlbnQgbG9jYXRpb24gZnJvbSB0aGVcbiAgICAgIC8vIGFjdGlvbi9sb2FkZXIgdGhpcyB3aWxsIGJlIGlnbm9yZWQgYW5kIHRoZSByZWRpcmVjdCB3aWxsIGJlIGEgUFVTSFxuICAgICAgaGlzdG9yeUFjdGlvbiA9IEFjdGlvbi5SZXBsYWNlO1xuICAgIH1cbiAgICBsZXQgcHJldmVudFNjcm9sbFJlc2V0ID0gb3B0cyAmJiBcInByZXZlbnRTY3JvbGxSZXNldFwiIGluIG9wdHMgPyBvcHRzLnByZXZlbnRTY3JvbGxSZXNldCA9PT0gdHJ1ZSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgZmx1c2hTeW5jID0gKG9wdHMgJiYgb3B0cy51bnN0YWJsZV9mbHVzaFN5bmMpID09PSB0cnVlO1xuICAgIGxldCBibG9ja2VyS2V5ID0gc2hvdWxkQmxvY2tOYXZpZ2F0aW9uKHtcbiAgICAgIGN1cnJlbnRMb2NhdGlvbixcbiAgICAgIG5leHRMb2NhdGlvbixcbiAgICAgIGhpc3RvcnlBY3Rpb25cbiAgICB9KTtcbiAgICBpZiAoYmxvY2tlcktleSkge1xuICAgICAgLy8gUHV0IHRoZSBibG9ja2VyIGludG8gYSBibG9ja2VkIHN0YXRlXG4gICAgICB1cGRhdGVCbG9ja2VyKGJsb2NrZXJLZXksIHtcbiAgICAgICAgc3RhdGU6IFwiYmxvY2tlZFwiLFxuICAgICAgICBsb2NhdGlvbjogbmV4dExvY2F0aW9uLFxuICAgICAgICBwcm9jZWVkKCkge1xuICAgICAgICAgIHVwZGF0ZUJsb2NrZXIoYmxvY2tlcktleSwge1xuICAgICAgICAgICAgc3RhdGU6IFwicHJvY2VlZGluZ1wiLFxuICAgICAgICAgICAgcHJvY2VlZDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVzZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxvY2F0aW9uOiBuZXh0TG9jYXRpb25cbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBTZW5kIHRoZSBzYW1lIG5hdmlnYXRpb24gdGhyb3VnaFxuICAgICAgICAgIG5hdmlnYXRlKHRvLCBvcHRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXQoKSB7XG4gICAgICAgICAgbGV0IGJsb2NrZXJzID0gbmV3IE1hcChzdGF0ZS5ibG9ja2Vycyk7XG4gICAgICAgICAgYmxvY2tlcnMuc2V0KGJsb2NrZXJLZXksIElETEVfQkxPQ0tFUik7XG4gICAgICAgICAgdXBkYXRlU3RhdGUoe1xuICAgICAgICAgICAgYmxvY2tlcnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbmV4dExvY2F0aW9uLCB7XG4gICAgICBzdWJtaXNzaW9uLFxuICAgICAgLy8gU2VuZCB0aHJvdWdoIHRoZSBmb3JtRGF0YSBzZXJpYWxpemF0aW9uIGVycm9yIGlmIHdlIGhhdmUgb25lIHNvIHdlIGNhblxuICAgICAgLy8gcmVuZGVyIGF0IHRoZSByaWdodCBlcnJvciBib3VuZGFyeSBhZnRlciB3ZSBtYXRjaCByb3V0ZXNcbiAgICAgIHBlbmRpbmdFcnJvcjogZXJyb3IsXG4gICAgICBwcmV2ZW50U2Nyb2xsUmVzZXQsXG4gICAgICByZXBsYWNlOiBvcHRzICYmIG9wdHMucmVwbGFjZSxcbiAgICAgIGVuYWJsZVZpZXdUcmFuc2l0aW9uOiBvcHRzICYmIG9wdHMudW5zdGFibGVfdmlld1RyYW5zaXRpb24sXG4gICAgICBmbHVzaFN5bmNcbiAgICB9KTtcbiAgfVxuICAvLyBSZXZhbGlkYXRlIGFsbCBjdXJyZW50IGxvYWRlcnMuICBJZiBhIG5hdmlnYXRpb24gaXMgaW4gcHJvZ3Jlc3Mgb3IgaWYgdGhpc1xuICAvLyBpcyBpbnRlcnJ1cHRlZCBieSBhIG5hdmlnYXRpb24sIGFsbG93IHRoaXMgdG8gXCJzdWNjZWVkXCIgYnkgY2FsbGluZyBhbGxcbiAgLy8gbG9hZGVycyBkdXJpbmcgdGhlIG5leHQgbG9hZGVyIHJvdW5kXG4gIGZ1bmN0aW9uIHJldmFsaWRhdGUoKSB7XG4gICAgaW50ZXJydXB0QWN0aXZlTG9hZHMoKTtcbiAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICByZXZhbGlkYXRpb246IFwibG9hZGluZ1wiXG4gICAgfSk7XG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IHN1Ym1pdHRpbmcgYW4gYWN0aW9uLCB3ZSBkb24ndCBuZWVkIHRvIHN0YXJ0IGEgbmV3XG4gICAgLy8gbmF2aWdhdGlvbiwgd2UnbGwganVzdCBsZXQgdGhlIGZvbGxvdyB1cCBsb2FkZXIgZXhlY3V0aW9uIGNhbGwgYWxsIGxvYWRlcnNcbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJzdWJtaXR0aW5nXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGluIGFuIGlkbGUgc3RhdGUsIHN0YXJ0IGEgbmV3IG5hdmlnYXRpb24gZm9yIHRoZSBjdXJyZW50XG4gICAgLy8gYWN0aW9uL2xvY2F0aW9uIGFuZCBtYXJrIGl0IGFzIHVuaW50ZXJydXB0ZWQsIHdoaWNoIHdpbGwgc2tpcCB0aGUgaGlzdG9yeVxuICAgIC8vIHVwZGF0ZSBpbiBjb21wbGV0ZU5hdmlnYXRpb25cbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJpZGxlXCIpIHtcbiAgICAgIHN0YXJ0TmF2aWdhdGlvbihzdGF0ZS5oaXN0b3J5QWN0aW9uLCBzdGF0ZS5sb2NhdGlvbiwge1xuICAgICAgICBzdGFydFVuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb246IHRydWVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UsIGlmIHdlJ3JlIGN1cnJlbnRseSBpbiBhIGxvYWRpbmcgc3RhdGUsIGp1c3Qgc3RhcnQgYSBuZXdcbiAgICAvLyBuYXZpZ2F0aW9uIHRvIHRoZSBuYXZpZ2F0aW9uLmxvY2F0aW9uIGJ1dCBkbyBub3QgdHJpZ2dlciBhbiB1bmludGVycnVwdGVkXG4gICAgLy8gcmV2YWxpZGF0aW9uIHNvIHRoYXQgaGlzdG9yeSBjb3JyZWN0bHkgdXBkYXRlcyBvbmNlIHRoZSBuYXZpZ2F0aW9uIGNvbXBsZXRlc1xuICAgIHN0YXJ0TmF2aWdhdGlvbihwZW5kaW5nQWN0aW9uIHx8IHN0YXRlLmhpc3RvcnlBY3Rpb24sIHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sIHtcbiAgICAgIG92ZXJyaWRlTmF2aWdhdGlvbjogc3RhdGUubmF2aWdhdGlvblxuICAgIH0pO1xuICB9XG4gIC8vIFN0YXJ0IGEgbmF2aWdhdGlvbiB0byB0aGUgZ2l2ZW4gYWN0aW9uL2xvY2F0aW9uLiAgQ2FuIG9wdGlvbmFsbHkgcHJvdmlkZSBhXG4gIC8vIG92ZXJyaWRlTmF2aWdhdGlvbiB3aGljaCB3aWxsIG92ZXJyaWRlIHRoZSBub3JtYWxMb2FkIGluIHRoZSBjYXNlIG9mIGEgcmVkaXJlY3RcbiAgLy8gbmF2aWdhdGlvblxuICBhc3luYyBmdW5jdGlvbiBzdGFydE5hdmlnYXRpb24oaGlzdG9yeUFjdGlvbiwgbG9jYXRpb24sIG9wdHMpIHtcbiAgICAvLyBBYm9ydCBhbnkgaW4tcHJvZ3Jlc3MgbmF2aWdhdGlvbnMgYW5kIHN0YXJ0IGEgbmV3IG9uZS4gVW5zZXQgYW55IG9uZ29pbmdcbiAgICAvLyB1bmludGVycnVwdGVkIHJldmFsaWRhdGlvbnMgdW5sZXNzIHRvbGQgb3RoZXJ3aXNlLCBzaW5jZSB3ZSB3YW50IHRoaXNcbiAgICAvLyBuZXcgbmF2aWdhdGlvbiB0byB1cGRhdGUgaGlzdG9yeSBub3JtYWxseVxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciAmJiBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBudWxsO1xuICAgIHBlbmRpbmdBY3Rpb24gPSBoaXN0b3J5QWN0aW9uO1xuICAgIGlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiA9IChvcHRzICYmIG9wdHMuc3RhcnRVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uKSA9PT0gdHJ1ZTtcbiAgICAvLyBTYXZlIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBldmVyeSB0aW1lIHdlIHN0YXJ0IGEgbmV3IG5hdmlnYXRpb24sXG4gICAgLy8gYW5kIHRyYWNrIHdoZXRoZXIgd2Ugc2hvdWxkIHJlc2V0IHNjcm9sbCBvbiBjb21wbGV0aW9uXG4gICAgc2F2ZVNjcm9sbFBvc2l0aW9uKHN0YXRlLmxvY2F0aW9uLCBzdGF0ZS5tYXRjaGVzKTtcbiAgICBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0ID0gKG9wdHMgJiYgb3B0cy5wcmV2ZW50U2Nyb2xsUmVzZXQpID09PSB0cnVlO1xuICAgIHBlbmRpbmdWaWV3VHJhbnNpdGlvbkVuYWJsZWQgPSAob3B0cyAmJiBvcHRzLmVuYWJsZVZpZXdUcmFuc2l0aW9uKSA9PT0gdHJ1ZTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbG9hZGluZ05hdmlnYXRpb24gPSBvcHRzICYmIG9wdHMub3ZlcnJpZGVOYXZpZ2F0aW9uO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gICAgbGV0IGZsdXNoU3luYyA9IChvcHRzICYmIG9wdHMuZmx1c2hTeW5jKSA9PT0gdHJ1ZTtcbiAgICAvLyBTaG9ydCBjaXJjdWl0IHdpdGggYSA0MDQgb24gdGhlIHJvb3QgZXJyb3IgYm91bmRhcnkgaWYgd2UgbWF0Y2ggbm90aGluZ1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICB9KTtcbiAgICAgIGxldCB7XG4gICAgICAgIG1hdGNoZXM6IG5vdEZvdW5kTWF0Y2hlcyxcbiAgICAgICAgcm91dGVcbiAgICAgIH0gPSBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKHJvdXRlc1RvVXNlKTtcbiAgICAgIC8vIENhbmNlbCBhbGwgcGVuZGluZyBkZWZlcnJlZCBvbiA0MDRzIHNpbmNlIHdlIGRvbid0IGtlZXAgYW55IHJvdXRlc1xuICAgICAgY2FuY2VsQWN0aXZlRGVmZXJyZWRzKCk7XG4gICAgICBjb21wbGV0ZU5hdmlnYXRpb24obG9jYXRpb24sIHtcbiAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3JcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBmbHVzaFN5bmNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIGl0J3Mgb25seSBhIGhhc2ggY2hhbmdlIGFuZCBub3QgYSByZXZhbGlkYXRpb24gb3JcbiAgICAvLyBtdXRhdGlvbiBzdWJtaXNzaW9uLlxuICAgIC8vXG4gICAgLy8gSWdub3JlIG9uIGluaXRpYWwgcGFnZSBsb2FkcyBiZWNhdXNlIHNpbmNlIHRoZSBpbml0aWFsIGxvYWQgd2lsbCBhbHdheXNcbiAgICAvLyBiZSBcInNhbWUgaGFzaFwiLiAgRm9yIGV4YW1wbGUsIG9uIC9wYWdlI2hhc2ggYW5kIHN1Ym1pdCBhIDxGb3JtIG1ldGhvZD1cInBvc3RcIj5cbiAgICAvLyB3aGljaCB3aWxsIGRlZmF1bHQgdG8gYSBuYXZpZ2F0aW9uIHRvIC9wYWdlXG4gICAgaWYgKHN0YXRlLmluaXRpYWxpemVkICYmICFpc1JldmFsaWRhdGlvblJlcXVpcmVkICYmIGlzSGFzaENoYW5nZU9ubHkoc3RhdGUubG9jYXRpb24sIGxvY2F0aW9uKSAmJiAhKG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qob3B0cy5zdWJtaXNzaW9uLmZvcm1NZXRob2QpKSkge1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCB7XG4gICAgICAgIG1hdGNoZXNcbiAgICAgIH0sIHtcbiAgICAgICAgZmx1c2hTeW5jXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgY29udHJvbGxlci9SZXF1ZXN0IGZvciB0aGlzIG5hdmlnYXRpb25cbiAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IHJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChpbml0Lmhpc3RvcnksIGxvY2F0aW9uLCBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuc2lnbmFsLCBvcHRzICYmIG9wdHMuc3VibWlzc2lvbik7XG4gICAgbGV0IHBlbmRpbmdBY3Rpb25EYXRhO1xuICAgIGxldCBwZW5kaW5nRXJyb3I7XG4gICAgaWYgKG9wdHMgJiYgb3B0cy5wZW5kaW5nRXJyb3IpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgYSBwZW5kaW5nRXJyb3IsIGl0IG1lYW5zIHRoZSB1c2VyIGF0dGVtcHRlZCBhIEdFVCBzdWJtaXNzaW9uXG4gICAgICAvLyB3aXRoIGJpbmFyeSBGb3JtRGF0YSBzbyBhc3NpZ24gaGVyZSBhbmQgc2tpcCB0byBoYW5kbGVMb2FkZXJzLiAgVGhhdFxuICAgICAgLy8gd2F5IHdlIGhhbmRsZSBjYWxsaW5nIGxvYWRlcnMgYWJvdmUgdGhlIGJvdW5kYXJ5IGV0Yy4gIEl0J3Mgbm90IHJlYWxseVxuICAgICAgLy8gZGlmZmVyZW50IGZyb20gYW4gYWN0aW9uRXJyb3IgaW4gdGhhdCBzZW5zZS5cbiAgICAgIHBlbmRpbmdFcnJvciA9IHtcbiAgICAgICAgW2ZpbmROZWFyZXN0Qm91bmRhcnkobWF0Y2hlcykucm91dGUuaWRdOiBvcHRzLnBlbmRpbmdFcnJvclxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uICYmIGlzTXV0YXRpb25NZXRob2Qob3B0cy5zdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgICAvLyBDYWxsIGFjdGlvbiBpZiB3ZSByZWNlaXZlZCBhbiBhY3Rpb24gc3VibWlzc2lvblxuICAgICAgbGV0IGFjdGlvbk91dHB1dCA9IGF3YWl0IGhhbmRsZUFjdGlvbihyZXF1ZXN0LCBsb2NhdGlvbiwgb3B0cy5zdWJtaXNzaW9uLCBtYXRjaGVzLCB7XG4gICAgICAgIHJlcGxhY2U6IG9wdHMucmVwbGFjZSxcbiAgICAgICAgZmx1c2hTeW5jXG4gICAgICB9KTtcbiAgICAgIGlmIChhY3Rpb25PdXRwdXQuc2hvcnRDaXJjdWl0ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcGVuZGluZ0FjdGlvbkRhdGEgPSBhY3Rpb25PdXRwdXQucGVuZGluZ0FjdGlvbkRhdGE7XG4gICAgICBwZW5kaW5nRXJyb3IgPSBhY3Rpb25PdXRwdXQucGVuZGluZ0FjdGlvbkVycm9yO1xuICAgICAgbG9hZGluZ05hdmlnYXRpb24gPSBnZXRMb2FkaW5nTmF2aWdhdGlvbihsb2NhdGlvbiwgb3B0cy5zdWJtaXNzaW9uKTtcbiAgICAgIGZsdXNoU3luYyA9IGZhbHNlO1xuICAgICAgLy8gQ3JlYXRlIGEgR0VUIHJlcXVlc3QgZm9yIHRoZSBsb2FkZXJzXG4gICAgICByZXF1ZXN0ID0gbmV3IFJlcXVlc3QocmVxdWVzdC51cmwsIHtcbiAgICAgICAgc2lnbmFsOiByZXF1ZXN0LnNpZ25hbFxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIENhbGwgbG9hZGVyc1xuICAgIGxldCB7XG4gICAgICBzaG9ydENpcmN1aXRlZCxcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnNcbiAgICB9ID0gYXdhaXQgaGFuZGxlTG9hZGVycyhyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgbG9hZGluZ05hdmlnYXRpb24sIG9wdHMgJiYgb3B0cy5zdWJtaXNzaW9uLCBvcHRzICYmIG9wdHMuZmV0Y2hlclN1Ym1pc3Npb24sIG9wdHMgJiYgb3B0cy5yZXBsYWNlLCBmbHVzaFN5bmMsIHBlbmRpbmdBY3Rpb25EYXRhLCBwZW5kaW5nRXJyb3IpO1xuICAgIGlmIChzaG9ydENpcmN1aXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBDbGVhbiB1cCBub3cgdGhhdCB0aGUgYWN0aW9uL2xvYWRlcnMgaGF2ZSBjb21wbGV0ZWQuICBEb24ndCBjbGVhbiB1cCBpZlxuICAgIC8vIHdlIHNob3J0IGNpcmN1aXRlZCBiZWNhdXNlIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciB3aWxsIGhhdmUgYWxyZWFkeVxuICAgIC8vIGJlZW4gYXNzaWduZWQgdG8gYSBuZXcgY29udHJvbGxlciBmb3IgdGhlIG5leHQgbmF2aWdhdGlvblxuICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlciA9IG51bGw7XG4gICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCBfZXh0ZW5kcyh7XG4gICAgICBtYXRjaGVzXG4gICAgfSwgcGVuZGluZ0FjdGlvbkRhdGEgPyB7XG4gICAgICBhY3Rpb25EYXRhOiBwZW5kaW5nQWN0aW9uRGF0YVxuICAgIH0gOiB7fSwge1xuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9yc1xuICAgIH0pKTtcbiAgfVxuICAvLyBDYWxsIHRoZSBhY3Rpb24gbWF0Y2hlZCBieSB0aGUgbGVhZiByb3V0ZSBmb3IgdGhpcyBuYXZpZ2F0aW9uIGFuZCBoYW5kbGVcbiAgLy8gcmVkaXJlY3RzL2Vycm9yc1xuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVBY3Rpb24ocmVxdWVzdCwgbG9jYXRpb24sIHN1Ym1pc3Npb24sIG1hdGNoZXMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG4gICAgLy8gUHV0IHVzIGluIGEgc3VibWl0dGluZyBzdGF0ZVxuICAgIGxldCBuYXZpZ2F0aW9uID0gZ2V0U3VibWl0dGluZ05hdmlnYXRpb24obG9jYXRpb24sIHN1Ym1pc3Npb24pO1xuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIG5hdmlnYXRpb25cbiAgICB9LCB7XG4gICAgICBmbHVzaFN5bmM6IG9wdHMuZmx1c2hTeW5jID09PSB0cnVlXG4gICAgfSk7XG4gICAgLy8gQ2FsbCBvdXIgYWN0aW9uIGFuZCBnZXQgdGhlIHJlc3VsdFxuICAgIGxldCByZXN1bHQ7XG4gICAgbGV0IGFjdGlvbk1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pO1xuICAgIGlmICghYWN0aW9uTWF0Y2gucm91dGUuYWN0aW9uICYmICFhY3Rpb25NYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICByZXN1bHQgPSB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZXJyb3IsXG4gICAgICAgIGVycm9yOiBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgcGF0aG5hbWU6IGxvY2F0aW9uLnBhdGhuYW1lLFxuICAgICAgICAgIHJvdXRlSWQ6IGFjdGlvbk1hdGNoLnJvdXRlLmlkXG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBhd2FpdCBjYWxsTG9hZGVyT3JBY3Rpb24oXCJhY3Rpb25cIiwgcmVxdWVzdCwgYWN0aW9uTWF0Y2gsIG1hdGNoZXMsIG1hbmlmZXN0LCBtYXBSb3V0ZVByb3BlcnRpZXMsIGJhc2VuYW1lKTtcbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc2hvcnRDaXJjdWl0ZWQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgbGV0IHJlcGxhY2U7XG4gICAgICBpZiAob3B0cyAmJiBvcHRzLnJlcGxhY2UgIT0gbnVsbCkge1xuICAgICAgICByZXBsYWNlID0gb3B0cy5yZXBsYWNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgZGlkbid0IGV4cGxpY2l0eSBpbmRpY2F0ZSByZXBsYWNlIGJlaGF2aW9yLCByZXBsYWNlIGlmXG4gICAgICAgIC8vIHdlIHJlZGlyZWN0ZWQgdG8gdGhlIGV4YWN0IHNhbWUgbG9jYXRpb24gd2UncmUgY3VycmVudGx5IGF0IHRvIGF2b2lkXG4gICAgICAgIC8vIGRvdWJsZSBiYWNrLWJ1dHRvbnNcbiAgICAgICAgcmVwbGFjZSA9IHJlc3VsdC5sb2NhdGlvbiA9PT0gc3RhdGUubG9jYXRpb24ucGF0aG5hbWUgKyBzdGF0ZS5sb2NhdGlvbi5zZWFyY2g7XG4gICAgICB9XG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgcmVzdWx0LCB7XG4gICAgICAgIHN1Ym1pc3Npb24sXG4gICAgICAgIHJlcGxhY2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2hvcnRDaXJjdWl0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFN0b3JlIG9mZiB0aGUgcGVuZGluZyBlcnJvciAtIHdlIHVzZSBpdCB0byBkZXRlcm1pbmUgd2hpY2ggbG9hZGVyc1xuICAgICAgLy8gdG8gY2FsbCBhbmQgd2lsbCBjb21taXQgaXQgd2hlbiB3ZSBjb21wbGV0ZSB0aGUgbmF2aWdhdGlvblxuICAgICAgbGV0IGJvdW5kYXJ5TWF0Y2ggPSBmaW5kTmVhcmVzdEJvdW5kYXJ5KG1hdGNoZXMsIGFjdGlvbk1hdGNoLnJvdXRlLmlkKTtcbiAgICAgIC8vIEJ5IGRlZmF1bHQsIGFsbCBzdWJtaXNzaW9ucyBhcmUgUkVQTEFDRSBuYXZpZ2F0aW9ucywgYnV0IGlmIHRoZVxuICAgICAgLy8gYWN0aW9uIHRocmV3IGFuIGVycm9yIHRoYXQnbGwgYmUgcmVuZGVyZWQgaW4gYW4gZXJyb3JFbGVtZW50LCB3ZSBmYWxsXG4gICAgICAvLyBiYWNrIHRvIFBVU0ggc28gdGhhdCB0aGUgdXNlciBjYW4gdXNlIHRoZSBiYWNrIGJ1dHRvbiB0byBnZXQgYmFjayB0b1xuICAgICAgLy8gdGhlIHByZS1zdWJtaXNzaW9uIGZvcm0gbG9jYXRpb24gdG8gdHJ5IGFnYWluXG4gICAgICBpZiAoKG9wdHMgJiYgb3B0cy5yZXBsYWNlKSAhPT0gdHJ1ZSkge1xuICAgICAgICBwZW5kaW5nQWN0aW9uID0gQWN0aW9uLlB1c2g7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvLyBTZW5kIGJhY2sgYW4gZW1wdHkgb2JqZWN0IHdlIGNhbiB1c2UgdG8gY2xlYXIgb3V0IGFueSBwcmlvciBhY3Rpb25EYXRhXG4gICAgICAgIHBlbmRpbmdBY3Rpb25EYXRhOiB7fSxcbiAgICAgICAgcGVuZGluZ0FjdGlvbkVycm9yOiB7XG4gICAgICAgICAgW2JvdW5kYXJ5TWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZXJyb3JcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHtcbiAgICAgICAgdHlwZTogXCJkZWZlci1hY3Rpb25cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBwZW5kaW5nQWN0aW9uRGF0YToge1xuICAgICAgICBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLy8gQ2FsbCBhbGwgYXBwbGljYWJsZSBsb2FkZXJzIGZvciB0aGUgZ2l2ZW4gbWF0Y2hlcywgaGFuZGxpbmcgcmVkaXJlY3RzLFxuICAvLyBlcnJvcnMsIGV0Yy5cbiAgYXN5bmMgZnVuY3Rpb24gaGFuZGxlTG9hZGVycyhyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgb3ZlcnJpZGVOYXZpZ2F0aW9uLCBzdWJtaXNzaW9uLCBmZXRjaGVyU3VibWlzc2lvbiwgcmVwbGFjZSwgZmx1c2hTeW5jLCBwZW5kaW5nQWN0aW9uRGF0YSwgcGVuZGluZ0Vycm9yKSB7XG4gICAgLy8gRmlndXJlIG91dCB0aGUgcmlnaHQgbmF2aWdhdGlvbiB3ZSB3YW50IHRvIHVzZSBmb3IgZGF0YSBsb2FkaW5nXG4gICAgbGV0IGxvYWRpbmdOYXZpZ2F0aW9uID0gb3ZlcnJpZGVOYXZpZ2F0aW9uIHx8IGdldExvYWRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKTtcbiAgICAvLyBJZiB0aGlzIHdhcyBhIHJlZGlyZWN0IGZyb20gYW4gYWN0aW9uIHdlIGRvbid0IGhhdmUgYSBcInN1Ym1pc3Npb25cIiBidXRcbiAgICAvLyB3ZSBoYXZlIGl0IG9uIHRoZSBsb2FkaW5nIG5hdmlnYXRpb24gc28gdXNlIHRoYXQgaWYgYXZhaWxhYmxlXG4gICAgbGV0IGFjdGl2ZVN1Ym1pc3Npb24gPSBzdWJtaXNzaW9uIHx8IGZldGNoZXJTdWJtaXNzaW9uIHx8IGdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbihsb2FkaW5nTmF2aWdhdGlvbik7XG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IFttYXRjaGVzVG9Mb2FkLCByZXZhbGlkYXRpbmdGZXRjaGVyc10gPSBnZXRNYXRjaGVzVG9Mb2FkKGluaXQuaGlzdG9yeSwgc3RhdGUsIG1hdGNoZXMsIGFjdGl2ZVN1Ym1pc3Npb24sIGxvY2F0aW9uLCBpc1JldmFsaWRhdGlvblJlcXVpcmVkLCBjYW5jZWxsZWREZWZlcnJlZFJvdXRlcywgY2FuY2VsbGVkRmV0Y2hlckxvYWRzLCBkZWxldGVkRmV0Y2hlcnMsIGZldGNoTG9hZE1hdGNoZXMsIGZldGNoUmVkaXJlY3RJZHMsIHJvdXRlc1RvVXNlLCBiYXNlbmFtZSwgcGVuZGluZ0FjdGlvbkRhdGEsIHBlbmRpbmdFcnJvcik7XG4gICAgLy8gQ2FuY2VsIHBlbmRpbmcgZGVmZXJyZWRzIGZvciBuby1sb25nZXItbWF0Y2hlZCByb3V0ZXMgb3Igcm91dGVzIHdlJ3JlXG4gICAgLy8gYWJvdXQgdG8gcmVsb2FkLiAgTm90ZSB0aGF0IGlmIHRoaXMgaXMgYW4gYWN0aW9uIHJlbG9hZCB3ZSB3b3VsZCBoYXZlXG4gICAgLy8gYWxyZWFkeSBjYW5jZWxsZWQgYWxsIHBlbmRpbmcgZGVmZXJyZWRzIHNvIHRoaXMgd291bGQgYmUgYSBuby1vcFxuICAgIGNhbmNlbEFjdGl2ZURlZmVycmVkcyhyb3V0ZUlkID0+ICEobWF0Y2hlcyAmJiBtYXRjaGVzLnNvbWUobSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSkgfHwgbWF0Y2hlc1RvTG9hZCAmJiBtYXRjaGVzVG9Mb2FkLnNvbWUobSA9PiBtLnJvdXRlLmlkID09PSByb3V0ZUlkKSk7XG4gICAgcGVuZGluZ05hdmlnYXRpb25Mb2FkSWQgPSArK2luY3JlbWVudGluZ0xvYWRJZDtcbiAgICAvLyBTaG9ydCBjaXJjdWl0IGlmIHdlIGhhdmUgbm8gbG9hZGVycyB0byBydW5cbiAgICBpZiAobWF0Y2hlc1RvTG9hZC5sZW5ndGggPT09IDAgJiYgcmV2YWxpZGF0aW5nRmV0Y2hlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBsZXQgdXBkYXRlZEZldGNoZXJzID0gbWFya0ZldGNoUmVkaXJlY3RzRG9uZSgpO1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKGxvY2F0aW9uLCBfZXh0ZW5kcyh7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICAvLyBDb21taXQgcGVuZGluZyBlcnJvciBpZiB3ZSdyZSBzaG9ydCBjaXJjdWl0aW5nXG4gICAgICAgIGVycm9yczogcGVuZGluZ0Vycm9yIHx8IG51bGxcbiAgICAgIH0sIHBlbmRpbmdBY3Rpb25EYXRhID8ge1xuICAgICAgICBhY3Rpb25EYXRhOiBwZW5kaW5nQWN0aW9uRGF0YVxuICAgICAgfSA6IHt9LCB1cGRhdGVkRmV0Y2hlcnMgPyB7XG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSA6IHt9KSwge1xuICAgICAgICBmbHVzaFN5bmNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2hvcnRDaXJjdWl0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIElmIHRoaXMgaXMgYW4gdW5pbnRlcnJ1cHRlZCByZXZhbGlkYXRpb24sIHdlIHJlbWFpbiBpbiBvdXIgY3VycmVudCBpZGxlXG4gICAgLy8gc3RhdGUuICBJZiBub3QsIHdlIG5lZWQgdG8gc3dpdGNoIHRvIG91ciBsb2FkaW5nIHN0YXRlIGFuZCBsb2FkIGRhdGEsXG4gICAgLy8gcHJlc2VydmluZyBhbnkgbmV3IGFjdGlvbiBkYXRhIG9yIGV4aXN0aW5nIGFjdGlvbiBkYXRhIChpbiB0aGUgY2FzZSBvZlxuICAgIC8vIGEgcmV2YWxpZGF0aW9uIGludGVycnVwdGluZyBhbiBhY3Rpb25SZWxvYWQpXG4gICAgaWYgKCFpc1VuaW50ZXJydXB0ZWRSZXZhbGlkYXRpb24pIHtcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZvckVhY2gocmYgPT4ge1xuICAgICAgICBsZXQgZmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChyZi5rZXkpO1xuICAgICAgICBsZXQgcmV2YWxpZGF0aW5nRmV0Y2hlciA9IGdldExvYWRpbmdGZXRjaGVyKHVuZGVmaW5lZCwgZmV0Y2hlciA/IGZldGNoZXIuZGF0YSA6IHVuZGVmaW5lZCk7XG4gICAgICAgIHN0YXRlLmZldGNoZXJzLnNldChyZi5rZXksIHJldmFsaWRhdGluZ0ZldGNoZXIpO1xuICAgICAgfSk7XG4gICAgICBsZXQgYWN0aW9uRGF0YSA9IHBlbmRpbmdBY3Rpb25EYXRhIHx8IHN0YXRlLmFjdGlvbkRhdGE7XG4gICAgICB1cGRhdGVTdGF0ZShfZXh0ZW5kcyh7XG4gICAgICAgIG5hdmlnYXRpb246IGxvYWRpbmdOYXZpZ2F0aW9uXG4gICAgICB9LCBhY3Rpb25EYXRhID8gT2JqZWN0LmtleXMoYWN0aW9uRGF0YSkubGVuZ3RoID09PSAwID8ge1xuICAgICAgICBhY3Rpb25EYXRhOiBudWxsXG4gICAgICB9IDoge1xuICAgICAgICBhY3Rpb25EYXRhXG4gICAgICB9IDoge30sIHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA+IDAgPyB7XG4gICAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgICAgfSA6IHt9KSwge1xuICAgICAgICBmbHVzaFN5bmNcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKHJmID0+IHtcbiAgICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhyZi5rZXkpKSB7XG4gICAgICAgIGFib3J0RmV0Y2hlcihyZi5rZXkpO1xuICAgICAgfVxuICAgICAgaWYgKHJmLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgLy8gRmV0Y2hlcnMgdXNlIGFuIGluZGVwZW5kZW50IEFib3J0Q29udHJvbGxlciBzbyB0aGF0IGFib3J0aW5nIGEgZmV0Y2hlclxuICAgICAgICAvLyAodmlhIGRlbGV0ZUZldGNoZXIpIGRvZXMgbm90IGFib3J0IHRoZSB0cmlnZ2VyaW5nIG5hdmlnYXRpb24gdGhhdFxuICAgICAgICAvLyB0cmlnZ2VyZWQgdGhlIHJldmFsaWRhdGlvblxuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLnNldChyZi5rZXksIHJmLmNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIFByb3h5IG5hdmlnYXRpb24gYWJvcnQgdGhyb3VnaCB0byByZXZhbGlkYXRpb24gZmV0Y2hlcnNcbiAgICBsZXQgYWJvcnRQZW5kaW5nRmV0Y2hSZXZhbGlkYXRpb25zID0gKCkgPT4gcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaChmID0+IGFib3J0RmV0Y2hlcihmLmtleSkpO1xuICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIpIHtcbiAgICAgIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcihcImFib3J0XCIsIGFib3J0UGVuZGluZ0ZldGNoUmV2YWxpZGF0aW9ucyk7XG4gICAgfVxuICAgIGxldCB7XG4gICAgICByZXN1bHRzLFxuICAgICAgbG9hZGVyUmVzdWx0cyxcbiAgICAgIGZldGNoZXJSZXN1bHRzXG4gICAgfSA9IGF3YWl0IGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShzdGF0ZS5tYXRjaGVzLCBtYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCByZXZhbGlkYXRpbmdGZXRjaGVycywgcmVxdWVzdCk7XG4gICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNob3J0Q2lyY3VpdGVkOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBDbGVhbiB1cCBfYWZ0ZXJfIGxvYWRlcnMgaGF2ZSBjb21wbGV0ZWQuICBEb24ndCBjbGVhbiB1cCBpZiB3ZSBzaG9ydFxuICAgIC8vIGNpcmN1aXRlZCBiZWNhdXNlIGZldGNoQ29udHJvbGxlcnMgd291bGQgaGF2ZSBiZWVuIGFib3J0ZWQgYW5kXG4gICAgLy8gcmVhc3NpZ25lZCB0byBuZXcgY29udHJvbGxlcnMgZm9yIHRoZSBuZXh0IG5hdmlnYXRpb25cbiAgICBpZiAocGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyKSB7XG4gICAgICBwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMpO1xuICAgIH1cbiAgICByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKHJmID0+IGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKHJmLmtleSkpO1xuICAgIC8vIElmIGFueSBsb2FkZXJzIHJldHVybmVkIGEgcmVkaXJlY3QgUmVzcG9uc2UsIHN0YXJ0IGEgbmV3IFJFUExBQ0UgbmF2aWdhdGlvblxuICAgIGxldCByZWRpcmVjdCA9IGZpbmRSZWRpcmVjdChyZXN1bHRzKTtcbiAgICBpZiAocmVkaXJlY3QpIHtcbiAgICAgIGlmIChyZWRpcmVjdC5pZHggPj0gbWF0Y2hlc1RvTG9hZC5sZW5ndGgpIHtcbiAgICAgICAgLy8gSWYgdGhpcyByZWRpcmVjdCBjYW1lIGZyb20gYSBmZXRjaGVyIG1ha2Ugc3VyZSB3ZSBtYXJrIGl0IGluXG4gICAgICAgIC8vIGZldGNoUmVkaXJlY3RJZHMgc28gaXQgZG9lc24ndCBnZXQgcmV2YWxpZGF0ZWQgb24gdGhlIG5leHQgc2V0IG9mXG4gICAgICAgIC8vIGxvYWRlciBleGVjdXRpb25zXG4gICAgICAgIGxldCBmZXRjaGVyS2V5ID0gcmV2YWxpZGF0aW5nRmV0Y2hlcnNbcmVkaXJlY3QuaWR4IC0gbWF0Y2hlc1RvTG9hZC5sZW5ndGhdLmtleTtcbiAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5hZGQoZmV0Y2hlcktleSk7XG4gICAgICB9XG4gICAgICBhd2FpdCBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgcmVkaXJlY3QucmVzdWx0LCB7XG4gICAgICAgIHJlcGxhY2VcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2hvcnRDaXJjdWl0ZWQ6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIFByb2Nlc3MgYW5kIGNvbW1pdCBvdXRwdXQgZnJvbSBsb2FkZXJzXG4gICAgbGV0IHtcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnNcbiAgICB9ID0gcHJvY2Vzc0xvYWRlckRhdGEoc3RhdGUsIG1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIGxvYWRlclJlc3VsdHMsIHBlbmRpbmdFcnJvciwgcmV2YWxpZGF0aW5nRmV0Y2hlcnMsIGZldGNoZXJSZXN1bHRzLCBhY3RpdmVEZWZlcnJlZHMpO1xuICAgIC8vIFdpcmUgdXAgc3Vic2NyaWJlcnMgdG8gdXBkYXRlIGxvYWRlckRhdGEgYXMgcHJvbWlzZXMgc2V0dGxlXG4gICAgYWN0aXZlRGVmZXJyZWRzLmZvckVhY2goKGRlZmVycmVkRGF0YSwgcm91dGVJZCkgPT4ge1xuICAgICAgZGVmZXJyZWREYXRhLnN1YnNjcmliZShhYm9ydGVkID0+IHtcbiAgICAgICAgLy8gTm90ZTogTm8gbmVlZCB0byB1cGRhdGVTdGF0ZSBoZXJlIHNpbmNlIHRoZSBUcmFja2VkUHJvbWlzZSBvblxuICAgICAgICAvLyBsb2FkZXJEYXRhIGlzIHN0YWJsZSBhY3Jvc3MgcmVzb2x2ZS9yZWplY3RcbiAgICAgICAgLy8gUmVtb3ZlIHRoaXMgaW5zdGFuY2UgaWYgd2Ugd2VyZSBhYm9ydGVkIG9yIGlmIHByb21pc2VzIGhhdmUgc2V0dGxlZFxuICAgICAgICBpZiAoYWJvcnRlZCB8fCBkZWZlcnJlZERhdGEuZG9uZSkge1xuICAgICAgICAgIGFjdGl2ZURlZmVycmVkcy5kZWxldGUocm91dGVJZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGxldCB1cGRhdGVkRmV0Y2hlcnMgPSBtYXJrRmV0Y2hSZWRpcmVjdHNEb25lKCk7XG4gICAgbGV0IGRpZEFib3J0RmV0Y2hMb2FkcyA9IGFib3J0U3RhbGVGZXRjaExvYWRzKHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkKTtcbiAgICBsZXQgc2hvdWxkVXBkYXRlRmV0Y2hlcnMgPSB1cGRhdGVkRmV0Y2hlcnMgfHwgZGlkQWJvcnRGZXRjaExvYWRzIHx8IHJldmFsaWRhdGluZ0ZldGNoZXJzLmxlbmd0aCA+IDA7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGxvYWRlckRhdGEsXG4gICAgICBlcnJvcnNcbiAgICB9LCBzaG91bGRVcGRhdGVGZXRjaGVycyA/IHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0gOiB7fSk7XG4gIH1cbiAgLy8gVHJpZ2dlciBhIGZldGNoZXIgbG9hZC9zdWJtaXQgZm9yIHRoZSBnaXZlbiBmZXRjaGVyIGtleVxuICBmdW5jdGlvbiBmZXRjaChrZXksIHJvdXRlSWQsIGhyZWYsIG9wdHMpIHtcbiAgICBpZiAoaXNTZXJ2ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInJvdXRlci5mZXRjaCgpIHdhcyBjYWxsZWQgZHVyaW5nIHRoZSBzZXJ2ZXIgcmVuZGVyLCBidXQgaXQgc2hvdWxkbid0IGJlLiBcIiArIFwiWW91IGFyZSBsaWtlbHkgY2FsbGluZyBhIHVzZUZldGNoZXIoKSBtZXRob2QgaW4gdGhlIGJvZHkgb2YgeW91ciBjb21wb25lbnQuIFwiICsgXCJUcnkgbW92aW5nIGl0IHRvIGEgdXNlRWZmZWN0IG9yIGEgY2FsbGJhY2suXCIpO1xuICAgIH1cbiAgICBpZiAoZmV0Y2hDb250cm9sbGVycy5oYXMoa2V5KSkgYWJvcnRGZXRjaGVyKGtleSk7XG4gICAgbGV0IGZsdXNoU3luYyA9IChvcHRzICYmIG9wdHMudW5zdGFibGVfZmx1c2hTeW5jKSA9PT0gdHJ1ZTtcbiAgICBsZXQgcm91dGVzVG9Vc2UgPSBpbkZsaWdodERhdGFSb3V0ZXMgfHwgZGF0YVJvdXRlcztcbiAgICBsZXQgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVUbyhzdGF0ZS5sb2NhdGlvbiwgc3RhdGUubWF0Y2hlcywgYmFzZW5hbWUsIGZ1dHVyZS52N19wcmVwZW5kQmFzZW5hbWUsIGhyZWYsIHJvdXRlSWQsIG9wdHMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdHMucmVsYXRpdmUpO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMocm91dGVzVG9Vc2UsIG5vcm1hbGl6ZWRQYXRoLCBiYXNlbmFtZSk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgICBwYXRobmFtZTogbm9ybWFsaXplZFBhdGhcbiAgICAgIH0pLCB7XG4gICAgICAgIGZsdXNoU3luY1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB7XG4gICAgICBwYXRoLFxuICAgICAgc3VibWlzc2lvbixcbiAgICAgIGVycm9yXG4gICAgfSA9IG5vcm1hbGl6ZU5hdmlnYXRlT3B0aW9ucyhmdXR1cmUudjdfbm9ybWFsaXplRm9ybU1ldGhvZCwgdHJ1ZSwgbm9ybWFsaXplZFBhdGgsIG9wdHMpO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgZXJyb3IsIHtcbiAgICAgICAgZmx1c2hTeW5jXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IG1hdGNoID0gZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgcGF0aCk7XG4gICAgcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldCA9IChvcHRzICYmIG9wdHMucHJldmVudFNjcm9sbFJlc2V0KSA9PT0gdHJ1ZTtcbiAgICBpZiAoc3VibWlzc2lvbiAmJiBpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICAgIGhhbmRsZUZldGNoZXJBY3Rpb24oa2V5LCByb3V0ZUlkLCBwYXRoLCBtYXRjaCwgbWF0Y2hlcywgZmx1c2hTeW5jLCBzdWJtaXNzaW9uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gU3RvcmUgb2ZmIHRoZSBtYXRjaCBzbyB3ZSBjYW4gY2FsbCBpdCdzIHNob3VsZFJldmFsaWRhdGUgb24gc3Vic2VxdWVudFxuICAgIC8vIHJldmFsaWRhdGlvbnNcbiAgICBmZXRjaExvYWRNYXRjaGVzLnNldChrZXksIHtcbiAgICAgIHJvdXRlSWQsXG4gICAgICBwYXRoXG4gICAgfSk7XG4gICAgaGFuZGxlRmV0Y2hlckxvYWRlcihrZXksIHJvdXRlSWQsIHBhdGgsIG1hdGNoLCBtYXRjaGVzLCBmbHVzaFN5bmMsIHN1Ym1pc3Npb24pO1xuICB9XG4gIC8vIENhbGwgdGhlIGFjdGlvbiBmb3IgdGhlIG1hdGNoZWQgZmV0Y2hlci5zdWJtaXQoKSwgYW5kIHRoZW4gaGFuZGxlIHJlZGlyZWN0cyxcbiAgLy8gZXJyb3JzLCBhbmQgcmV2YWxpZGF0aW9uXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUZldGNoZXJBY3Rpb24oa2V5LCByb3V0ZUlkLCBwYXRoLCBtYXRjaCwgcmVxdWVzdE1hdGNoZXMsIGZsdXNoU3luYywgc3VibWlzc2lvbikge1xuICAgIGludGVycnVwdEFjdGl2ZUxvYWRzKCk7XG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5kZWxldGUoa2V5KTtcbiAgICBpZiAoIW1hdGNoLnJvdXRlLmFjdGlvbiAmJiAhbWF0Y2gucm91dGUubGF6eSkge1xuICAgICAgbGV0IGVycm9yID0gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgbWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgICAgIHBhdGhuYW1lOiBwYXRoLFxuICAgICAgICByb3V0ZUlkOiByb3V0ZUlkXG4gICAgICB9KTtcbiAgICAgIHNldEZldGNoZXJFcnJvcihrZXksIHJvdXRlSWQsIGVycm9yLCB7XG4gICAgICAgIGZsdXNoU3luY1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFB1dCB0aGlzIGZldGNoZXIgaW50byBpdCdzIHN1Ym1pdHRpbmcgc3RhdGVcbiAgICBsZXQgZXhpc3RpbmdGZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0U3VibWl0dGluZ0ZldGNoZXIoc3VibWlzc2lvbiwgZXhpc3RpbmdGZXRjaGVyKSwge1xuICAgICAgZmx1c2hTeW5jXG4gICAgfSk7XG4gICAgLy8gQ2FsbCB0aGUgYWN0aW9uIGZvciB0aGUgZmV0Y2hlclxuICAgIGxldCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IGZldGNoUmVxdWVzdCA9IGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KGluaXQuaGlzdG9yeSwgcGF0aCwgYWJvcnRDb250cm9sbGVyLnNpZ25hbCwgc3VibWlzc2lvbik7XG4gICAgZmV0Y2hDb250cm9sbGVycy5zZXQoa2V5LCBhYm9ydENvbnRyb2xsZXIpO1xuICAgIGxldCBvcmlnaW5hdGluZ0xvYWRJZCA9IGluY3JlbWVudGluZ0xvYWRJZDtcbiAgICBsZXQgYWN0aW9uUmVzdWx0ID0gYXdhaXQgY2FsbExvYWRlck9yQWN0aW9uKFwiYWN0aW9uXCIsIGZldGNoUmVxdWVzdCwgbWF0Y2gsIHJlcXVlc3RNYXRjaGVzLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzLCBiYXNlbmFtZSk7XG4gICAgaWYgKGZldGNoUmVxdWVzdC5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgLy8gV2UgY2FuIGRlbGV0ZSB0aGlzIHNvIGxvbmcgYXMgd2Ugd2VyZW4ndCBhYm9ydGVkIGJ5IG91ciBvd24gZmV0Y2hlclxuICAgICAgLy8gcmUtc3VibWl0IHdoaWNoIHdvdWxkIGhhdmUgcHV0IF9uZXdfIGNvbnRyb2xsZXIgaXMgaW4gZmV0Y2hDb250cm9sbGVyc1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuZ2V0KGtleSkgPT09IGFib3J0Q29udHJvbGxlcikge1xuICAgICAgICBmZXRjaENvbnRyb2xsZXJzLmRlbGV0ZShrZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGVsZXRlZEZldGNoZXJzLmhhcyhrZXkpKSB7XG4gICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcih1bmRlZmluZWQpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQoYWN0aW9uUmVzdWx0KSkge1xuICAgICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgICAgIGlmIChwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCA+IG9yaWdpbmF0aW5nTG9hZElkKSB7XG4gICAgICAgIC8vIEEgbmV3IG5hdmlnYXRpb24gd2FzIGtpY2tlZCBvZmYgYWZ0ZXIgb3VyIGFjdGlvbiBzdGFydGVkLCBzbyB0aGF0XG4gICAgICAgIC8vIHNob3VsZCB0YWtlIHByZWNlZGVuY2Ugb3ZlciB0aGlzIHJlZGlyZWN0IG5hdmlnYXRpb24uICBXZSBhbHJlYWR5XG4gICAgICAgIC8vIHNldCBpc1JldmFsaWRhdGlvblJlcXVpcmVkIHNvIGFsbCBsb2FkZXJzIGZvciB0aGUgbmV3IHJvdXRlIHNob3VsZFxuICAgICAgICAvLyBmaXJlIHVubGVzcyBvcHRlZCBvdXQgdmlhIHNob3VsZFJldmFsaWRhdGVcbiAgICAgICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIodW5kZWZpbmVkKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZldGNoUmVkaXJlY3RJZHMuYWRkKGtleSk7XG4gICAgICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldExvYWRpbmdGZXRjaGVyKHN1Ym1pc3Npb24pKTtcbiAgICAgICAgcmV0dXJuIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCBhY3Rpb25SZXN1bHQsIHtcbiAgICAgICAgICBmZXRjaGVyU3VibWlzc2lvbjogc3VibWlzc2lvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUHJvY2VzcyBhbnkgbm9uLXJlZGlyZWN0IGVycm9ycyB0aHJvd25cbiAgICBpZiAoaXNFcnJvclJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCBhY3Rpb25SZXN1bHQuZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChhY3Rpb25SZXN1bHQpKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xuICAgICAgICB0eXBlOiBcImRlZmVyLWFjdGlvblwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgLy8gU3RhcnQgdGhlIGRhdGEgbG9hZCBmb3IgY3VycmVudCBtYXRjaGVzLCBvciB0aGUgbmV4dCBsb2NhdGlvbiBpZiB3ZSdyZVxuICAgIC8vIGluIHRoZSBtaWRkbGUgb2YgYSBuYXZpZ2F0aW9uXG4gICAgbGV0IG5leHRMb2NhdGlvbiA9IHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24gfHwgc3RhdGUubG9jYXRpb247XG4gICAgbGV0IHJldmFsaWRhdGlvblJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChpbml0Lmhpc3RvcnksIG5leHRMb2NhdGlvbiwgYWJvcnRDb250cm9sbGVyLnNpZ25hbCk7XG4gICAgbGV0IHJvdXRlc1RvVXNlID0gaW5GbGlnaHREYXRhUm91dGVzIHx8IGRhdGFSb3V0ZXM7XG4gICAgbGV0IG1hdGNoZXMgPSBzdGF0ZS5uYXZpZ2F0aW9uLnN0YXRlICE9PSBcImlkbGVcIiA/IG1hdGNoUm91dGVzKHJvdXRlc1RvVXNlLCBzdGF0ZS5uYXZpZ2F0aW9uLmxvY2F0aW9uLCBiYXNlbmFtZSkgOiBzdGF0ZS5tYXRjaGVzO1xuICAgIGludmFyaWFudChtYXRjaGVzLCBcIkRpZG4ndCBmaW5kIGFueSBtYXRjaGVzIGFmdGVyIGZldGNoZXIgYWN0aW9uXCIpO1xuICAgIGxldCBsb2FkSWQgPSArK2luY3JlbWVudGluZ0xvYWRJZDtcbiAgICBmZXRjaFJlbG9hZElkcy5zZXQoa2V5LCBsb2FkSWQpO1xuICAgIGxldCBsb2FkRmV0Y2hlciA9IGdldExvYWRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGFjdGlvblJlc3VsdC5kYXRhKTtcbiAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBsb2FkRmV0Y2hlcik7XG4gICAgbGV0IFttYXRjaGVzVG9Mb2FkLCByZXZhbGlkYXRpbmdGZXRjaGVyc10gPSBnZXRNYXRjaGVzVG9Mb2FkKGluaXQuaGlzdG9yeSwgc3RhdGUsIG1hdGNoZXMsIHN1Ym1pc3Npb24sIG5leHRMb2NhdGlvbiwgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCwgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMsIGNhbmNlbGxlZEZldGNoZXJMb2FkcywgZGVsZXRlZEZldGNoZXJzLCBmZXRjaExvYWRNYXRjaGVzLCBmZXRjaFJlZGlyZWN0SWRzLCByb3V0ZXNUb1VzZSwgYmFzZW5hbWUsIHtcbiAgICAgIFttYXRjaC5yb3V0ZS5pZF06IGFjdGlvblJlc3VsdC5kYXRhXG4gICAgfSwgdW5kZWZpbmVkIC8vIE5vIG5lZWQgdG8gc2VuZCB0aHJvdWdoIGVycm9ycyBzaW5jZSB3ZSBzaG9ydCBjaXJjdWl0IGFib3ZlXG4gICAgKTtcbiAgICAvLyBQdXQgYWxsIHJldmFsaWRhdGluZyBmZXRjaGVycyBpbnRvIHRoZSBsb2FkaW5nIHN0YXRlLCBleGNlcHQgZm9yIHRoZVxuICAgIC8vIGN1cnJlbnQgZmV0Y2hlciB3aGljaCB3ZSB3YW50IHRvIGtlZXAgaW4gaXQncyBjdXJyZW50IGxvYWRpbmcgc3RhdGUgd2hpY2hcbiAgICAvLyBjb250YWlucyBpdCdzIGFjdGlvbiBzdWJtaXNzaW9uIGluZm8gKyBhY3Rpb24gZGF0YVxuICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLmZpbHRlcihyZiA9PiByZi5rZXkgIT09IGtleSkuZm9yRWFjaChyZiA9PiB7XG4gICAgICBsZXQgc3RhbGVLZXkgPSByZi5rZXk7XG4gICAgICBsZXQgZXhpc3RpbmdGZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KHN0YWxlS2V5KTtcbiAgICAgIGxldCByZXZhbGlkYXRpbmdGZXRjaGVyID0gZ2V0TG9hZGluZ0ZldGNoZXIodW5kZWZpbmVkLCBleGlzdGluZ0ZldGNoZXIgPyBleGlzdGluZ0ZldGNoZXIuZGF0YSA6IHVuZGVmaW5lZCk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoc3RhbGVLZXksIHJldmFsaWRhdGluZ0ZldGNoZXIpO1xuICAgICAgaWYgKGZldGNoQ29udHJvbGxlcnMuaGFzKHN0YWxlS2V5KSkge1xuICAgICAgICBhYm9ydEZldGNoZXIoc3RhbGVLZXkpO1xuICAgICAgfVxuICAgICAgaWYgKHJmLmNvbnRyb2xsZXIpIHtcbiAgICAgICAgZmV0Y2hDb250cm9sbGVycy5zZXQoc3RhbGVLZXksIHJmLmNvbnRyb2xsZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0pO1xuICAgIGxldCBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMgPSAoKSA9PiByZXZhbGlkYXRpbmdGZXRjaGVycy5mb3JFYWNoKHJmID0+IGFib3J0RmV0Y2hlcihyZi5rZXkpKTtcbiAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMpO1xuICAgIGxldCB7XG4gICAgICByZXN1bHRzLFxuICAgICAgbG9hZGVyUmVzdWx0cyxcbiAgICAgIGZldGNoZXJSZXN1bHRzXG4gICAgfSA9IGF3YWl0IGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YShzdGF0ZS5tYXRjaGVzLCBtYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCByZXZhbGlkYXRpbmdGZXRjaGVycywgcmV2YWxpZGF0aW9uUmVxdWVzdCk7XG4gICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMpO1xuICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgcmV2YWxpZGF0aW5nRmV0Y2hlcnMuZm9yRWFjaChyID0+IGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKHIua2V5KSk7XG4gICAgbGV0IHJlZGlyZWN0ID0gZmluZFJlZGlyZWN0KHJlc3VsdHMpO1xuICAgIGlmIChyZWRpcmVjdCkge1xuICAgICAgaWYgKHJlZGlyZWN0LmlkeCA+PSBtYXRjaGVzVG9Mb2FkLmxlbmd0aCkge1xuICAgICAgICAvLyBJZiB0aGlzIHJlZGlyZWN0IGNhbWUgZnJvbSBhIGZldGNoZXIgbWFrZSBzdXJlIHdlIG1hcmsgaXQgaW5cbiAgICAgICAgLy8gZmV0Y2hSZWRpcmVjdElkcyBzbyBpdCBkb2Vzbid0IGdldCByZXZhbGlkYXRlZCBvbiB0aGUgbmV4dCBzZXQgb2ZcbiAgICAgICAgLy8gbG9hZGVyIGV4ZWN1dGlvbnNcbiAgICAgICAgbGV0IGZldGNoZXJLZXkgPSByZXZhbGlkYXRpbmdGZXRjaGVyc1tyZWRpcmVjdC5pZHggLSBtYXRjaGVzVG9Mb2FkLmxlbmd0aF0ua2V5O1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmFkZChmZXRjaGVyS2V5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGFydFJlZGlyZWN0TmF2aWdhdGlvbihzdGF0ZSwgcmVkaXJlY3QucmVzdWx0KTtcbiAgICB9XG4gICAgLy8gUHJvY2VzcyBhbmQgY29tbWl0IG91dHB1dCBmcm9tIGxvYWRlcnNcbiAgICBsZXQge1xuICAgICAgbG9hZGVyRGF0YSxcbiAgICAgIGVycm9yc1xuICAgIH0gPSBwcm9jZXNzTG9hZGVyRGF0YShzdGF0ZSwgc3RhdGUubWF0Y2hlcywgbWF0Y2hlc1RvTG9hZCwgbG9hZGVyUmVzdWx0cywgdW5kZWZpbmVkLCByZXZhbGlkYXRpbmdGZXRjaGVycywgZmV0Y2hlclJlc3VsdHMsIGFjdGl2ZURlZmVycmVkcyk7XG4gICAgLy8gU2luY2Ugd2UgbGV0IHJldmFsaWRhdGlvbnMgY29tcGxldGUgZXZlbiBpZiB0aGUgc3VibWl0dGluZyBmZXRjaGVyIHdhc1xuICAgIC8vIGRlbGV0ZWQsIG9ubHkgcHV0IGl0IGJhY2sgdG8gaWRsZSBpZiBpdCBoYXNuJ3QgYmVlbiBkZWxldGVkXG4gICAgaWYgKHN0YXRlLmZldGNoZXJzLmhhcyhrZXkpKSB7XG4gICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcihhY3Rpb25SZXN1bHQuZGF0YSk7XG4gICAgICBzdGF0ZS5mZXRjaGVycy5zZXQoa2V5LCBkb25lRmV0Y2hlcik7XG4gICAgfVxuICAgIGFib3J0U3RhbGVGZXRjaExvYWRzKGxvYWRJZCk7XG4gICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBpbiBhIG5hdmlnYXRpb24gbG9hZGluZyBzdGF0ZSBhbmQgdGhpcyBmZXRjaGVyIGlzXG4gICAgLy8gbW9yZSByZWNlbnQgdGhhbiB0aGUgbmF2aWdhdGlvbiwgd2Ugd2FudCB0aGUgbmV3ZXIgZGF0YSBzbyBhYm9ydCB0aGVcbiAgICAvLyBuYXZpZ2F0aW9uIGFuZCBjb21wbGV0ZSBpdCB3aXRoIHRoZSBmZXRjaGVyIGRhdGFcbiAgICBpZiAoc3RhdGUubmF2aWdhdGlvbi5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIgJiYgbG9hZElkID4gcGVuZGluZ05hdmlnYXRpb25Mb2FkSWQpIHtcbiAgICAgIGludmFyaWFudChwZW5kaW5nQWN0aW9uLCBcIkV4cGVjdGVkIHBlbmRpbmcgYWN0aW9uXCIpO1xuICAgICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyICYmIHBlbmRpbmdOYXZpZ2F0aW9uQ29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgY29tcGxldGVOYXZpZ2F0aW9uKHN0YXRlLm5hdmlnYXRpb24ubG9jYXRpb24sIHtcbiAgICAgICAgbWF0Y2hlcyxcbiAgICAgICAgbG9hZGVyRGF0YSxcbiAgICAgICAgZXJyb3JzLFxuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UganVzdCB1cGRhdGUgd2l0aCB0aGUgZmV0Y2hlciBkYXRhLCBwcmVzZXJ2aW5nIGFueSBleGlzdGluZ1xuICAgICAgLy8gbG9hZGVyRGF0YSBmb3IgbG9hZGVycyB0aGF0IGRpZCBub3QgbmVlZCB0byByZWxvYWQuICBXZSBoYXZlIHRvXG4gICAgICAvLyBtYW51YWxseSBtZXJnZSBoZXJlIHNpbmNlIHdlIGFyZW4ndCBnb2luZyB0aHJvdWdoIGNvbXBsZXRlTmF2aWdhdGlvblxuICAgICAgdXBkYXRlU3RhdGUoe1xuICAgICAgICBlcnJvcnMsXG4gICAgICAgIGxvYWRlckRhdGE6IG1lcmdlTG9hZGVyRGF0YShzdGF0ZS5sb2FkZXJEYXRhLCBsb2FkZXJEYXRhLCBtYXRjaGVzLCBlcnJvcnMpLFxuICAgICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICAgIH0pO1xuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBDYWxsIHRoZSBtYXRjaGVkIGxvYWRlciBmb3IgZmV0Y2hlci5sb2FkKCksIGhhbmRsaW5nIHJlZGlyZWN0cywgZXJyb3JzLCBldGMuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZUZldGNoZXJMb2FkZXIoa2V5LCByb3V0ZUlkLCBwYXRoLCBtYXRjaCwgbWF0Y2hlcywgZmx1c2hTeW5jLCBzdWJtaXNzaW9uKSB7XG4gICAgbGV0IGV4aXN0aW5nRmV0Y2hlciA9IHN0YXRlLmZldGNoZXJzLmdldChrZXkpO1xuICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldExvYWRpbmdGZXRjaGVyKHN1Ym1pc3Npb24sIGV4aXN0aW5nRmV0Y2hlciA/IGV4aXN0aW5nRmV0Y2hlci5kYXRhIDogdW5kZWZpbmVkKSwge1xuICAgICAgZmx1c2hTeW5jXG4gICAgfSk7XG4gICAgLy8gQ2FsbCB0aGUgbG9hZGVyIGZvciB0aGlzIGZldGNoZXIgcm91dGUgbWF0Y2hcbiAgICBsZXQgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGxldCBmZXRjaFJlcXVlc3QgPSBjcmVhdGVDbGllbnRTaWRlUmVxdWVzdChpbml0Lmhpc3RvcnksIHBhdGgsIGFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgIGZldGNoQ29udHJvbGxlcnMuc2V0KGtleSwgYWJvcnRDb250cm9sbGVyKTtcbiAgICBsZXQgb3JpZ2luYXRpbmdMb2FkSWQgPSBpbmNyZW1lbnRpbmdMb2FkSWQ7XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IGNhbGxMb2FkZXJPckFjdGlvbihcImxvYWRlclwiLCBmZXRjaFJlcXVlc3QsIG1hdGNoLCBtYXRjaGVzLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzLCBiYXNlbmFtZSk7XG4gICAgLy8gRGVmZXJyZWQgaXNuJ3Qgc3VwcG9ydGVkIGZvciBmZXRjaGVyIGxvYWRzLCBhd2FpdCBldmVyeXRoaW5nIGFuZCB0cmVhdCBpdFxuICAgIC8vIGFzIGEgbm9ybWFsIGxvYWQuICByZXNvbHZlRGVmZXJyZWREYXRhIHdpbGwgcmV0dXJuIHVuZGVmaW5lZCBpZiB0aGlzXG4gICAgLy8gZmV0Y2hlciBnZXRzIGFib3J0ZWQsIHNvIHdlIGp1c3QgbGVhdmUgcmVzdWx0IHVudG91Y2hlZCBhbmQgc2hvcnQgY2lyY3VpdFxuICAgIC8vIGJlbG93IGlmIHRoYXQgaGFwcGVuc1xuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIHJlc3VsdCA9IChhd2FpdCByZXNvbHZlRGVmZXJyZWREYXRhKHJlc3VsdCwgZmV0Y2hSZXF1ZXN0LnNpZ25hbCwgdHJ1ZSkpIHx8IHJlc3VsdDtcbiAgICB9XG4gICAgLy8gV2UgY2FuIGRlbGV0ZSB0aGlzIHNvIGxvbmcgYXMgd2Ugd2VyZW4ndCBhYm9ydGVkIGJ5IG91ciBvdXIgb3duIGZldGNoZXJcbiAgICAvLyByZS1sb2FkIHdoaWNoIHdvdWxkIGhhdmUgcHV0IF9uZXdfIGNvbnRyb2xsZXIgaXMgaW4gZmV0Y2hDb250cm9sbGVyc1xuICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpID09PSBhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgIGZldGNoQ29udHJvbGxlcnMuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIGlmIChmZXRjaFJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRlbGV0ZWRGZXRjaGVycy5oYXMoa2V5KSkge1xuICAgICAgdXBkYXRlRmV0Y2hlclN0YXRlKGtleSwgZ2V0RG9uZUZldGNoZXIodW5kZWZpbmVkKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHRoZSBsb2FkZXIgdGhyZXcgYSByZWRpcmVjdCBSZXNwb25zZSwgc3RhcnQgYSBuZXcgUkVQTEFDRSBuYXZpZ2F0aW9uXG4gICAgaWYgKGlzUmVkaXJlY3RSZXN1bHQocmVzdWx0KSkge1xuICAgICAgaWYgKHBlbmRpbmdOYXZpZ2F0aW9uTG9hZElkID4gb3JpZ2luYXRpbmdMb2FkSWQpIHtcbiAgICAgICAgLy8gQSBuZXcgbmF2aWdhdGlvbiB3YXMga2lja2VkIG9mZiBhZnRlciBvdXIgbG9hZGVyIHN0YXJ0ZWQsIHNvIHRoYXRcbiAgICAgICAgLy8gc2hvdWxkIHRha2UgcHJlY2VkZW5jZSBvdmVyIHRoaXMgcmVkaXJlY3QgbmF2aWdhdGlvblxuICAgICAgICB1cGRhdGVGZXRjaGVyU3RhdGUoa2V5LCBnZXREb25lRmV0Y2hlcih1bmRlZmluZWQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmV0Y2hSZWRpcmVjdElkcy5hZGQoa2V5KTtcbiAgICAgICAgYXdhaXQgc3RhcnRSZWRpcmVjdE5hdmlnYXRpb24oc3RhdGUsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUHJvY2VzcyBhbnkgbm9uLXJlZGlyZWN0IGVycm9ycyB0aHJvd25cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICBzZXRGZXRjaGVyRXJyb3Ioa2V5LCByb3V0ZUlkLCByZXN1bHQuZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoIWlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSwgXCJVbmhhbmRsZWQgZmV0Y2hlciBkZWZlcnJlZCBkYXRhXCIpO1xuICAgIC8vIFB1dCB0aGUgZmV0Y2hlciBiYWNrIGludG8gYW4gaWRsZSBzdGF0ZVxuICAgIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGdldERvbmVGZXRjaGVyKHJlc3VsdC5kYXRhKSk7XG4gIH1cbiAgLyoqXG4gICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gaGFuZGxlIHJlZGlyZWN0cyByZXR1cm5lZCBmcm9tIGFuIGFjdGlvbiBvciBsb2FkZXIuXG4gICAqIE5vcm1hbGx5LCBhIHJlZGlyZWN0IFwicmVwbGFjZXNcIiB0aGUgbmF2aWdhdGlvbiB0aGF0IHRyaWdnZXJlZCBpdC4gIFNvLCBmb3JcbiAgICogZXhhbXBsZTpcbiAgICpcbiAgICogIC0gdXNlciBpcyBvbiAvYVxuICAgKiAgLSB1c2VyIGNsaWNrcyBhIGxpbmsgdG8gL2JcbiAgICogIC0gbG9hZGVyIGZvciAvYiByZWRpcmVjdHMgdG8gL2NcbiAgICpcbiAgICogSW4gYSBub24tSlMgYXBwIHRoZSBicm93c2VyIHdvdWxkIHRyYWNrIHRoZSBpbi1mbGlnaHQgbmF2aWdhdGlvbiB0byAvYiBhbmRcbiAgICogdGhlbiByZXBsYWNlIGl0IHdpdGggL2Mgd2hlbiBpdCBlbmNvdW50ZXJlZCB0aGUgcmVkaXJlY3QgcmVzcG9uc2UuICBJblxuICAgKiB0aGUgZW5kIGl0IHdvdWxkIG9ubHkgZXZlciB1cGRhdGUgdGhlIFVSTCBiYXIgd2l0aCAvYy5cbiAgICpcbiAgICogSW4gY2xpZW50LXNpZGUgcm91dGluZyB1c2luZyBwdXNoU3RhdGUvcmVwbGFjZVN0YXRlLCB3ZSBhaW0gdG8gZW11bGF0ZVxuICAgKiB0aGlzIGJlaGF2aW9yIGFuZCB3ZSBhbHNvIGRvIG5vdCB1cGRhdGUgaGlzdG9yeSB1bnRpbCB0aGUgZW5kIG9mIHRoZVxuICAgKiBuYXZpZ2F0aW9uIChpbmNsdWRpbmcgcHJvY2Vzc2VkIHJlZGlyZWN0cykuICBUaGlzIG1lYW5zIHRoYXQgd2UgbmV2ZXJcbiAgICogYWN0dWFsbHkgdG91Y2ggaGlzdG9yeSB1bnRpbCB3ZSd2ZSBwcm9jZXNzZWQgcmVkaXJlY3RzLCBzbyB3ZSBqdXN0IHVzZVxuICAgKiB0aGUgaGlzdG9yeSBhY3Rpb24gZnJvbSB0aGUgb3JpZ2luYWwgbmF2aWdhdGlvbiAoUFVTSCBvciBSRVBMQUNFKS5cbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIHN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uKHN0YXRlLCByZWRpcmVjdCwgX3RlbXAyKSB7XG4gICAgbGV0IHtcbiAgICAgIHN1Ym1pc3Npb24sXG4gICAgICBmZXRjaGVyU3VibWlzc2lvbixcbiAgICAgIHJlcGxhY2VcbiAgICB9ID0gX3RlbXAyID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wMjtcbiAgICBpZiAocmVkaXJlY3QucmV2YWxpZGF0ZSkge1xuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCA9IHRydWU7XG4gICAgfVxuICAgIGxldCByZWRpcmVjdExvY2F0aW9uID0gY3JlYXRlTG9jYXRpb24oc3RhdGUubG9jYXRpb24sIHJlZGlyZWN0LmxvY2F0aW9uLCB7XG4gICAgICBfaXNSZWRpcmVjdDogdHJ1ZVxuICAgIH0pO1xuICAgIGludmFyaWFudChyZWRpcmVjdExvY2F0aW9uLCBcIkV4cGVjdGVkIGEgbG9jYXRpb24gb24gdGhlIHJlZGlyZWN0IG5hdmlnYXRpb25cIik7XG4gICAgaWYgKGlzQnJvd3Nlcikge1xuICAgICAgbGV0IGlzRG9jdW1lbnRSZWxvYWQgPSBmYWxzZTtcbiAgICAgIGlmIChyZWRpcmVjdC5yZWxvYWREb2N1bWVudCkge1xuICAgICAgICAvLyBIYXJkIHJlbG9hZCBpZiB0aGUgcmVzcG9uc2UgY29udGFpbmVkIFgtUmVtaXgtUmVsb2FkLURvY3VtZW50XG4gICAgICAgIGlzRG9jdW1lbnRSZWxvYWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChBQlNPTFVURV9VUkxfUkVHRVgudGVzdChyZWRpcmVjdC5sb2NhdGlvbikpIHtcbiAgICAgICAgY29uc3QgdXJsID0gaW5pdC5oaXN0b3J5LmNyZWF0ZVVSTChyZWRpcmVjdC5sb2NhdGlvbik7XG4gICAgICAgIGlzRG9jdW1lbnRSZWxvYWQgPVxuICAgICAgICAvLyBIYXJkIHJlbG9hZCBpZiBpdCdzIGFuIGFic29sdXRlIFVSTCB0byBhIG5ldyBvcmlnaW5cbiAgICAgICAgdXJsLm9yaWdpbiAhPT0gcm91dGVyV2luZG93LmxvY2F0aW9uLm9yaWdpbiB8fFxuICAgICAgICAvLyBIYXJkIHJlbG9hZCBpZiBpdCdzIGFuIGFic29sdXRlIFVSTCB0aGF0IGRvZXMgbm90IG1hdGNoIG91ciBiYXNlbmFtZVxuICAgICAgICBzdHJpcEJhc2VuYW1lKHVybC5wYXRobmFtZSwgYmFzZW5hbWUpID09IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoaXNEb2N1bWVudFJlbG9hZCkge1xuICAgICAgICBpZiAocmVwbGFjZSkge1xuICAgICAgICAgIHJvdXRlcldpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHJlZGlyZWN0LmxvY2F0aW9uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByb3V0ZXJXaW5kb3cubG9jYXRpb24uYXNzaWduKHJlZGlyZWN0LmxvY2F0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBhYm9ydCBvbiByZWRpcmVjdHMsIHNpbmNlIHdlIGRvbid0IGRldGVjdCB0aGVcbiAgICAvLyByZWRpcmVjdCB1bnRpbCB0aGUgYWN0aW9uL2xvYWRlcnMgaGF2ZSBzZXR0bGVkXG4gICAgcGVuZGluZ05hdmlnYXRpb25Db250cm9sbGVyID0gbnVsbDtcbiAgICBsZXQgcmVkaXJlY3RIaXN0b3J5QWN0aW9uID0gcmVwbGFjZSA9PT0gdHJ1ZSA/IEFjdGlvbi5SZXBsYWNlIDogQWN0aW9uLlB1c2g7XG4gICAgLy8gVXNlIHRoZSBpbmNvbWluZyBzdWJtaXNzaW9uIGlmIHByb3ZpZGVkLCBmYWxsYmFjayBvbiB0aGUgYWN0aXZlIG9uZSBpblxuICAgIC8vIHN0YXRlLm5hdmlnYXRpb25cbiAgICBsZXQge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZVxuICAgIH0gPSBzdGF0ZS5uYXZpZ2F0aW9uO1xuICAgIGlmICghc3VibWlzc2lvbiAmJiAhZmV0Y2hlclN1Ym1pc3Npb24gJiYgZm9ybU1ldGhvZCAmJiBmb3JtQWN0aW9uICYmIGZvcm1FbmNUeXBlKSB7XG4gICAgICBzdWJtaXNzaW9uID0gZ2V0U3VibWlzc2lvbkZyb21OYXZpZ2F0aW9uKHN0YXRlLm5hdmlnYXRpb24pO1xuICAgIH1cbiAgICAvLyBJZiB0aGlzIHdhcyBhIDMwNy8zMDggc3VibWlzc2lvbiB3ZSB3YW50IHRvIHByZXNlcnZlIHRoZSBIVFRQIG1ldGhvZCBhbmRcbiAgICAvLyByZS1zdWJtaXQgdGhlIEdFVC9QT1NUL1BVVC9QQVRDSC9ERUxFVEUgYXMgYSBzdWJtaXNzaW9uIG5hdmlnYXRpb24gdG8gdGhlXG4gICAgLy8gcmVkaXJlY3RlZCBsb2NhdGlvblxuICAgIGxldCBhY3RpdmVTdWJtaXNzaW9uID0gc3VibWlzc2lvbiB8fCBmZXRjaGVyU3VibWlzc2lvbjtcbiAgICBpZiAocmVkaXJlY3RQcmVzZXJ2ZU1ldGhvZFN0YXR1c0NvZGVzLmhhcyhyZWRpcmVjdC5zdGF0dXMpICYmIGFjdGl2ZVN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChhY3RpdmVTdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgICBhd2FpdCBzdGFydE5hdmlnYXRpb24ocmVkaXJlY3RIaXN0b3J5QWN0aW9uLCByZWRpcmVjdExvY2F0aW9uLCB7XG4gICAgICAgIHN1Ym1pc3Npb246IF9leHRlbmRzKHt9LCBhY3RpdmVTdWJtaXNzaW9uLCB7XG4gICAgICAgICAgZm9ybUFjdGlvbjogcmVkaXJlY3QubG9jYXRpb25cbiAgICAgICAgfSksXG4gICAgICAgIC8vIFByZXNlcnZlIHRoaXMgZmxhZyBhY3Jvc3MgcmVkaXJlY3RzXG4gICAgICAgIHByZXZlbnRTY3JvbGxSZXNldDogcGVuZGluZ1ByZXZlbnRTY3JvbGxSZXNldFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgYSBuYXZpZ2F0aW9uIHN1Ym1pc3Npb24sIHdlIHdpbGwgcHJlc2VydmUgaXQgdGhyb3VnaCB0aGVcbiAgICAgIC8vIHJlZGlyZWN0IG5hdmlnYXRpb25cbiAgICAgIGxldCBvdmVycmlkZU5hdmlnYXRpb24gPSBnZXRMb2FkaW5nTmF2aWdhdGlvbihyZWRpcmVjdExvY2F0aW9uLCBzdWJtaXNzaW9uKTtcbiAgICAgIGF3YWl0IHN0YXJ0TmF2aWdhdGlvbihyZWRpcmVjdEhpc3RvcnlBY3Rpb24sIHJlZGlyZWN0TG9jYXRpb24sIHtcbiAgICAgICAgb3ZlcnJpZGVOYXZpZ2F0aW9uLFxuICAgICAgICAvLyBTZW5kIGZldGNoZXIgc3VibWlzc2lvbnMgdGhyb3VnaCBmb3Igc2hvdWxkUmV2YWxpZGF0ZVxuICAgICAgICBmZXRjaGVyU3VibWlzc2lvbixcbiAgICAgICAgLy8gUHJlc2VydmUgdGhpcyBmbGFnIGFjcm9zcyByZWRpcmVjdHNcbiAgICAgICAgcHJldmVudFNjcm9sbFJlc2V0OiBwZW5kaW5nUHJldmVudFNjcm9sbFJlc2V0XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gY2FsbExvYWRlcnNBbmRNYXliZVJlc29sdmVEYXRhKGN1cnJlbnRNYXRjaGVzLCBtYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCBmZXRjaGVyc1RvTG9hZCwgcmVxdWVzdCkge1xuICAgIC8vIENhbGwgYWxsIG5hdmlnYXRpb24gbG9hZGVycyBhbmQgcmV2YWxpZGF0aW5nIGZldGNoZXIgbG9hZGVycyBpbiBwYXJhbGxlbCxcbiAgICAvLyB0aGVuIHNsaWNlIG9mZiB0aGUgcmVzdWx0cyBpbnRvIHNlcGFyYXRlIGFycmF5cyBzbyB3ZSBjYW4gaGFuZGxlIHRoZW1cbiAgICAvLyBhY2NvcmRpbmdseVxuICAgIGxldCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoWy4uLm1hdGNoZXNUb0xvYWQubWFwKG1hdGNoID0+IGNhbGxMb2FkZXJPckFjdGlvbihcImxvYWRlclwiLCByZXF1ZXN0LCBtYXRjaCwgbWF0Y2hlcywgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllcywgYmFzZW5hbWUpKSwgLi4uZmV0Y2hlcnNUb0xvYWQubWFwKGYgPT4ge1xuICAgICAgaWYgKGYubWF0Y2hlcyAmJiBmLm1hdGNoICYmIGYuY29udHJvbGxlcikge1xuICAgICAgICByZXR1cm4gY2FsbExvYWRlck9yQWN0aW9uKFwibG9hZGVyXCIsIGNyZWF0ZUNsaWVudFNpZGVSZXF1ZXN0KGluaXQuaGlzdG9yeSwgZi5wYXRoLCBmLmNvbnRyb2xsZXIuc2lnbmFsKSwgZi5tYXRjaCwgZi5tYXRjaGVzLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzLCBiYXNlbmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgZXJyb3IgPSB7XG4gICAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcbiAgICAgICAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDQsIHtcbiAgICAgICAgICAgIHBhdGhuYW1lOiBmLnBhdGhcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICB9XG4gICAgfSldKTtcbiAgICBsZXQgbG9hZGVyUmVzdWx0cyA9IHJlc3VsdHMuc2xpY2UoMCwgbWF0Y2hlc1RvTG9hZC5sZW5ndGgpO1xuICAgIGxldCBmZXRjaGVyUmVzdWx0cyA9IHJlc3VsdHMuc2xpY2UobWF0Y2hlc1RvTG9hZC5sZW5ndGgpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKFtyZXNvbHZlRGVmZXJyZWRSZXN1bHRzKGN1cnJlbnRNYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCBsb2FkZXJSZXN1bHRzLCBsb2FkZXJSZXN1bHRzLm1hcCgoKSA9PiByZXF1ZXN0LnNpZ25hbCksIGZhbHNlLCBzdGF0ZS5sb2FkZXJEYXRhKSwgcmVzb2x2ZURlZmVycmVkUmVzdWx0cyhjdXJyZW50TWF0Y2hlcywgZmV0Y2hlcnNUb0xvYWQubWFwKGYgPT4gZi5tYXRjaCksIGZldGNoZXJSZXN1bHRzLCBmZXRjaGVyc1RvTG9hZC5tYXAoZiA9PiBmLmNvbnRyb2xsZXIgPyBmLmNvbnRyb2xsZXIuc2lnbmFsIDogbnVsbCksIHRydWUpXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdHMsXG4gICAgICBsb2FkZXJSZXN1bHRzLFxuICAgICAgZmV0Y2hlclJlc3VsdHNcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGludGVycnVwdEFjdGl2ZUxvYWRzKCkge1xuICAgIC8vIEV2ZXJ5IGludGVycnVwdGlvbiB0cmlnZ2VycyBhIHJldmFsaWRhdGlvblxuICAgIGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQgPSB0cnVlO1xuICAgIC8vIENhbmNlbCBwZW5kaW5nIHJvdXRlLWxldmVsIGRlZmVycmVkcyBhbmQgbWFyayBjYW5jZWxsZWQgcm91dGVzIGZvclxuICAgIC8vIHJldmFsaWRhdGlvblxuICAgIGNhbmNlbGxlZERlZmVycmVkUm91dGVzLnB1c2goLi4uY2FuY2VsQWN0aXZlRGVmZXJyZWRzKCkpO1xuICAgIC8vIEFib3J0IGluLWZsaWdodCBmZXRjaGVyIGxvYWRzXG4gICAgZmV0Y2hMb2FkTWF0Y2hlcy5mb3JFYWNoKChfLCBrZXkpID0+IHtcbiAgICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpKSB7XG4gICAgICAgIGNhbmNlbGxlZEZldGNoZXJMb2Fkcy5wdXNoKGtleSk7XG4gICAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHVwZGF0ZUZldGNoZXJTdGF0ZShrZXksIGZldGNoZXIsIG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIHN0YXRlLmZldGNoZXJzLnNldChrZXksIGZldGNoZXIpO1xuICAgIHVwZGF0ZVN0YXRlKHtcbiAgICAgIGZldGNoZXJzOiBuZXcgTWFwKHN0YXRlLmZldGNoZXJzKVxuICAgIH0sIHtcbiAgICAgIGZsdXNoU3luYzogKG9wdHMgJiYgb3B0cy5mbHVzaFN5bmMpID09PSB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0RmV0Y2hlckVycm9yKGtleSwgcm91dGVJZCwgZXJyb3IsIG9wdHMpIHtcbiAgICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRzID0ge307XG4gICAgfVxuICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShzdGF0ZS5tYXRjaGVzLCByb3V0ZUlkKTtcbiAgICBkZWxldGVGZXRjaGVyKGtleSk7XG4gICAgdXBkYXRlU3RhdGUoe1xuICAgICAgZXJyb3JzOiB7XG4gICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogZXJyb3JcbiAgICAgIH0sXG4gICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICB9LCB7XG4gICAgICBmbHVzaFN5bmM6IChvcHRzICYmIG9wdHMuZmx1c2hTeW5jKSA9PT0gdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGdldEZldGNoZXIoa2V5KSB7XG4gICAgaWYgKGZ1dHVyZS52N19mZXRjaGVyUGVyc2lzdCkge1xuICAgICAgYWN0aXZlRmV0Y2hlcnMuc2V0KGtleSwgKGFjdGl2ZUZldGNoZXJzLmdldChrZXkpIHx8IDApICsgMSk7XG4gICAgICAvLyBJZiB0aGlzIGZldGNoZXIgd2FzIHByZXZpb3VzbHkgbWFya2VkIGZvciBkZWxldGlvbiwgdW5tYXJrIGl0IHNpbmNlIHdlXG4gICAgICAvLyBoYXZlIGEgbmV3IGluc3RhbmNlXG4gICAgICBpZiAoZGVsZXRlZEZldGNoZXJzLmhhcyhrZXkpKSB7XG4gICAgICAgIGRlbGV0ZWRGZXRjaGVycy5kZWxldGUoa2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlLmZldGNoZXJzLmdldChrZXkpIHx8IElETEVfRkVUQ0hFUjtcbiAgfVxuICBmdW5jdGlvbiBkZWxldGVGZXRjaGVyKGtleSkge1xuICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgLy8gRG9uJ3QgYWJvcnQgdGhlIGNvbnRyb2xsZXIgaWYgdGhpcyBpcyBhIGRlbGV0aW9uIG9mIGEgZmV0Y2hlci5zdWJtaXQoKVxuICAgIC8vIGluIGl0J3MgbG9hZGluZyBwaGFzZSBzaW5jZSAtIHdlIGRvbid0IHdhbnQgdG8gYWJvcnQgdGhlIGNvcnJlc3BvbmRpbmdcbiAgICAvLyByZXZhbGlkYXRpb24gYW5kIHdhbnQgdGhlbSB0byBjb21wbGV0ZSBhbmQgbGFuZFxuICAgIGlmIChmZXRjaENvbnRyb2xsZXJzLmhhcyhrZXkpICYmICEoZmV0Y2hlciAmJiBmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIiAmJiBmZXRjaFJlbG9hZElkcy5oYXMoa2V5KSkpIHtcbiAgICAgIGFib3J0RmV0Y2hlcihrZXkpO1xuICAgIH1cbiAgICBmZXRjaExvYWRNYXRjaGVzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoUmVsb2FkSWRzLmRlbGV0ZShrZXkpO1xuICAgIGZldGNoUmVkaXJlY3RJZHMuZGVsZXRlKGtleSk7XG4gICAgZGVsZXRlZEZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICAgIHN0YXRlLmZldGNoZXJzLmRlbGV0ZShrZXkpO1xuICB9XG4gIGZ1bmN0aW9uIGRlbGV0ZUZldGNoZXJBbmRVcGRhdGVTdGF0ZShrZXkpIHtcbiAgICBpZiAoZnV0dXJlLnY3X2ZldGNoZXJQZXJzaXN0KSB7XG4gICAgICBsZXQgY291bnQgPSAoYWN0aXZlRmV0Y2hlcnMuZ2V0KGtleSkgfHwgMCkgLSAxO1xuICAgICAgaWYgKGNvdW50IDw9IDApIHtcbiAgICAgICAgYWN0aXZlRmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgICAgIGRlbGV0ZWRGZXRjaGVycy5hZGQoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFjdGl2ZUZldGNoZXJzLnNldChrZXksIGNvdW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlRmV0Y2hlcihrZXkpO1xuICAgIH1cbiAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICBmZXRjaGVyczogbmV3IE1hcChzdGF0ZS5mZXRjaGVycylcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBhYm9ydEZldGNoZXIoa2V5KSB7XG4gICAgbGV0IGNvbnRyb2xsZXIgPSBmZXRjaENvbnRyb2xsZXJzLmdldChrZXkpO1xuICAgIGludmFyaWFudChjb250cm9sbGVyLCBcIkV4cGVjdGVkIGZldGNoIGNvbnRyb2xsZXI6IFwiICsga2V5KTtcbiAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgZmV0Y2hDb250cm9sbGVycy5kZWxldGUoa2V5KTtcbiAgfVxuICBmdW5jdGlvbiBtYXJrRmV0Y2hlcnNEb25lKGtleXMpIHtcbiAgICBmb3IgKGxldCBrZXkgb2Yga2V5cykge1xuICAgICAgbGV0IGZldGNoZXIgPSBnZXRGZXRjaGVyKGtleSk7XG4gICAgICBsZXQgZG9uZUZldGNoZXIgPSBnZXREb25lRmV0Y2hlcihmZXRjaGVyLmRhdGEpO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtYXJrRmV0Y2hSZWRpcmVjdHNEb25lKCkge1xuICAgIGxldCBkb25lS2V5cyA9IFtdO1xuICAgIGxldCB1cGRhdGVkRmV0Y2hlcnMgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBrZXkgb2YgZmV0Y2hSZWRpcmVjdElkcykge1xuICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAgIGludmFyaWFudChmZXRjaGVyLCBcIkV4cGVjdGVkIGZldGNoZXI6IFwiICsga2V5KTtcbiAgICAgIGlmIChmZXRjaGVyLnN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgICBmZXRjaFJlZGlyZWN0SWRzLmRlbGV0ZShrZXkpO1xuICAgICAgICBkb25lS2V5cy5wdXNoKGtleSk7XG4gICAgICAgIHVwZGF0ZWRGZXRjaGVycyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIG1hcmtGZXRjaGVyc0RvbmUoZG9uZUtleXMpO1xuICAgIHJldHVybiB1cGRhdGVkRmV0Y2hlcnM7XG4gIH1cbiAgZnVuY3Rpb24gYWJvcnRTdGFsZUZldGNoTG9hZHMobGFuZGVkSWQpIHtcbiAgICBsZXQgeWVldGVkS2V5cyA9IFtdO1xuICAgIGZvciAobGV0IFtrZXksIGlkXSBvZiBmZXRjaFJlbG9hZElkcykge1xuICAgICAgaWYgKGlkIDwgbGFuZGVkSWQpIHtcbiAgICAgICAgbGV0IGZldGNoZXIgPSBzdGF0ZS5mZXRjaGVycy5nZXQoa2V5KTtcbiAgICAgICAgaW52YXJpYW50KGZldGNoZXIsIFwiRXhwZWN0ZWQgZmV0Y2hlcjogXCIgKyBrZXkpO1xuICAgICAgICBpZiAoZmV0Y2hlci5zdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgICAgICBhYm9ydEZldGNoZXIoa2V5KTtcbiAgICAgICAgICBmZXRjaFJlbG9hZElkcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICB5ZWV0ZWRLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBtYXJrRmV0Y2hlcnNEb25lKHllZXRlZEtleXMpO1xuICAgIHJldHVybiB5ZWV0ZWRLZXlzLmxlbmd0aCA+IDA7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0QmxvY2tlcihrZXksIGZuKSB7XG4gICAgbGV0IGJsb2NrZXIgPSBzdGF0ZS5ibG9ja2Vycy5nZXQoa2V5KSB8fCBJRExFX0JMT0NLRVI7XG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbnMuZ2V0KGtleSkgIT09IGZuKSB7XG4gICAgICBibG9ja2VyRnVuY3Rpb25zLnNldChrZXksIGZuKTtcbiAgICB9XG4gICAgcmV0dXJuIGJsb2NrZXI7XG4gIH1cbiAgZnVuY3Rpb24gZGVsZXRlQmxvY2tlcihrZXkpIHtcbiAgICBzdGF0ZS5ibG9ja2Vycy5kZWxldGUoa2V5KTtcbiAgICBibG9ja2VyRnVuY3Rpb25zLmRlbGV0ZShrZXkpO1xuICB9XG4gIC8vIFV0aWxpdHkgZnVuY3Rpb24gdG8gdXBkYXRlIGJsb2NrZXJzLCBlbnN1cmluZyB2YWxpZCBzdGF0ZSB0cmFuc2l0aW9uc1xuICBmdW5jdGlvbiB1cGRhdGVCbG9ja2VyKGtleSwgbmV3QmxvY2tlcikge1xuICAgIGxldCBibG9ja2VyID0gc3RhdGUuYmxvY2tlcnMuZ2V0KGtleSkgfHwgSURMRV9CTE9DS0VSO1xuICAgIC8vIFBvb3IgbWFucyBzdGF0ZSBtYWNoaW5lIDopXG4gICAgLy8gaHR0cHM6Ly9tZXJtYWlkLmxpdmUvZWRpdCNwYWtvOmVOcVZrYzlPd3pBTXhsOGw4bm5qQVlyRXRESU9IRUJJZ3d2S0pUUmVHeTNfbERwSXFPMjdrNmF3TUcwWGNyTGxuejg3bndkb25FU29nS1hYQnVFNzlycTc1WFpPMy15SGRzMFJKVnV2NzBZclBsVXJDRWUySGZyT1JTM3J1YnFaZnVodHBnNUM5d2s1dFo0VktjUlVxODhxOVo4UlMwLTQ4Y0UxaUhKa0wwdWdiSHVGTHVzOUw2c3BaeThuWDlNUDJDTmRvbVZhcG9zcXUzZkdheVQ4VDgtakpRd2hlcG9fVXRwZ0JRYURFVW9tMDRkWmhBTjFhSkJEbFVLSkJ4RTFjZUIyU21qME1sbi1JQlc1QUZVMmR3VWlrdHRfMlFhcTJkQmZhS2RFdXA4NVVWN1lkLWRLamxua2FibDJQdnIwRFRrVHJlTVxuICAgIGludmFyaWFudChibG9ja2VyLnN0YXRlID09PSBcInVuYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiIHx8IGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiIHx8IGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwicHJvY2VlZGluZ1wiIHx8IGJsb2NrZXIuc3RhdGUgPT09IFwiYmxvY2tlZFwiICYmIG5ld0Jsb2NrZXIuc3RhdGUgPT09IFwidW5ibG9ja2VkXCIgfHwgYmxvY2tlci5zdGF0ZSA9PT0gXCJwcm9jZWVkaW5nXCIgJiYgbmV3QmxvY2tlci5zdGF0ZSA9PT0gXCJ1bmJsb2NrZWRcIiwgXCJJbnZhbGlkIGJsb2NrZXIgc3RhdGUgdHJhbnNpdGlvbjogXCIgKyBibG9ja2VyLnN0YXRlICsgXCIgLT4gXCIgKyBuZXdCbG9ja2VyLnN0YXRlKTtcbiAgICBsZXQgYmxvY2tlcnMgPSBuZXcgTWFwKHN0YXRlLmJsb2NrZXJzKTtcbiAgICBibG9ja2Vycy5zZXQoa2V5LCBuZXdCbG9ja2VyKTtcbiAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICBibG9ja2Vyc1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHNob3VsZEJsb2NrTmF2aWdhdGlvbihfcmVmMikge1xuICAgIGxldCB7XG4gICAgICBjdXJyZW50TG9jYXRpb24sXG4gICAgICBuZXh0TG9jYXRpb24sXG4gICAgICBoaXN0b3J5QWN0aW9uXG4gICAgfSA9IF9yZWYyO1xuICAgIGlmIChibG9ja2VyRnVuY3Rpb25zLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gV2Ugb255IHN1cHBvcnQgYSBzaW5nbGUgYWN0aXZlIGJsb2NrZXIgYXQgdGhlIG1vbWVudCBzaW5jZSB3ZSBkb24ndCBoYXZlXG4gICAgLy8gYW55IGNvbXBlbGxpbmcgdXNlIGNhc2VzIGZvciBtdWx0aS1ibG9ja2VyIHlldFxuICAgIGlmIChibG9ja2VyRnVuY3Rpb25zLnNpemUgPiAxKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCBcIkEgcm91dGVyIG9ubHkgc3VwcG9ydHMgb25lIGJsb2NrZXIgYXQgYSB0aW1lXCIpO1xuICAgIH1cbiAgICBsZXQgZW50cmllcyA9IEFycmF5LmZyb20oYmxvY2tlckZ1bmN0aW9ucy5lbnRyaWVzKCkpO1xuICAgIGxldCBbYmxvY2tlcktleSwgYmxvY2tlckZ1bmN0aW9uXSA9IGVudHJpZXNbZW50cmllcy5sZW5ndGggLSAxXTtcbiAgICBsZXQgYmxvY2tlciA9IHN0YXRlLmJsb2NrZXJzLmdldChibG9ja2VyS2V5KTtcbiAgICBpZiAoYmxvY2tlciAmJiBibG9ja2VyLnN0YXRlID09PSBcInByb2NlZWRpbmdcIikge1xuICAgICAgLy8gSWYgdGhlIGJsb2NrZXIgaXMgY3VycmVudGx5IHByb2NlZWRpbmcsIHdlIGRvbid0IG5lZWQgdG8gcmUtY2hlY2tcbiAgICAgIC8vIGl0IGFuZCBjYW4gbGV0IHRoaXMgbmF2aWdhdGlvbiBjb250aW51ZVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB3ZSBrbm93IHdlJ3JlIHVuYmxvY2tlZC9ibG9ja2VkIHNvIHdlIG5lZWQgdG8gY2hlY2sgdGhlXG4gICAgLy8gdXNlci1wcm92aWRlZCBibG9ja2VyIGZ1bmN0aW9uXG4gICAgaWYgKGJsb2NrZXJGdW5jdGlvbih7XG4gICAgICBjdXJyZW50TG9jYXRpb24sXG4gICAgICBuZXh0TG9jYXRpb24sXG4gICAgICBoaXN0b3J5QWN0aW9uXG4gICAgfSkpIHtcbiAgICAgIHJldHVybiBibG9ja2VyS2V5O1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjYW5jZWxBY3RpdmVEZWZlcnJlZHMocHJlZGljYXRlKSB7XG4gICAgbGV0IGNhbmNlbGxlZFJvdXRlSWRzID0gW107XG4gICAgYWN0aXZlRGVmZXJyZWRzLmZvckVhY2goKGRmZCwgcm91dGVJZCkgPT4ge1xuICAgICAgaWYgKCFwcmVkaWNhdGUgfHwgcHJlZGljYXRlKHJvdXRlSWQpKSB7XG4gICAgICAgIC8vIENhbmNlbCB0aGUgZGVmZXJyZWQgLSBidXQgZG8gbm90IHJlbW92ZSBmcm9tIGFjdGl2ZURlZmVycmVkcyBoZXJlIC1cbiAgICAgICAgLy8gd2UgcmVseSBvbiB0aGUgc3Vic2NyaWJlcnMgdG8gZG8gdGhhdCBzbyBvdXIgdGVzdHMgY2FuIGFzc2VydCBwcm9wZXJcbiAgICAgICAgLy8gY2xlYW51cCB2aWEgX2ludGVybmFsQWN0aXZlRGVmZXJyZWRzXG4gICAgICAgIGRmZC5jYW5jZWwoKTtcbiAgICAgICAgY2FuY2VsbGVkUm91dGVJZHMucHVzaChyb3V0ZUlkKTtcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzLmRlbGV0ZShyb3V0ZUlkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2FuY2VsbGVkUm91dGVJZHM7XG4gIH1cbiAgLy8gT3B0IGluIHRvIGNhcHR1cmluZyBhbmQgcmVwb3J0aW5nIHNjcm9sbCBwb3NpdGlvbnMgZHVyaW5nIG5hdmlnYXRpb25zLFxuICAvLyB1c2VkIGJ5IHRoZSA8U2Nyb2xsUmVzdG9yYXRpb24+IGNvbXBvbmVudFxuICBmdW5jdGlvbiBlbmFibGVTY3JvbGxSZXN0b3JhdGlvbihwb3NpdGlvbnMsIGdldFBvc2l0aW9uLCBnZXRLZXkpIHtcbiAgICBzYXZlZFNjcm9sbFBvc2l0aW9ucyA9IHBvc2l0aW9ucztcbiAgICBnZXRTY3JvbGxQb3NpdGlvbiA9IGdldFBvc2l0aW9uO1xuICAgIGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5ID0gZ2V0S2V5IHx8IG51bGw7XG4gICAgLy8gUGVyZm9ybSBpbml0aWFsIGh5ZHJhdGlvbiBzY3JvbGwgcmVzdG9yYXRpb24sIHNpbmNlIHdlIG1pc3MgdGhlIGJvYXQgb25cbiAgICAvLyB0aGUgaW5pdGlhbCB1cGRhdGVTdGF0ZSgpIGJlY2F1c2Ugd2UndmUgbm90IHlldCByZW5kZXJlZCA8U2Nyb2xsUmVzdG9yYXRpb24vPlxuICAgIC8vIGFuZCB0aGVyZWZvcmUgaGF2ZSBubyBzYXZlZFNjcm9sbFBvc2l0aW9ucyBhdmFpbGFibGVcbiAgICBpZiAoIWluaXRpYWxTY3JvbGxSZXN0b3JlZCAmJiBzdGF0ZS5uYXZpZ2F0aW9uID09PSBJRExFX05BVklHQVRJT04pIHtcbiAgICAgIGluaXRpYWxTY3JvbGxSZXN0b3JlZCA9IHRydWU7XG4gICAgICBsZXQgeSA9IGdldFNhdmVkU2Nyb2xsUG9zaXRpb24oc3RhdGUubG9jYXRpb24sIHN0YXRlLm1hdGNoZXMpO1xuICAgICAgaWYgKHkgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVTdGF0ZSh7XG4gICAgICAgICAgcmVzdG9yZVNjcm9sbFBvc2l0aW9uOiB5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgc2F2ZWRTY3JvbGxQb3NpdGlvbnMgPSBudWxsO1xuICAgICAgZ2V0U2Nyb2xsUG9zaXRpb24gPSBudWxsO1xuICAgICAgZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkgPSBudWxsO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U2Nyb2xsS2V5KGxvY2F0aW9uLCBtYXRjaGVzKSB7XG4gICAgaWYgKGdldFNjcm9sbFJlc3RvcmF0aW9uS2V5KSB7XG4gICAgICBsZXQga2V5ID0gZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkobG9jYXRpb24sIG1hdGNoZXMubWFwKG0gPT4gY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gobSwgc3RhdGUubG9hZGVyRGF0YSkpKTtcbiAgICAgIHJldHVybiBrZXkgfHwgbG9jYXRpb24ua2V5O1xuICAgIH1cbiAgICByZXR1cm4gbG9jYXRpb24ua2V5O1xuICB9XG4gIGZ1bmN0aW9uIHNhdmVTY3JvbGxQb3NpdGlvbihsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGlmIChzYXZlZFNjcm9sbFBvc2l0aW9ucyAmJiBnZXRTY3JvbGxQb3NpdGlvbikge1xuICAgICAgbGV0IGtleSA9IGdldFNjcm9sbEtleShsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICBzYXZlZFNjcm9sbFBvc2l0aW9uc1trZXldID0gZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbihsb2NhdGlvbiwgbWF0Y2hlcykge1xuICAgIGlmIChzYXZlZFNjcm9sbFBvc2l0aW9ucykge1xuICAgICAgbGV0IGtleSA9IGdldFNjcm9sbEtleShsb2NhdGlvbiwgbWF0Y2hlcyk7XG4gICAgICBsZXQgeSA9IHNhdmVkU2Nyb2xsUG9zaXRpb25zW2tleV07XG4gICAgICBpZiAodHlwZW9mIHkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIHk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIF9pbnRlcm5hbFNldFJvdXRlcyhuZXdSb3V0ZXMpIHtcbiAgICBtYW5pZmVzdCA9IHt9O1xuICAgIGluRmxpZ2h0RGF0YVJvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMobmV3Um91dGVzLCBtYXBSb3V0ZVByb3BlcnRpZXMsIHVuZGVmaW5lZCwgbWFuaWZlc3QpO1xuICB9XG4gIHJvdXRlciA9IHtcbiAgICBnZXQgYmFzZW5hbWUoKSB7XG4gICAgICByZXR1cm4gYmFzZW5hbWU7XG4gICAgfSxcbiAgICBnZXQgc3RhdGUoKSB7XG4gICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSxcbiAgICBnZXQgcm91dGVzKCkge1xuICAgICAgcmV0dXJuIGRhdGFSb3V0ZXM7XG4gICAgfSxcbiAgICBnZXQgd2luZG93KCkge1xuICAgICAgcmV0dXJuIHJvdXRlcldpbmRvdztcbiAgICB9LFxuICAgIGluaXRpYWxpemUsXG4gICAgc3Vic2NyaWJlLFxuICAgIGVuYWJsZVNjcm9sbFJlc3RvcmF0aW9uLFxuICAgIG5hdmlnYXRlLFxuICAgIGZldGNoLFxuICAgIHJldmFsaWRhdGUsXG4gICAgLy8gUGFzc3Rocm91Z2ggdG8gaGlzdG9yeS1hd2FyZSBjcmVhdGVIcmVmIHVzZWQgYnkgdXNlSHJlZiBzbyB3ZSBnZXQgcHJvcGVyXG4gICAgLy8gaGFzaC1hd2FyZSBVUkxzIGluIERPTSBwYXRoc1xuICAgIGNyZWF0ZUhyZWY6IHRvID0+IGluaXQuaGlzdG9yeS5jcmVhdGVIcmVmKHRvKSxcbiAgICBlbmNvZGVMb2NhdGlvbjogdG8gPT4gaW5pdC5oaXN0b3J5LmVuY29kZUxvY2F0aW9uKHRvKSxcbiAgICBnZXRGZXRjaGVyLFxuICAgIGRlbGV0ZUZldGNoZXI6IGRlbGV0ZUZldGNoZXJBbmRVcGRhdGVTdGF0ZSxcbiAgICBkaXNwb3NlLFxuICAgIGdldEJsb2NrZXIsXG4gICAgZGVsZXRlQmxvY2tlcixcbiAgICBfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzOiBmZXRjaENvbnRyb2xsZXJzLFxuICAgIF9pbnRlcm5hbEFjdGl2ZURlZmVycmVkczogYWN0aXZlRGVmZXJyZWRzLFxuICAgIC8vIFRPRE86IFJlbW92ZSBzZXRSb3V0ZXMsIGl0J3MgdGVtcG9yYXJ5IHRvIGF2b2lkIGRlYWxpbmcgd2l0aFxuICAgIC8vIHVwZGF0aW5nIHRoZSB0cmVlIHdoaWxlIHZhbGlkYXRpbmcgdGhlIHVwZGF0ZSBhbGdvcml0aG0uXG4gICAgX2ludGVybmFsU2V0Um91dGVzXG4gIH07XG4gIHJldHVybiByb3V0ZXI7XG59XG4vLyNlbmRyZWdpb25cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gY3JlYXRlU3RhdGljSGFuZGxlclxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmNvbnN0IFVOU0FGRV9ERUZFUlJFRF9TWU1CT0wgPSBTeW1ib2woXCJkZWZlcnJlZFwiKTtcbmZ1bmN0aW9uIGNyZWF0ZVN0YXRpY0hhbmRsZXIocm91dGVzLCBvcHRzKSB7XG4gIGludmFyaWFudChyb3V0ZXMubGVuZ3RoID4gMCwgXCJZb3UgbXVzdCBwcm92aWRlIGEgbm9uLWVtcHR5IHJvdXRlcyBhcnJheSB0byBjcmVhdGVTdGF0aWNIYW5kbGVyXCIpO1xuICBsZXQgbWFuaWZlc3QgPSB7fTtcbiAgbGV0IGJhc2VuYW1lID0gKG9wdHMgPyBvcHRzLmJhc2VuYW1lIDogbnVsbCkgfHwgXCIvXCI7XG4gIGxldCBtYXBSb3V0ZVByb3BlcnRpZXM7XG4gIGlmIChvcHRzICE9IG51bGwgJiYgb3B0cy5tYXBSb3V0ZVByb3BlcnRpZXMpIHtcbiAgICBtYXBSb3V0ZVByb3BlcnRpZXMgPSBvcHRzLm1hcFJvdXRlUHJvcGVydGllcztcbiAgfSBlbHNlIGlmIChvcHRzICE9IG51bGwgJiYgb3B0cy5kZXRlY3RFcnJvckJvdW5kYXJ5KSB7XG4gICAgLy8gSWYgdGhleSBhcmUgc3RpbGwgdXNpbmcgdGhlIGRlcHJlY2F0ZWQgdmVyc2lvbiwgd3JhcCBpdCB3aXRoIHRoZSBuZXcgQVBJXG4gICAgbGV0IGRldGVjdEVycm9yQm91bmRhcnkgPSBvcHRzLmRldGVjdEVycm9yQm91bmRhcnk7XG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzID0gcm91dGUgPT4gKHtcbiAgICAgIGhhc0Vycm9yQm91bmRhcnk6IGRldGVjdEVycm9yQm91bmRhcnkocm91dGUpXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgbWFwUm91dGVQcm9wZXJ0aWVzID0gZGVmYXVsdE1hcFJvdXRlUHJvcGVydGllcztcbiAgfVxuICBsZXQgZGF0YVJvdXRlcyA9IGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMocm91dGVzLCBtYXBSb3V0ZVByb3BlcnRpZXMsIHVuZGVmaW5lZCwgbWFuaWZlc3QpO1xuICAvKipcbiAgICogVGhlIHF1ZXJ5KCkgbWV0aG9kIGlzIGludGVuZGVkIGZvciBkb2N1bWVudCByZXF1ZXN0cywgaW4gd2hpY2ggd2Ugd2FudCB0b1xuICAgKiBjYWxsIGFuIG9wdGlvbmFsIGFjdGlvbiBhbmQgcG90ZW50aWFsbHkgbXVsdGlwbGUgbG9hZGVycyBmb3IgYWxsIG5lc3RlZFxuICAgKiByb3V0ZXMuICBJdCByZXR1cm5zIGEgU3RhdGljSGFuZGxlckNvbnRleHQgb2JqZWN0LCB3aGljaCBpcyB2ZXJ5IHNpbWlsYXJcbiAgICogdG8gdGhlIHJvdXRlciBzdGF0ZSAobG9jYXRpb24sIGxvYWRlckRhdGEsIGFjdGlvbkRhdGEsIGVycm9ycywgZXRjLikgYW5kXG4gICAqIGFsc28gYWRkcyBTU1Itc3BlY2lmaWMgaW5mb3JtYXRpb24gc3VjaCBhcyB0aGUgc3RhdHVzQ29kZSBhbmQgaGVhZGVyc1xuICAgKiBmcm9tIGFjdGlvbi9sb2FkZXJzIFJlc3BvbnNlcy5cbiAgICpcbiAgICogSXQgX3Nob3VsZF8gbmV2ZXIgdGhyb3cgYW5kIHNob3VsZCByZXBvcnQgYWxsIGVycm9ycyB0aHJvdWdoIHRoZVxuICAgKiByZXR1cm5lZCBjb250ZXh0LmVycm9ycyBvYmplY3QsIHByb3Blcmx5IGFzc29jaWF0aW5nIGVycm9ycyB0byB0aGVpciBlcnJvclxuICAgKiBib3VuZGFyeS4gIEFkZGl0aW9uYWxseSwgaXQgdHJhY2tzIF9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIHdoaWNoIGNhbiBiZVxuICAgKiB1c2VkIHRvIGVtdWxhdGUgUmVhY3QgZXJyb3IgYm91bmRhcmllcyBkdXJpbmcgU1NyIGJ5IHBlcmZvcm1pbmcgYSBzZWNvbmRcbiAgICogcGFzcyBvbmx5IGRvd24gdG8gdGhlIGJvdW5kYXJ5SWQuXG4gICAqXG4gICAqIFRoZSBvbmUgZXhjZXB0aW9uIHdoZXJlIHdlIGRvIG5vdCByZXR1cm4gYSBTdGF0aWNIYW5kbGVyQ29udGV4dCBpcyB3aGVuIGFcbiAgICogcmVkaXJlY3QgcmVzcG9uc2UgaXMgcmV0dXJuZWQgb3IgdGhyb3duIGZyb20gYW55IGFjdGlvbi9sb2FkZXIuICBXZVxuICAgKiBwcm9wYWdhdGUgdGhhdCBvdXQgYW5kIHJldHVybiB0aGUgcmF3IFJlc3BvbnNlIHNvIHRoZSBIVFRQIHNlcnZlciBjYW5cbiAgICogcmV0dXJuIGl0IGRpcmVjdGx5LlxuICAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gcXVlcnkocmVxdWVzdCwgX3RlbXAzKSB7XG4gICAgbGV0IHtcbiAgICAgIHJlcXVlc3RDb250ZXh0XG4gICAgfSA9IF90ZW1wMyA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDM7XG4gICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgIGxldCBtZXRob2QgPSByZXF1ZXN0Lm1ldGhvZDtcbiAgICBsZXQgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbihcIlwiLCBjcmVhdGVQYXRoKHVybCksIG51bGwsIFwiZGVmYXVsdFwiKTtcbiAgICBsZXQgbWF0Y2hlcyA9IG1hdGNoUm91dGVzKGRhdGFSb3V0ZXMsIGxvY2F0aW9uLCBiYXNlbmFtZSk7XG4gICAgLy8gU1NSIHN1cHBvcnRzIEhFQUQgcmVxdWVzdHMgd2hpbGUgU1BBIGRvZXNuJ3RcbiAgICBpZiAoIWlzVmFsaWRNZXRob2QobWV0aG9kKSAmJiBtZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICBtZXRob2RcbiAgICAgIH0pO1xuICAgICAgbGV0IHtcbiAgICAgICAgbWF0Y2hlczogbWV0aG9kTm90QWxsb3dlZE1hdGNoZXMsXG4gICAgICAgIHJvdXRlXG4gICAgICB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhc2VuYW1lLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlczogbWV0aG9kTm90QWxsb3dlZE1hdGNoZXMsXG4gICAgICAgIGxvYWRlckRhdGE6IHt9LFxuICAgICAgICBhY3Rpb25EYXRhOiBudWxsLFxuICAgICAgICBlcnJvcnM6IHtcbiAgICAgICAgICBbcm91dGUuaWRdOiBlcnJvclxuICAgICAgICB9LFxuICAgICAgICBzdGF0dXNDb2RlOiBlcnJvci5zdGF0dXMsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzOiBudWxsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZVxuICAgICAgfSk7XG4gICAgICBsZXQge1xuICAgICAgICBtYXRjaGVzOiBub3RGb3VuZE1hdGNoZXMsXG4gICAgICAgIHJvdXRlXG4gICAgICB9ID0gZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyhkYXRhUm91dGVzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJhc2VuYW1lLFxuICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgbWF0Y2hlczogbm90Rm91bmRNYXRjaGVzLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgZXJyb3JzOiB7XG4gICAgICAgICAgW3JvdXRlLmlkXTogZXJyb3JcbiAgICAgICAgfSxcbiAgICAgICAgc3RhdHVzQ29kZTogZXJyb3Iuc3RhdHVzLFxuICAgICAgICBsb2FkZXJIZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge30sXG4gICAgICAgIGFjdGl2ZURlZmVycmVkczogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5SW1wbChyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQpO1xuICAgIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIFdoZW4gcmV0dXJuaW5nIFN0YXRpY0hhbmRsZXJDb250ZXh0LCB3ZSBwYXRjaCBiYWNrIGluIHRoZSBsb2NhdGlvbiBoZXJlXG4gICAgLy8gc2luY2Ugd2UgbmVlZCBpdCBmb3IgUmVhY3QgQ29udGV4dC4gIEJ1dCB0aGlzIGhlbHBzIGtlZXAgb3VyIHN1Ym1pdCBhbmRcbiAgICAvLyBsb2FkUm91dGVEYXRhIG9wZXJhdGluZyBvbiBhIFJlcXVlc3QgaW5zdGVhZCBvZiBhIExvY2F0aW9uXG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIGxvY2F0aW9uLFxuICAgICAgYmFzZW5hbWVcbiAgICB9LCByZXN1bHQpO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcXVlcnlSb3V0ZSgpIG1ldGhvZCBpcyBpbnRlbmRlZCBmb3IgdGFyZ2V0ZWQgcm91dGUgcmVxdWVzdHMsIGVpdGhlclxuICAgKiBmb3IgZmV0Y2ggP19kYXRhIHJlcXVlc3RzIG9yIHJlc291cmNlIHJvdXRlIHJlcXVlc3RzLiAgSW4gdGhpcyBjYXNlLCB3ZVxuICAgKiBhcmUgb25seSBldmVyIGNhbGxpbmcgYSBzaW5nbGUgYWN0aW9uIG9yIGxvYWRlciwgYW5kIHdlIGFyZSByZXR1cm5pbmcgdGhlXG4gICAqIHJldHVybmVkIHZhbHVlIGRpcmVjdGx5LiAgSW4gbW9zdCBjYXNlcywgdGhpcyB3aWxsIGJlIGEgUmVzcG9uc2UgcmV0dXJuZWRcbiAgICogZnJvbSB0aGUgYWN0aW9uL2xvYWRlciwgYnV0IGl0IG1heSBiZSBhIHByaW1pdGl2ZSBvciBvdGhlciB2YWx1ZSBhcyB3ZWxsIC1cbiAgICogYW5kIGluIHN1Y2ggY2FzZXMgdGhlIGNhbGxpbmcgY29udGV4dCBzaG91bGQgaGFuZGxlIHRoYXQgYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIFdlIGRvIHJlc3BlY3QgdGhlIHRocm93L3JldHVybiBkaWZmZXJlbnRpYXRpb24sIHNvIGlmIGFuIGFjdGlvbi9sb2FkZXJcbiAgICogdGhyb3dzLCB0aGVuIHRoaXMgbWV0aG9kIHdpbGwgdGhyb3cgdGhlIHZhbHVlLiAgVGhpcyBpcyBpbXBvcnRhbnQgc28gd2VcbiAgICogY2FuIGRvIHByb3BlciBib3VuZGFyeSBpZGVudGlmaWNhdGlvbiBpbiBSZW1peCB3aGVyZSBhIHRocm93biBSZXNwb25zZVxuICAgKiBtdXN0IGdvIHRvIHRoZSBDYXRjaCBCb3VuZGFyeSBidXQgYSByZXR1cm5lZCBSZXNwb25zZSBpcyBoYXBweS1wYXRoLlxuICAgKlxuICAgKiBPbmUgdGhpbmcgdG8gbm90ZSBpcyB0aGF0IGFueSBSb3V0ZXItaW5pdGlhdGVkIEVycm9ycyB0aGF0IG1ha2Ugc2Vuc2VcbiAgICogdG8gYXNzb2NpYXRlIHdpdGggYSBzdGF0dXMgY29kZSB3aWxsIGJlIHRocm93biBhcyBhbiBFcnJvclJlc3BvbnNlXG4gICAqIGluc3RhbmNlIHdoaWNoIGluY2x1ZGUgdGhlIHJhdyBFcnJvciwgc3VjaCB0aGF0IHRoZSBjYWxsaW5nIGNvbnRleHQgY2FuXG4gICAqIHNlcmlhbGl6ZSB0aGUgZXJyb3IgYXMgdGhleSBzZWUgZml0IHdoaWxlIGluY2x1ZGluZyB0aGUgcHJvcGVyIHJlc3BvbnNlXG4gICAqIGNvZGUuICBFeGFtcGxlcyBoZXJlIGFyZSA0MDQgYW5kIDQwNSBlcnJvcnMgdGhhdCBvY2N1ciBwcmlvciB0byByZWFjaGluZ1xuICAgKiBhbnkgdXNlci1kZWZpbmVkIGxvYWRlcnMuXG4gICAqL1xuICBhc3luYyBmdW5jdGlvbiBxdWVyeVJvdXRlKHJlcXVlc3QsIF90ZW1wNCkge1xuICAgIGxldCB7XG4gICAgICByb3V0ZUlkLFxuICAgICAgcmVxdWVzdENvbnRleHRcbiAgICB9ID0gX3RlbXA0ID09PSB2b2lkIDAgPyB7fSA6IF90ZW1wNDtcbiAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgbGV0IG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICAgIGxldCBsb2NhdGlvbiA9IGNyZWF0ZUxvY2F0aW9uKFwiXCIsIGNyZWF0ZVBhdGgodXJsKSwgbnVsbCwgXCJkZWZhdWx0XCIpO1xuICAgIGxldCBtYXRjaGVzID0gbWF0Y2hSb3V0ZXMoZGF0YVJvdXRlcywgbG9jYXRpb24sIGJhc2VuYW1lKTtcbiAgICAvLyBTU1Igc3VwcG9ydHMgSEVBRCByZXF1ZXN0cyB3aGlsZSBTUEEgZG9lc24ndFxuICAgIGlmICghaXNWYWxpZE1ldGhvZChtZXRob2QpICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIgJiYgbWV0aG9kICE9PSBcIk9QVElPTlNcIikge1xuICAgICAgdGhyb3cgZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgbWV0aG9kXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCFtYXRjaGVzKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNCwge1xuICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgbWF0Y2ggPSByb3V0ZUlkID8gbWF0Y2hlcy5maW5kKG0gPT4gbS5yb3V0ZS5pZCA9PT0gcm91dGVJZCkgOiBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbik7XG4gICAgaWYgKHJvdXRlSWQgJiYgIW1hdGNoKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMywge1xuICAgICAgICBwYXRobmFtZTogbG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoIW1hdGNoKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoaXQgSSBkb24ndCB0aGluaz9cbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICAgIHBhdGhuYW1lOiBsb2NhdGlvbi5wYXRobmFtZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBhd2FpdCBxdWVyeUltcGwocmVxdWVzdCwgbG9jYXRpb24sIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0LCBtYXRjaCk7XG4gICAgaWYgKGlzUmVzcG9uc2UocmVzdWx0KSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbGV0IGVycm9yID0gcmVzdWx0LmVycm9ycyA/IE9iamVjdC52YWx1ZXMocmVzdWx0LmVycm9ycylbMF0gOiB1bmRlZmluZWQ7XG4gICAgaWYgKGVycm9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIElmIHdlIGdvdCBiYWNrIHJlc3VsdC5lcnJvcnMsIHRoYXQgbWVhbnMgdGhlIGxvYWRlci9hY3Rpb24gdGhyZXdcbiAgICAgIC8vIF9zb21ldGhpbmdfIHRoYXQgd2Fzbid0IGEgUmVzcG9uc2UsIGJ1dCBpdCdzIG5vdCBndWFyYW50ZWVkL3JlcXVpcmVkXG4gICAgICAvLyB0byBiZSBhbiBgaW5zdGFuY2VvZiBFcnJvcmAgZWl0aGVyLCBzbyB3ZSBoYXZlIHRvIHVzZSB0aHJvdyBoZXJlIHRvXG4gICAgICAvLyBwcmVzZXJ2ZSB0aGUgXCJlcnJvclwiIHN0YXRlIG91dHNpZGUgb2YgcXVlcnlJbXBsLlxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIC8vIFBpY2sgb2ZmIHRoZSByaWdodCBzdGF0ZSB2YWx1ZSB0byByZXR1cm5cbiAgICBpZiAocmVzdWx0LmFjdGlvbkRhdGEpIHtcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHJlc3VsdC5hY3Rpb25EYXRhKVswXTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5sb2FkZXJEYXRhKSB7XG4gICAgICB2YXIgX3Jlc3VsdCRhY3RpdmVEZWZlcnJlO1xuICAgICAgbGV0IGRhdGEgPSBPYmplY3QudmFsdWVzKHJlc3VsdC5sb2FkZXJEYXRhKVswXTtcbiAgICAgIGlmICgoX3Jlc3VsdCRhY3RpdmVEZWZlcnJlID0gcmVzdWx0LmFjdGl2ZURlZmVycmVkcykgIT0gbnVsbCAmJiBfcmVzdWx0JGFjdGl2ZURlZmVycmVbbWF0Y2gucm91dGUuaWRdKSB7XG4gICAgICAgIGRhdGFbVU5TQUZFX0RFRkVSUkVEX1NZTUJPTF0gPSByZXN1bHQuYWN0aXZlRGVmZXJyZWRzW21hdGNoLnJvdXRlLmlkXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGFzeW5jIGZ1bmN0aW9uIHF1ZXJ5SW1wbChyZXF1ZXN0LCBsb2NhdGlvbiwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQsIHJvdXRlTWF0Y2gpIHtcbiAgICBpbnZhcmlhbnQocmVxdWVzdC5zaWduYWwsIFwicXVlcnkoKS9xdWVyeVJvdXRlKCkgcmVxdWVzdHMgbXVzdCBjb250YWluIGFuIEFib3J0Q29udHJvbGxlciBzaWduYWxcIik7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChpc011dGF0aW9uTWV0aG9kKHJlcXVlc3QubWV0aG9kLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBzdWJtaXQocmVxdWVzdCwgbWF0Y2hlcywgcm91dGVNYXRjaCB8fCBnZXRUYXJnZXRNYXRjaChtYXRjaGVzLCBsb2NhdGlvbiksIHJlcXVlc3RDb250ZXh0LCByb3V0ZU1hdGNoICE9IG51bGwpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbGV0IHJlc3VsdCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEocmVxdWVzdCwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQsIHJvdXRlTWF0Y2gpO1xuICAgICAgcmV0dXJuIGlzUmVzcG9uc2UocmVzdWx0KSA/IHJlc3VsdCA6IF9leHRlbmRzKHt9LCByZXN1bHQsIHtcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgYWN0aW9uSGVhZGVyczoge31cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHRocmV3L3JldHVybmVkIGEgUmVzcG9uc2UgaW4gY2FsbExvYWRlck9yQWN0aW9uLCB3ZSB0aHJvd1xuICAgICAgLy8gaXQgdG8gYmFpbCBvdXQgYW5kIHRoZW4gcmV0dXJuIG9yIHRocm93IGhlcmUgYmFzZWQgb24gd2hldGhlciB0aGUgdXNlclxuICAgICAgLy8gcmV0dXJuZWQgb3IgdGhyZXdcbiAgICAgIGlmIChpc1F1ZXJ5Um91dGVSZXNwb25zZShlKSkge1xuICAgICAgICBpZiAoZS50eXBlID09PSBSZXN1bHRUeXBlLmVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZS5yZXNwb25zZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZS5yZXNwb25zZTtcbiAgICAgIH1cbiAgICAgIC8vIFJlZGlyZWN0cyBhcmUgYWx3YXlzIHJldHVybmVkIHNpbmNlIHRoZXkgZG9uJ3QgcHJvcGFnYXRlIHRvIGNhdGNoXG4gICAgICAvLyBib3VuZGFyaWVzXG4gICAgICBpZiAoaXNSZWRpcmVjdFJlc3BvbnNlKGUpKSB7XG4gICAgICAgIHJldHVybiBlO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgZnVuY3Rpb24gc3VibWl0KHJlcXVlc3QsIG1hdGNoZXMsIGFjdGlvbk1hdGNoLCByZXF1ZXN0Q29udGV4dCwgaXNSb3V0ZVJlcXVlc3QpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmICghYWN0aW9uTWF0Y2gucm91dGUuYWN0aW9uICYmICFhY3Rpb25NYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICBsZXQgZXJyb3IgPSBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQ6IGFjdGlvbk1hdGNoLnJvdXRlLmlkXG4gICAgICB9KTtcbiAgICAgIGlmIChpc1JvdXRlUmVxdWVzdCkge1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgdHlwZTogUmVzdWx0VHlwZS5lcnJvcixcbiAgICAgICAgZXJyb3JcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IGNhbGxMb2FkZXJPckFjdGlvbihcImFjdGlvblwiLCByZXF1ZXN0LCBhY3Rpb25NYXRjaCwgbWF0Y2hlcywgbWFuaWZlc3QsIG1hcFJvdXRlUHJvcGVydGllcywgYmFzZW5hbWUsIHtcbiAgICAgICAgaXNTdGF0aWNSZXF1ZXN0OiB0cnVlLFxuICAgICAgICBpc1JvdXRlUmVxdWVzdCxcbiAgICAgICAgcmVxdWVzdENvbnRleHRcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgbGV0IG1ldGhvZCA9IGlzUm91dGVSZXF1ZXN0ID8gXCJxdWVyeVJvdXRlXCIgOiBcInF1ZXJ5XCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyBcIigpIGNhbGwgYWJvcnRlZDogXCIgKyByZXF1ZXN0Lm1ldGhvZCArIFwiIFwiICsgcmVxdWVzdC51cmwpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBVaGhoaCAtIHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbiwgd2Ugc2hvdWxkIGFsd2F5cyB0aHJvdyB0aGVzZSBmcm9tXG4gICAgICAvLyBjYWxsTG9hZGVyT3JBY3Rpb24sIGJ1dCB0aGUgdHlwZSBuYXJyb3dpbmcgaGVyZSBrZWVwcyBUUyBoYXBweSBhbmQgd2VcbiAgICAgIC8vIGNhbiBnZXQgYmFjayBvbiB0aGUgXCJ0aHJvdyBhbGwgcmVkaXJlY3QgcmVzcG9uc2VzXCIgdHJhaW4gaGVyZSBzaG91bGRcbiAgICAgIC8vIHRoaXMgZXZlciBoYXBwZW4gOi9cbiAgICAgIHRocm93IG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogcmVzdWx0LnN0YXR1cyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiByZXN1bHQubG9jYXRpb25cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc0RlZmVycmVkUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBlcnJvciA9IGdldEludGVybmFsUm91dGVyRXJyb3IoNDAwLCB7XG4gICAgICAgIHR5cGU6IFwiZGVmZXItYWN0aW9uXCJcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICBlcnJvclxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGlzUm91dGVSZXF1ZXN0KSB7XG4gICAgICAvLyBOb3RlOiBUaGlzIHNob3VsZCBvbmx5IGJlIG5vbi1SZXNwb25zZSB2YWx1ZXMgaWYgd2UgZ2V0IGhlcmUsIHNpbmNlXG4gICAgICAvLyBpc1JvdXRlUmVxdWVzdCBzaG91bGQgdGhyb3cgYW55IFJlc3BvbnNlIHJlY2VpdmVkIGluIGNhbGxMb2FkZXJPckFjdGlvblxuICAgICAgaWYgKGlzRXJyb3JSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRjaGVzOiBbYWN0aW9uTWF0Y2hdLFxuICAgICAgICBsb2FkZXJEYXRhOiB7fSxcbiAgICAgICAgYWN0aW9uRGF0YToge1xuICAgICAgICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5kYXRhXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yczogbnVsbCxcbiAgICAgICAgLy8gTm90ZTogc3RhdHVzQ29kZSArIGhlYWRlcnMgYXJlIHVudXNlZCBoZXJlIHNpbmNlIHF1ZXJ5Um91dGUgd2lsbFxuICAgICAgICAvLyByZXR1cm4gdGhlIHJhdyBSZXNwb25zZSBvciB2YWx1ZVxuICAgICAgICBzdGF0dXNDb2RlOiAyMDAsXG4gICAgICAgIGxvYWRlckhlYWRlcnM6IHt9LFxuICAgICAgICBhY3Rpb25IZWFkZXJzOiB7fSxcbiAgICAgICAgYWN0aXZlRGVmZXJyZWRzOiBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoaXNFcnJvclJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBTdG9yZSBvZmYgdGhlIHBlbmRpbmcgZXJyb3IgLSB3ZSB1c2UgaXQgdG8gZGV0ZXJtaW5lIHdoaWNoIGxvYWRlcnNcbiAgICAgIC8vIHRvIGNhbGwgYW5kIHdpbGwgY29tbWl0IGl0IHdoZW4gd2UgY29tcGxldGUgdGhlIG5hdmlnYXRpb25cbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBhY3Rpb25NYXRjaC5yb3V0ZS5pZCk7XG4gICAgICBsZXQgY29udGV4dCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEocmVxdWVzdCwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQsIHVuZGVmaW5lZCwge1xuICAgICAgICBbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5lcnJvclxuICAgICAgfSk7XG4gICAgICAvLyBhY3Rpb24gc3RhdHVzIGNvZGVzIHRha2UgcHJlY2VkZW5jZSBvdmVyIGxvYWRlciBzdGF0dXMgY29kZXNcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgY29udGV4dCwge1xuICAgICAgICBzdGF0dXNDb2RlOiBpc1JvdXRlRXJyb3JSZXNwb25zZShyZXN1bHQuZXJyb3IpID8gcmVzdWx0LmVycm9yLnN0YXR1cyA6IDUwMCxcbiAgICAgICAgYWN0aW9uRGF0YTogbnVsbCxcbiAgICAgICAgYWN0aW9uSGVhZGVyczogX2V4dGVuZHMoe30sIHJlc3VsdC5oZWFkZXJzID8ge1xuICAgICAgICAgIFthY3Rpb25NYXRjaC5yb3V0ZS5pZF06IHJlc3VsdC5oZWFkZXJzXG4gICAgICAgIH0gOiB7fSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBDcmVhdGUgYSBHRVQgcmVxdWVzdCBmb3IgdGhlIGxvYWRlcnNcbiAgICBsZXQgbG9hZGVyUmVxdWVzdCA9IG5ldyBSZXF1ZXN0KHJlcXVlc3QudXJsLCB7XG4gICAgICBoZWFkZXJzOiByZXF1ZXN0LmhlYWRlcnMsXG4gICAgICByZWRpcmVjdDogcmVxdWVzdC5yZWRpcmVjdCxcbiAgICAgIHNpZ25hbDogcmVxdWVzdC5zaWduYWxcbiAgICB9KTtcbiAgICBsZXQgY29udGV4dCA9IGF3YWl0IGxvYWRSb3V0ZURhdGEobG9hZGVyUmVxdWVzdCwgbWF0Y2hlcywgcmVxdWVzdENvbnRleHQpO1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgY29udGV4dCwgcmVzdWx0LnN0YXR1c0NvZGUgPyB7XG4gICAgICBzdGF0dXNDb2RlOiByZXN1bHQuc3RhdHVzQ29kZVxuICAgIH0gOiB7fSwge1xuICAgICAgYWN0aW9uRGF0YToge1xuICAgICAgICBbYWN0aW9uTWF0Y2gucm91dGUuaWRdOiByZXN1bHQuZGF0YVxuICAgICAgfSxcbiAgICAgIGFjdGlvbkhlYWRlcnM6IF9leHRlbmRzKHt9LCByZXN1bHQuaGVhZGVycyA/IHtcbiAgICAgICAgW2FjdGlvbk1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmhlYWRlcnNcbiAgICAgIH0gOiB7fSlcbiAgICB9KTtcbiAgfVxuICBhc3luYyBmdW5jdGlvbiBsb2FkUm91dGVEYXRhKHJlcXVlc3QsIG1hdGNoZXMsIHJlcXVlc3RDb250ZXh0LCByb3V0ZU1hdGNoLCBwZW5kaW5nQWN0aW9uRXJyb3IpIHtcbiAgICBsZXQgaXNSb3V0ZVJlcXVlc3QgPSByb3V0ZU1hdGNoICE9IG51bGw7XG4gICAgLy8gU2hvcnQgY2lyY3VpdCBpZiB3ZSBoYXZlIG5vIGxvYWRlcnMgdG8gcnVuIChxdWVyeVJvdXRlKCkpXG4gICAgaWYgKGlzUm91dGVSZXF1ZXN0ICYmICEocm91dGVNYXRjaCAhPSBudWxsICYmIHJvdXRlTWF0Y2gucm91dGUubG9hZGVyKSAmJiAhKHJvdXRlTWF0Y2ggIT0gbnVsbCAmJiByb3V0ZU1hdGNoLnJvdXRlLmxhenkpKSB7XG4gICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwMCwge1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3QubWV0aG9kLFxuICAgICAgICBwYXRobmFtZTogbmV3IFVSTChyZXF1ZXN0LnVybCkucGF0aG5hbWUsXG4gICAgICAgIHJvdXRlSWQ6IHJvdXRlTWF0Y2ggPT0gbnVsbCA/IHZvaWQgMCA6IHJvdXRlTWF0Y2gucm91dGUuaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgcmVxdWVzdE1hdGNoZXMgPSByb3V0ZU1hdGNoID8gW3JvdXRlTWF0Y2hdIDogZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkobWF0Y2hlcywgT2JqZWN0LmtleXMocGVuZGluZ0FjdGlvbkVycm9yIHx8IHt9KVswXSk7XG4gICAgbGV0IG1hdGNoZXNUb0xvYWQgPSByZXF1ZXN0TWF0Y2hlcy5maWx0ZXIobSA9PiBtLnJvdXRlLmxvYWRlciB8fCBtLnJvdXRlLmxhenkpO1xuICAgIC8vIFNob3J0IGNpcmN1aXQgaWYgd2UgaGF2ZSBubyBsb2FkZXJzIHRvIHJ1biAocXVlcnkoKSlcbiAgICBpZiAobWF0Y2hlc1RvTG9hZC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdGNoZXMsXG4gICAgICAgIC8vIEFkZCBhIG51bGwgZm9yIGFsbCBtYXRjaGVkIHJvdXRlcyBmb3IgcHJvcGVyIHJldmFsaWRhdGlvbiBvbiB0aGUgY2xpZW50XG4gICAgICAgIGxvYWRlckRhdGE6IG1hdGNoZXMucmVkdWNlKChhY2MsIG0pID0+IE9iamVjdC5hc3NpZ24oYWNjLCB7XG4gICAgICAgICAgW20ucm91dGUuaWRdOiBudWxsXG4gICAgICAgIH0pLCB7fSksXG4gICAgICAgIGVycm9yczogcGVuZGluZ0FjdGlvbkVycm9yIHx8IG51bGwsXG4gICAgICAgIHN0YXR1c0NvZGU6IDIwMCxcbiAgICAgICAgbG9hZGVySGVhZGVyczoge30sXG4gICAgICAgIGFjdGl2ZURlZmVycmVkczogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChbLi4ubWF0Y2hlc1RvTG9hZC5tYXAobWF0Y2ggPT4gY2FsbExvYWRlck9yQWN0aW9uKFwibG9hZGVyXCIsIHJlcXVlc3QsIG1hdGNoLCBtYXRjaGVzLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzLCBiYXNlbmFtZSwge1xuICAgICAgaXNTdGF0aWNSZXF1ZXN0OiB0cnVlLFxuICAgICAgaXNSb3V0ZVJlcXVlc3QsXG4gICAgICByZXF1ZXN0Q29udGV4dFxuICAgIH0pKV0pO1xuICAgIGlmIChyZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICBsZXQgbWV0aG9kID0gaXNSb3V0ZVJlcXVlc3QgPyBcInF1ZXJ5Um91dGVcIiA6IFwicXVlcnlcIjtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyBcIigpIGNhbGwgYWJvcnRlZDogXCIgKyByZXF1ZXN0Lm1ldGhvZCArIFwiIFwiICsgcmVxdWVzdC51cmwpO1xuICAgIH1cbiAgICAvLyBQcm9jZXNzIGFuZCBjb21taXQgb3V0cHV0IGZyb20gbG9hZGVyc1xuICAgIGxldCBhY3RpdmVEZWZlcnJlZHMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IGNvbnRleHQgPSBwcm9jZXNzUm91dGVMb2FkZXJEYXRhKG1hdGNoZXMsIG1hdGNoZXNUb0xvYWQsIHJlc3VsdHMsIHBlbmRpbmdBY3Rpb25FcnJvciwgYWN0aXZlRGVmZXJyZWRzKTtcbiAgICAvLyBBZGQgYSBudWxsIGZvciBhbnkgbm9uLWxvYWRlciBtYXRjaGVzIGZvciBwcm9wZXIgcmV2YWxpZGF0aW9uIG9uIHRoZSBjbGllbnRcbiAgICBsZXQgZXhlY3V0ZWRMb2FkZXJzID0gbmV3IFNldChtYXRjaGVzVG9Mb2FkLm1hcChtYXRjaCA9PiBtYXRjaC5yb3V0ZS5pZCkpO1xuICAgIG1hdGNoZXMuZm9yRWFjaChtYXRjaCA9PiB7XG4gICAgICBpZiAoIWV4ZWN1dGVkTG9hZGVycy5oYXMobWF0Y2gucm91dGUuaWQpKSB7XG4gICAgICAgIGNvbnRleHQubG9hZGVyRGF0YVttYXRjaC5yb3V0ZS5pZF0gPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfZXh0ZW5kcyh7fSwgY29udGV4dCwge1xuICAgICAgbWF0Y2hlcyxcbiAgICAgIGFjdGl2ZURlZmVycmVkczogYWN0aXZlRGVmZXJyZWRzLnNpemUgPiAwID8gT2JqZWN0LmZyb21FbnRyaWVzKGFjdGl2ZURlZmVycmVkcy5lbnRyaWVzKCkpIDogbnVsbFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0YVJvdXRlcyxcbiAgICBxdWVyeSxcbiAgICBxdWVyeVJvdXRlXG4gIH07XG59XG4vLyNlbmRyZWdpb25cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyNyZWdpb24gSGVscGVyc1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKlxuICogR2l2ZW4gYW4gZXhpc3RpbmcgU3RhdGljSGFuZGxlckNvbnRleHQgYW5kIGFuIGVycm9yIHRocm93biBhdCByZW5kZXIgdGltZSxcbiAqIHByb3ZpZGUgYW4gdXBkYXRlZCBTdGF0aWNIYW5kbGVyQ29udGV4dCBzdWl0YWJsZSBmb3IgYSBzZWNvbmQgU1NSIHJlbmRlclxuICovXG5mdW5jdGlvbiBnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yKHJvdXRlcywgY29udGV4dCwgZXJyb3IpIHtcbiAgbGV0IG5ld0NvbnRleHQgPSBfZXh0ZW5kcyh7fSwgY29udGV4dCwge1xuICAgIHN0YXR1c0NvZGU6IDUwMCxcbiAgICBlcnJvcnM6IHtcbiAgICAgIFtjb250ZXh0Ll9kZWVwZXN0UmVuZGVyZWRCb3VuZGFyeUlkIHx8IHJvdXRlc1swXS5pZF06IGVycm9yXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ld0NvbnRleHQ7XG59XG5mdW5jdGlvbiBpc1N1Ym1pc3Npb25OYXZpZ2F0aW9uKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgIT0gbnVsbCAmJiAoXCJmb3JtRGF0YVwiIGluIG9wdHMgJiYgb3B0cy5mb3JtRGF0YSAhPSBudWxsIHx8IFwiYm9keVwiIGluIG9wdHMgJiYgb3B0cy5ib2R5ICE9PSB1bmRlZmluZWQpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVG8obG9jYXRpb24sIG1hdGNoZXMsIGJhc2VuYW1lLCBwcmVwZW5kQmFzZW5hbWUsIHRvLCBmcm9tUm91dGVJZCwgcmVsYXRpdmUpIHtcbiAgbGV0IGNvbnRleHR1YWxNYXRjaGVzO1xuICBsZXQgYWN0aXZlUm91dGVNYXRjaDtcbiAgaWYgKGZyb21Sb3V0ZUlkKSB7XG4gICAgLy8gR3JhYiBtYXRjaGVzIHVwIHRvIHRoZSBjYWxsaW5nIHJvdXRlIHNvIG91ciByb3V0ZS1yZWxhdGl2ZSBsb2dpYyBpc1xuICAgIC8vIHJlbGF0aXZlIHRvIHRoZSBjb3JyZWN0IHNvdXJjZSByb3V0ZVxuICAgIGNvbnRleHR1YWxNYXRjaGVzID0gW107XG4gICAgZm9yIChsZXQgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgY29udGV4dHVhbE1hdGNoZXMucHVzaChtYXRjaCk7XG4gICAgICBpZiAobWF0Y2gucm91dGUuaWQgPT09IGZyb21Sb3V0ZUlkKSB7XG4gICAgICAgIGFjdGl2ZVJvdXRlTWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnRleHR1YWxNYXRjaGVzID0gbWF0Y2hlcztcbiAgICBhY3RpdmVSb3V0ZU1hdGNoID0gbWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdO1xuICB9XG4gIC8vIFJlc29sdmUgdGhlIHJlbGF0aXZlIHBhdGhcbiAgbGV0IHBhdGggPSByZXNvbHZlVG8odG8gPyB0byA6IFwiLlwiLCBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhjb250ZXh0dWFsTWF0Y2hlcykubWFwKG0gPT4gbS5wYXRobmFtZUJhc2UpLCBzdHJpcEJhc2VuYW1lKGxvY2F0aW9uLnBhdGhuYW1lLCBiYXNlbmFtZSkgfHwgbG9jYXRpb24ucGF0aG5hbWUsIHJlbGF0aXZlID09PSBcInBhdGhcIik7XG4gIC8vIFdoZW4gYHRvYCBpcyBub3Qgc3BlY2lmaWVkIHdlIGluaGVyaXQgc2VhcmNoL2hhc2ggZnJvbSB0aGUgY3VycmVudFxuICAvLyBsb2NhdGlvbiwgdW5saWtlIHdoZW4gdG89XCIuXCIgYW5kIHdlIGp1c3QgaW5oZXJpdCB0aGUgcGF0aC5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1peC1ydW4vcmVtaXgvaXNzdWVzLzkyN1xuICBpZiAodG8gPT0gbnVsbCkge1xuICAgIHBhdGguc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoO1xuICAgIHBhdGguaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG4gIH1cbiAgLy8gQWRkIGFuID9pbmRleCBwYXJhbSBmb3IgbWF0Y2hlZCBpbmRleCByb3V0ZXMgaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIG9uZVxuICBpZiAoKHRvID09IG51bGwgfHwgdG8gPT09IFwiXCIgfHwgdG8gPT09IFwiLlwiKSAmJiBhY3RpdmVSb3V0ZU1hdGNoICYmIGFjdGl2ZVJvdXRlTWF0Y2gucm91dGUuaW5kZXggJiYgIWhhc05ha2VkSW5kZXhRdWVyeShwYXRoLnNlYXJjaCkpIHtcbiAgICBwYXRoLnNlYXJjaCA9IHBhdGguc2VhcmNoID8gcGF0aC5zZWFyY2gucmVwbGFjZSgvXlxcPy8sIFwiP2luZGV4JlwiKSA6IFwiP2luZGV4XCI7XG4gIH1cbiAgLy8gSWYgd2UncmUgb3BlcmF0aW5nIHdpdGhpbiBhIGJhc2VuYW1lLCBwcmVwZW5kIGl0IHRvIHRoZSBwYXRobmFtZS4gIElmXG4gIC8vIHRoaXMgaXMgYSByb290IG5hdmlnYXRpb24sIHRoZW4ganVzdCB1c2UgdGhlIHJhdyBiYXNlbmFtZSB3aGljaCBhbGxvd3NcbiAgLy8gdGhlIGJhc2VuYW1lIHRvIGhhdmUgZnVsbCBjb250cm9sIG92ZXIgdGhlIHByZXNlbmNlIG9mIGEgdHJhaWxpbmcgc2xhc2hcbiAgLy8gb24gcm9vdCBhY3Rpb25zXG4gIGlmIChwcmVwZW5kQmFzZW5hbWUgJiYgYmFzZW5hbWUgIT09IFwiL1wiKSB7XG4gICAgcGF0aC5wYXRobmFtZSA9IHBhdGgucGF0aG5hbWUgPT09IFwiL1wiID8gYmFzZW5hbWUgOiBqb2luUGF0aHMoW2Jhc2VuYW1lLCBwYXRoLnBhdGhuYW1lXSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZVBhdGgocGF0aCk7XG59XG4vLyBOb3JtYWxpemUgbmF2aWdhdGlvbiBvcHRpb25zIGJ5IGNvbnZlcnRpbmcgZm9ybU1ldGhvZD1HRVQgZm9ybURhdGEgb2JqZWN0cyB0b1xuLy8gVVJMU2VhcmNoUGFyYW1zIHNvIHRoZXkgYmVoYXZlIGlkZW50aWNhbGx5IHRvIGxpbmtzIHdpdGggcXVlcnkgcGFyYW1zXG5mdW5jdGlvbiBub3JtYWxpemVOYXZpZ2F0ZU9wdGlvbnMobm9ybWFsaXplRm9ybU1ldGhvZCwgaXNGZXRjaGVyLCBwYXRoLCBvcHRzKSB7XG4gIC8vIFJldHVybiBsb2NhdGlvbiB2ZXJiYXRpbSBvbiBub24tc3VibWlzc2lvbiBuYXZpZ2F0aW9uc1xuICBpZiAoIW9wdHMgfHwgIWlzU3VibWlzc2lvbk5hdmlnYXRpb24ob3B0cykpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aFxuICAgIH07XG4gIH1cbiAgaWYgKG9wdHMuZm9ybU1ldGhvZCAmJiAhaXNWYWxpZE1ldGhvZChvcHRzLmZvcm1NZXRob2QpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhdGgsXG4gICAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDUsIHtcbiAgICAgICAgbWV0aG9kOiBvcHRzLmZvcm1NZXRob2RcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBsZXQgZ2V0SW52YWxpZEJvZHlFcnJvciA9ICgpID0+ICh7XG4gICAgcGF0aCxcbiAgICBlcnJvcjogZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcig0MDAsIHtcbiAgICAgIHR5cGU6IFwiaW52YWxpZC1ib2R5XCJcbiAgICB9KVxuICB9KTtcbiAgLy8gQ3JlYXRlIGEgU3VibWlzc2lvbiBvbiBub24tR0VUIG5hdmlnYXRpb25zXG4gIGxldCByYXdGb3JtTWV0aG9kID0gb3B0cy5mb3JtTWV0aG9kIHx8IFwiZ2V0XCI7XG4gIGxldCBmb3JtTWV0aG9kID0gbm9ybWFsaXplRm9ybU1ldGhvZCA/IHJhd0Zvcm1NZXRob2QudG9VcHBlckNhc2UoKSA6IHJhd0Zvcm1NZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgbGV0IGZvcm1BY3Rpb24gPSBzdHJpcEhhc2hGcm9tUGF0aChwYXRoKTtcbiAgaWYgKG9wdHMuYm9keSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKG9wdHMuZm9ybUVuY1R5cGUgPT09IFwidGV4dC9wbGFpblwiKSB7XG4gICAgICAvLyB0ZXh0IG9ubHkgc3VwcG9ydCBQT1NUL1BVVC9QQVRDSC9ERUxFVEUgc3VibWlzc2lvbnNcbiAgICAgIGlmICghaXNNdXRhdGlvbk1ldGhvZChmb3JtTWV0aG9kKSkge1xuICAgICAgICByZXR1cm4gZ2V0SW52YWxpZEJvZHlFcnJvcigpO1xuICAgICAgfVxuICAgICAgbGV0IHRleHQgPSB0eXBlb2Ygb3B0cy5ib2R5ID09PSBcInN0cmluZ1wiID8gb3B0cy5ib2R5IDogb3B0cy5ib2R5IGluc3RhbmNlb2YgRm9ybURhdGEgfHwgb3B0cy5ib2R5IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zID9cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2Zvcm0tY29udHJvbC1pbmZyYXN0cnVjdHVyZS5odG1sI3BsYWluLXRleHQtZm9ybS1kYXRhXG4gICAgICBBcnJheS5mcm9tKG9wdHMuYm9keS5lbnRyaWVzKCkpLnJlZHVjZSgoYWNjLCBfcmVmMykgPT4ge1xuICAgICAgICBsZXQgW25hbWUsIHZhbHVlXSA9IF9yZWYzO1xuICAgICAgICByZXR1cm4gXCJcIiArIGFjYyArIG5hbWUgKyBcIj1cIiArIHZhbHVlICsgXCJcXG5cIjtcbiAgICAgIH0sIFwiXCIpIDogU3RyaW5nKG9wdHMuYm9keSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXRoLFxuICAgICAgICBzdWJtaXNzaW9uOiB7XG4gICAgICAgICAgZm9ybU1ldGhvZCxcbiAgICAgICAgICBmb3JtQWN0aW9uLFxuICAgICAgICAgIGZvcm1FbmNUeXBlOiBvcHRzLmZvcm1FbmNUeXBlLFxuICAgICAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAganNvbjogdW5kZWZpbmVkLFxuICAgICAgICAgIHRleHRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG9wdHMuZm9ybUVuY1R5cGUgPT09IFwiYXBwbGljYXRpb24vanNvblwiKSB7XG4gICAgICAvLyBqc29uIG9ubHkgc3VwcG9ydHMgUE9TVC9QVVQvUEFUQ0gvREVMRVRFIHN1Ym1pc3Npb25zXG4gICAgICBpZiAoIWlzTXV0YXRpb25NZXRob2QoZm9ybU1ldGhvZCkpIHtcbiAgICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBqc29uID0gdHlwZW9mIG9wdHMuYm9keSA9PT0gXCJzdHJpbmdcIiA/IEpTT04ucGFyc2Uob3B0cy5ib2R5KSA6IG9wdHMuYm9keTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXRoLFxuICAgICAgICAgIHN1Ym1pc3Npb246IHtcbiAgICAgICAgICAgIGZvcm1NZXRob2QsXG4gICAgICAgICAgICBmb3JtQWN0aW9uLFxuICAgICAgICAgICAgZm9ybUVuY1R5cGU6IG9wdHMuZm9ybUVuY1R5cGUsXG4gICAgICAgICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAgICAgICAganNvbixcbiAgICAgICAgICAgIHRleHQ6IHVuZGVmaW5lZFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaW52YXJpYW50KHR5cGVvZiBGb3JtRGF0YSA9PT0gXCJmdW5jdGlvblwiLCBcIkZvcm1EYXRhIGlzIG5vdCBhdmFpbGFibGUgaW4gdGhpcyBlbnZpcm9ubWVudFwiKTtcbiAgbGV0IHNlYXJjaFBhcmFtcztcbiAgbGV0IGZvcm1EYXRhO1xuICBpZiAob3B0cy5mb3JtRGF0YSkge1xuICAgIHNlYXJjaFBhcmFtcyA9IGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKG9wdHMuZm9ybURhdGEpO1xuICAgIGZvcm1EYXRhID0gb3B0cy5mb3JtRGF0YTtcbiAgfSBlbHNlIGlmIChvcHRzLmJvZHkgaW5zdGFuY2VvZiBGb3JtRGF0YSkge1xuICAgIHNlYXJjaFBhcmFtcyA9IGNvbnZlcnRGb3JtRGF0YVRvU2VhcmNoUGFyYW1zKG9wdHMuYm9keSk7XG4gICAgZm9ybURhdGEgPSBvcHRzLmJvZHk7XG4gIH0gZWxzZSBpZiAob3B0cy5ib2R5IGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG4gICAgc2VhcmNoUGFyYW1zID0gb3B0cy5ib2R5O1xuICAgIGZvcm1EYXRhID0gY29udmVydFNlYXJjaFBhcmFtc1RvRm9ybURhdGEoc2VhcmNoUGFyYW1zKTtcbiAgfSBlbHNlIGlmIChvcHRzLmJvZHkgPT0gbnVsbCkge1xuICAgIHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgICBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBzZWFyY2hQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKG9wdHMuYm9keSk7XG4gICAgICBmb3JtRGF0YSA9IGNvbnZlcnRTZWFyY2hQYXJhbXNUb0Zvcm1EYXRhKHNlYXJjaFBhcmFtcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIGdldEludmFsaWRCb2R5RXJyb3IoKTtcbiAgICB9XG4gIH1cbiAgbGV0IHN1Ym1pc3Npb24gPSB7XG4gICAgZm9ybU1ldGhvZCxcbiAgICBmb3JtQWN0aW9uLFxuICAgIGZvcm1FbmNUeXBlOiBvcHRzICYmIG9wdHMuZm9ybUVuY1R5cGUgfHwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIixcbiAgICBmb3JtRGF0YSxcbiAgICBqc29uOiB1bmRlZmluZWQsXG4gICAgdGV4dDogdW5kZWZpbmVkXG4gIH07XG4gIGlmIChpc011dGF0aW9uTWV0aG9kKHN1Ym1pc3Npb24uZm9ybU1ldGhvZCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aCxcbiAgICAgIHN1Ym1pc3Npb25cbiAgICB9O1xuICB9XG4gIC8vIEZsYXR0ZW4gc3VibWlzc2lvbiBvbnRvIFVSTFNlYXJjaFBhcmFtcyBmb3IgR0VUIHN1Ym1pc3Npb25zXG4gIGxldCBwYXJzZWRQYXRoID0gcGFyc2VQYXRoKHBhdGgpO1xuICAvLyBPbiBHRVQgbmF2aWdhdGlvbiBzdWJtaXNzaW9ucyB3ZSBjYW4gZHJvcCB0aGUgP2luZGV4IHBhcmFtIGZyb20gdGhlXG4gIC8vIHJlc3VsdGluZyBsb2NhdGlvbiBzaW5jZSBhbGwgbG9hZGVycyB3aWxsIHJ1bi4gIEJ1dCBmZXRjaGVyIEdFVCBzdWJtaXNzaW9uc1xuICAvLyBvbmx5IHJ1biBhIHNpbmdsZSBsb2FkZXIgc28gd2UgbmVlZCB0byBwcmVzZXJ2ZSBhbnkgaW5jb21pbmcgP2luZGV4IHBhcmFtc1xuICBpZiAoaXNGZXRjaGVyICYmIHBhcnNlZFBhdGguc2VhcmNoICYmIGhhc05ha2VkSW5kZXhRdWVyeShwYXJzZWRQYXRoLnNlYXJjaCkpIHtcbiAgICBzZWFyY2hQYXJhbXMuYXBwZW5kKFwiaW5kZXhcIiwgXCJcIik7XG4gIH1cbiAgcGFyc2VkUGF0aC5zZWFyY2ggPSBcIj9cIiArIHNlYXJjaFBhcmFtcztcbiAgcmV0dXJuIHtcbiAgICBwYXRoOiBjcmVhdGVQYXRoKHBhcnNlZFBhdGgpLFxuICAgIHN1Ym1pc3Npb25cbiAgfTtcbn1cbi8vIEZpbHRlciBvdXQgYWxsIHJvdXRlcyBiZWxvdyBhbnkgY2F1Z2h0IGVycm9yIGFzIHRoZXkgYXJlbid0IGdvaW5nIHRvXG4vLyByZW5kZXIgc28gd2UgZG9uJ3QgbmVlZCB0byBsb2FkIHRoZW1cbmZ1bmN0aW9uIGdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5KG1hdGNoZXMsIGJvdW5kYXJ5SWQpIHtcbiAgbGV0IGJvdW5kYXJ5TWF0Y2hlcyA9IG1hdGNoZXM7XG4gIGlmIChib3VuZGFyeUlkKSB7XG4gICAgbGV0IGluZGV4ID0gbWF0Y2hlcy5maW5kSW5kZXgobSA9PiBtLnJvdXRlLmlkID09PSBib3VuZGFyeUlkKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgYm91bmRhcnlNYXRjaGVzID0gbWF0Y2hlcy5zbGljZSgwLCBpbmRleCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBib3VuZGFyeU1hdGNoZXM7XG59XG5mdW5jdGlvbiBnZXRNYXRjaGVzVG9Mb2FkKGhpc3RvcnksIHN0YXRlLCBtYXRjaGVzLCBzdWJtaXNzaW9uLCBsb2NhdGlvbiwgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCwgY2FuY2VsbGVkRGVmZXJyZWRSb3V0ZXMsIGNhbmNlbGxlZEZldGNoZXJMb2FkcywgZGVsZXRlZEZldGNoZXJzLCBmZXRjaExvYWRNYXRjaGVzLCBmZXRjaFJlZGlyZWN0SWRzLCByb3V0ZXNUb1VzZSwgYmFzZW5hbWUsIHBlbmRpbmdBY3Rpb25EYXRhLCBwZW5kaW5nRXJyb3IpIHtcbiAgbGV0IGFjdGlvblJlc3VsdCA9IHBlbmRpbmdFcnJvciA/IE9iamVjdC52YWx1ZXMocGVuZGluZ0Vycm9yKVswXSA6IHBlbmRpbmdBY3Rpb25EYXRhID8gT2JqZWN0LnZhbHVlcyhwZW5kaW5nQWN0aW9uRGF0YSlbMF0gOiB1bmRlZmluZWQ7XG4gIGxldCBjdXJyZW50VXJsID0gaGlzdG9yeS5jcmVhdGVVUkwoc3RhdGUubG9jYXRpb24pO1xuICBsZXQgbmV4dFVybCA9IGhpc3RvcnkuY3JlYXRlVVJMKGxvY2F0aW9uKTtcbiAgLy8gUGljayBuYXZpZ2F0aW9uIG1hdGNoZXMgdGhhdCBhcmUgbmV0LW5ldyBvciBxdWFsaWZ5IGZvciByZXZhbGlkYXRpb25cbiAgbGV0IGJvdW5kYXJ5SWQgPSBwZW5kaW5nRXJyb3IgPyBPYmplY3Qua2V5cyhwZW5kaW5nRXJyb3IpWzBdIDogdW5kZWZpbmVkO1xuICBsZXQgYm91bmRhcnlNYXRjaGVzID0gZ2V0TG9hZGVyTWF0Y2hlc1VudGlsQm91bmRhcnkobWF0Y2hlcywgYm91bmRhcnlJZCk7XG4gIGxldCBuYXZpZ2F0aW9uTWF0Y2hlcyA9IGJvdW5kYXJ5TWF0Y2hlcy5maWx0ZXIoKG1hdGNoLCBpbmRleCkgPT4ge1xuICAgIGlmIChtYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICAvLyBXZSBoYXZlbid0IGxvYWRlZCB0aGlzIHJvdXRlIHlldCBzbyB3ZSBkb24ndCBrbm93IGlmIGl0J3MgZ290IGEgbG9hZGVyIVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChtYXRjaC5yb3V0ZS5sb2FkZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBBbHdheXMgY2FsbCB0aGUgbG9hZGVyIG9uIG5ldyByb3V0ZSBpbnN0YW5jZXMgYW5kIHBlbmRpbmcgZGVmZXIgY2FuY2VsbGF0aW9uc1xuICAgIGlmIChpc05ld0xvYWRlcihzdGF0ZS5sb2FkZXJEYXRhLCBzdGF0ZS5tYXRjaGVzW2luZGV4XSwgbWF0Y2gpIHx8IGNhbmNlbGxlZERlZmVycmVkUm91dGVzLnNvbWUoaWQgPT4gaWQgPT09IG1hdGNoLnJvdXRlLmlkKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIHdoZW4gd2UgcmV2YWxpZGF0ZS4gIElmIHRoZSByb3V0ZVxuICAgIC8vIHByb3ZpZGVzIGl0J3Mgb3duIGltcGxlbWVudGF0aW9uLCB0aGVuIHdlIGdpdmUgdGhlbSBmdWxsIGNvbnRyb2wgYnV0XG4gICAgLy8gcHJvdmlkZSB0aGlzIHZhbHVlIHNvIHRoZXkgY2FuIGxldmVyYWdlIGl0IGlmIG5lZWRlZCBhZnRlciB0aGV5IGNoZWNrXG4gICAgLy8gdGhlaXIgb3duIHNwZWNpZmljIHVzZSBjYXNlc1xuICAgIGxldCBjdXJyZW50Um91dGVNYXRjaCA9IHN0YXRlLm1hdGNoZXNbaW5kZXhdO1xuICAgIGxldCBuZXh0Um91dGVNYXRjaCA9IG1hdGNoO1xuICAgIHJldHVybiBzaG91bGRSZXZhbGlkYXRlTG9hZGVyKG1hdGNoLCBfZXh0ZW5kcyh7XG4gICAgICBjdXJyZW50VXJsLFxuICAgICAgY3VycmVudFBhcmFtczogY3VycmVudFJvdXRlTWF0Y2gucGFyYW1zLFxuICAgICAgbmV4dFVybCxcbiAgICAgIG5leHRQYXJhbXM6IG5leHRSb3V0ZU1hdGNoLnBhcmFtc1xuICAgIH0sIHN1Ym1pc3Npb24sIHtcbiAgICAgIGFjdGlvblJlc3VsdCxcbiAgICAgIGRlZmF1bHRTaG91bGRSZXZhbGlkYXRlOlxuICAgICAgLy8gRm9yY2VkIHJldmFsaWRhdGlvbiBkdWUgdG8gc3VibWlzc2lvbiwgdXNlUmV2YWxpZGF0b3IsIG9yIFgtUmVtaXgtUmV2YWxpZGF0ZVxuICAgICAgaXNSZXZhbGlkYXRpb25SZXF1aXJlZCB8fFxuICAgICAgLy8gQ2xpY2tlZCB0aGUgc2FtZSBsaW5rLCByZXN1Ym1pdHRlZCBhIEdFVCBmb3JtXG4gICAgICBjdXJyZW50VXJsLnBhdGhuYW1lICsgY3VycmVudFVybC5zZWFyY2ggPT09IG5leHRVcmwucGF0aG5hbWUgKyBuZXh0VXJsLnNlYXJjaCB8fFxuICAgICAgLy8gU2VhcmNoIHBhcmFtcyBhZmZlY3QgYWxsIGxvYWRlcnNcbiAgICAgIGN1cnJlbnRVcmwuc2VhcmNoICE9PSBuZXh0VXJsLnNlYXJjaCB8fCBpc05ld1JvdXRlSW5zdGFuY2UoY3VycmVudFJvdXRlTWF0Y2gsIG5leHRSb3V0ZU1hdGNoKVxuICAgIH0pKTtcbiAgfSk7XG4gIC8vIFBpY2sgZmV0Y2hlci5sb2FkcyB0aGF0IG5lZWQgdG8gYmUgcmV2YWxpZGF0ZWRcbiAgbGV0IHJldmFsaWRhdGluZ0ZldGNoZXJzID0gW107XG4gIGZldGNoTG9hZE1hdGNoZXMuZm9yRWFjaCgoZiwga2V5KSA9PiB7XG4gICAgLy8gRG9uJ3QgcmV2YWxpZGF0ZSBpZiBmZXRjaGVyIHdvbid0IGJlIHByZXNlbnQgaW4gdGhlIHN1YnNlcXVlbnQgcmVuZGVyXG4gICAgaWYgKCFtYXRjaGVzLnNvbWUobSA9PiBtLnJvdXRlLmlkID09PSBmLnJvdXRlSWQpIHx8IGRlbGV0ZWRGZXRjaGVycy5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZmV0Y2hlck1hdGNoZXMgPSBtYXRjaFJvdXRlcyhyb3V0ZXNUb1VzZSwgZi5wYXRoLCBiYXNlbmFtZSk7XG4gICAgLy8gSWYgdGhlIGZldGNoZXIgcGF0aCBubyBsb25nZXIgbWF0Y2hlcywgcHVzaCBpdCBpbiB3aXRoIG51bGwgbWF0Y2hlcyBzb1xuICAgIC8vIHdlIGNhbiB0cmlnZ2VyIGEgNDA0IGluIGNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YS4gIE5vdGUgdGhpcyBpc1xuICAgIC8vIGN1cnJlbnRseSBvbmx5IGEgdXNlLWNhc2UgZm9yIFJlbWl4IEhNUiB3aGVyZSB0aGUgcm91dGUgdHJlZSBjYW4gY2hhbmdlXG4gICAgLy8gYXQgcnVudGltZSBhbmQgcmVtb3ZlIGEgcm91dGUgcHJldmlvdXNseSBsb2FkZWQgdmlhIGEgZmV0Y2hlclxuICAgIGlmICghZmV0Y2hlck1hdGNoZXMpIHtcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLnB1c2goe1xuICAgICAgICBrZXksXG4gICAgICAgIHJvdXRlSWQ6IGYucm91dGVJZCxcbiAgICAgICAgcGF0aDogZi5wYXRoLFxuICAgICAgICBtYXRjaGVzOiBudWxsLFxuICAgICAgICBtYXRjaDogbnVsbCxcbiAgICAgICAgY29udHJvbGxlcjogbnVsbFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJldmFsaWRhdGluZyBmZXRjaGVycyBhcmUgZGVjb3VwbGVkIGZyb20gdGhlIHJvdXRlIG1hdGNoZXMgc2luY2UgdGhleVxuICAgIC8vIGxvYWQgZnJvbSBhIHN0YXRpYyBocmVmLiAgVGhleSByZXZhbGlkYXRlIGJhc2VkIG9uIGV4cGxpY2l0IHJldmFsaWRhdGlvblxuICAgIC8vIChzdWJtaXNzaW9uLCB1c2VSZXZhbGlkYXRvciwgb3IgWC1SZW1peC1SZXZhbGlkYXRlKVxuICAgIGxldCBmZXRjaGVyID0gc3RhdGUuZmV0Y2hlcnMuZ2V0KGtleSk7XG4gICAgbGV0IGZldGNoZXJNYXRjaCA9IGdldFRhcmdldE1hdGNoKGZldGNoZXJNYXRjaGVzLCBmLnBhdGgpO1xuICAgIGxldCBzaG91bGRSZXZhbGlkYXRlID0gZmFsc2U7XG4gICAgaWYgKGZldGNoUmVkaXJlY3RJZHMuaGFzKGtleSkpIHtcbiAgICAgIC8vIE5ldmVyIHRyaWdnZXIgYSByZXZhbGlkYXRpb24gb2YgYW4gYWN0aXZlbHkgcmVkaXJlY3RpbmcgZmV0Y2hlclxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoY2FuY2VsbGVkRmV0Y2hlckxvYWRzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIC8vIEFsd2F5cyByZXZhbGlkYXRlIGlmIHRoZSBmZXRjaGVyIHdhcyBjYW5jZWxsZWRcbiAgICAgIHNob3VsZFJldmFsaWRhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZmV0Y2hlciAmJiBmZXRjaGVyLnN0YXRlICE9PSBcImlkbGVcIiAmJiBmZXRjaGVyLmRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gSWYgdGhlIGZldGNoZXIgaGFzbid0IGV2ZXIgY29tcGxldGVkIGxvYWRpbmcgeWV0LCB0aGVuIHRoaXMgaXNuJ3QgYVxuICAgICAgLy8gcmV2YWxpZGF0aW9uLCBpdCB3b3VsZCBqdXN0IGJlIGEgYnJhbmQgbmV3IGxvYWQgaWYgYW4gZXhwbGljaXRcbiAgICAgIC8vIHJldmFsaWRhdGlvbiBpcyByZXF1aXJlZFxuICAgICAgc2hvdWxkUmV2YWxpZGF0ZSA9IGlzUmV2YWxpZGF0aW9uUmVxdWlyZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSBmYWxsIGJhY2sgb24gYW55IHVzZXItZGVmaW5lZCBzaG91bGRSZXZhbGlkYXRlLCBkZWZhdWx0aW5nXG4gICAgICAvLyB0byBleHBsaWNpdCByZXZhbGlkYXRpb25zIG9ubHlcbiAgICAgIHNob3VsZFJldmFsaWRhdGUgPSBzaG91bGRSZXZhbGlkYXRlTG9hZGVyKGZldGNoZXJNYXRjaCwgX2V4dGVuZHMoe1xuICAgICAgICBjdXJyZW50VXJsLFxuICAgICAgICBjdXJyZW50UGFyYW1zOiBzdGF0ZS5tYXRjaGVzW3N0YXRlLm1hdGNoZXMubGVuZ3RoIC0gMV0ucGFyYW1zLFxuICAgICAgICBuZXh0VXJsLFxuICAgICAgICBuZXh0UGFyYW1zOiBtYXRjaGVzW21hdGNoZXMubGVuZ3RoIC0gMV0ucGFyYW1zXG4gICAgICB9LCBzdWJtaXNzaW9uLCB7XG4gICAgICAgIGFjdGlvblJlc3VsdCxcbiAgICAgICAgZGVmYXVsdFNob3VsZFJldmFsaWRhdGU6IGlzUmV2YWxpZGF0aW9uUmVxdWlyZWRcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgaWYgKHNob3VsZFJldmFsaWRhdGUpIHtcbiAgICAgIHJldmFsaWRhdGluZ0ZldGNoZXJzLnB1c2goe1xuICAgICAgICBrZXksXG4gICAgICAgIHJvdXRlSWQ6IGYucm91dGVJZCxcbiAgICAgICAgcGF0aDogZi5wYXRoLFxuICAgICAgICBtYXRjaGVzOiBmZXRjaGVyTWF0Y2hlcyxcbiAgICAgICAgbWF0Y2g6IGZldGNoZXJNYXRjaCxcbiAgICAgICAgY29udHJvbGxlcjogbmV3IEFib3J0Q29udHJvbGxlcigpXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gW25hdmlnYXRpb25NYXRjaGVzLCByZXZhbGlkYXRpbmdGZXRjaGVyc107XG59XG5mdW5jdGlvbiBpc05ld0xvYWRlcihjdXJyZW50TG9hZGVyRGF0YSwgY3VycmVudE1hdGNoLCBtYXRjaCkge1xuICBsZXQgaXNOZXcgPVxuICAvLyBbYV0gLT4gW2EsIGJdXG4gICFjdXJyZW50TWF0Y2ggfHxcbiAgLy8gW2EsIGJdIC0+IFthLCBjXVxuICBtYXRjaC5yb3V0ZS5pZCAhPT0gY3VycmVudE1hdGNoLnJvdXRlLmlkO1xuICAvLyBIYW5kbGUgdGhlIGNhc2UgdGhhdCB3ZSBkb24ndCBoYXZlIGRhdGEgZm9yIGEgcmUtdXNlZCByb3V0ZSwgcG90ZW50aWFsbHlcbiAgLy8gZnJvbSBhIHByaW9yIGVycm9yIG9yIGZyb20gYSBjYW5jZWxsZWQgcGVuZGluZyBkZWZlcnJlZFxuICBsZXQgaXNNaXNzaW5nRGF0YSA9IGN1cnJlbnRMb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSA9PT0gdW5kZWZpbmVkO1xuICAvLyBBbHdheXMgbG9hZCBpZiB0aGlzIGlzIGEgbmV0LW5ldyByb3V0ZSBvciB3ZSBkb24ndCB5ZXQgaGF2ZSBkYXRhXG4gIHJldHVybiBpc05ldyB8fCBpc01pc3NpbmdEYXRhO1xufVxuZnVuY3Rpb24gaXNOZXdSb3V0ZUluc3RhbmNlKGN1cnJlbnRNYXRjaCwgbWF0Y2gpIHtcbiAgbGV0IGN1cnJlbnRQYXRoID0gY3VycmVudE1hdGNoLnJvdXRlLnBhdGg7XG4gIHJldHVybiAoXG4gICAgLy8gcGFyYW0gY2hhbmdlIGZvciB0aGlzIG1hdGNoLCAvdXNlcnMvMTIzIC0+IC91c2Vycy80NTZcbiAgICBjdXJyZW50TWF0Y2gucGF0aG5hbWUgIT09IG1hdGNoLnBhdGhuYW1lIHx8XG4gICAgLy8gc3BsYXQgcGFyYW0gY2hhbmdlZCwgd2hpY2ggaXMgbm90IHByZXNlbnQgaW4gbWF0Y2gucGF0aFxuICAgIC8vIGUuZy4gL2ZpbGVzL2ltYWdlcy9hdmF0YXIuanBnIC0+IGZpbGVzL2ZpbmFuY2VzLnhsc1xuICAgIGN1cnJlbnRQYXRoICE9IG51bGwgJiYgY3VycmVudFBhdGguZW5kc1dpdGgoXCIqXCIpICYmIGN1cnJlbnRNYXRjaC5wYXJhbXNbXCIqXCJdICE9PSBtYXRjaC5wYXJhbXNbXCIqXCJdXG4gICk7XG59XG5mdW5jdGlvbiBzaG91bGRSZXZhbGlkYXRlTG9hZGVyKGxvYWRlck1hdGNoLCBhcmcpIHtcbiAgaWYgKGxvYWRlck1hdGNoLnJvdXRlLnNob3VsZFJldmFsaWRhdGUpIHtcbiAgICBsZXQgcm91dGVDaG9pY2UgPSBsb2FkZXJNYXRjaC5yb3V0ZS5zaG91bGRSZXZhbGlkYXRlKGFyZyk7XG4gICAgaWYgKHR5cGVvZiByb3V0ZUNob2ljZSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJldHVybiByb3V0ZUNob2ljZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFyZy5kZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZTtcbn1cbi8qKlxuICogRXhlY3V0ZSByb3V0ZS5sYXp5KCkgbWV0aG9kcyB0byBsYXppbHkgbG9hZCByb3V0ZSBtb2R1bGVzIChsb2FkZXIsIGFjdGlvbixcbiAqIHNob3VsZFJldmFsaWRhdGUpIGFuZCB1cGRhdGUgdGhlIHJvdXRlTWFuaWZlc3QgaW4gcGxhY2Ugd2hpY2ggc2hhcmVzIG9iamVjdHNcbiAqIHdpdGggZGF0YVJvdXRlcyBzbyB0aG9zZSBnZXQgdXBkYXRlZCBhcyB3ZWxsLlxuICovXG5hc3luYyBmdW5jdGlvbiBsb2FkTGF6eVJvdXRlTW9kdWxlKHJvdXRlLCBtYXBSb3V0ZVByb3BlcnRpZXMsIG1hbmlmZXN0KSB7XG4gIGlmICghcm91dGUubGF6eSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbGF6eVJvdXRlID0gYXdhaXQgcm91dGUubGF6eSgpO1xuICAvLyBJZiB0aGUgbGF6eSByb3V0ZSBmdW5jdGlvbiB3YXMgZXhlY3V0ZWQgYW5kIHJlbW92ZWQgYnkgYW5vdGhlciBwYXJhbGxlbFxuICAvLyBjYWxsIHRoZW4gd2UgY2FuIHJldHVybiAtIGZpcnN0IGxhenkoKSB0byBmaW5pc2ggd2lucyBiZWNhdXNlIHRoZSByZXR1cm5cbiAgLy8gdmFsdWUgb2YgbGF6eSBpcyBleHBlY3RlZCB0byBiZSBzdGF0aWNcbiAgaWYgKCFyb3V0ZS5sYXp5KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCByb3V0ZVRvVXBkYXRlID0gbWFuaWZlc3Rbcm91dGUuaWRdO1xuICBpbnZhcmlhbnQocm91dGVUb1VwZGF0ZSwgXCJObyByb3V0ZSBmb3VuZCBpbiBtYW5pZmVzdFwiKTtcbiAgLy8gVXBkYXRlIHRoZSByb3V0ZSBpbiBwbGFjZS4gIFRoaXMgc2hvdWxkIGJlIHNhZmUgYmVjYXVzZSB0aGVyZSdzIG5vIHdheVxuICAvLyB3ZSBjb3VsZCB5ZXQgYmUgc2l0dGluZyBvbiB0aGlzIHJvdXRlIGFzIHdlIGNhbid0IGdldCB0aGVyZSB3aXRob3V0XG4gIC8vIHJlc29sdmluZyBsYXp5KCkgZmlyc3QuXG4gIC8vXG4gIC8vIFRoaXMgaXMgZGlmZmVyZW50IHRoYW4gdGhlIEhNUiBcInVwZGF0ZVwiIHVzZS1jYXNlIHdoZXJlIHdlIG1heSBhY3RpdmVseSBiZVxuICAvLyBvbiB0aGUgcm91dGUgYmVpbmcgdXBkYXRlZC4gIFRoZSBtYWluIGNvbmNlcm4gYm9pbHMgZG93biB0byBcImRvZXMgdGhpc1xuICAvLyBtdXRhdGlvbiBhZmZlY3QgYW55IG9uZ29pbmcgbmF2aWdhdGlvbnMgb3IgYW55IGN1cnJlbnQgc3RhdGUubWF0Y2hlc1xuICAvLyB2YWx1ZXM/XCIuICBJZiBub3QsIGl0IHNob3VsZCBiZSBzYWZlIHRvIHVwZGF0ZSBpbiBwbGFjZS5cbiAgbGV0IHJvdXRlVXBkYXRlcyA9IHt9O1xuICBmb3IgKGxldCBsYXp5Um91dGVQcm9wZXJ0eSBpbiBsYXp5Um91dGUpIHtcbiAgICBsZXQgc3RhdGljUm91dGVWYWx1ZSA9IHJvdXRlVG9VcGRhdGVbbGF6eVJvdXRlUHJvcGVydHldO1xuICAgIGxldCBpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQgPSBzdGF0aWNSb3V0ZVZhbHVlICE9PSB1bmRlZmluZWQgJiZcbiAgICAvLyBUaGlzIHByb3BlcnR5IGlzbid0IHN0YXRpYyBzaW5jZSBpdCBzaG91bGQgYWx3YXlzIGJlIHVwZGF0ZWQgYmFzZWRcbiAgICAvLyBvbiB0aGUgcm91dGUgdXBkYXRlc1xuICAgIGxhenlSb3V0ZVByb3BlcnR5ICE9PSBcImhhc0Vycm9yQm91bmRhcnlcIjtcbiAgICB3YXJuaW5nKCFpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQsIFwiUm91dGUgXFxcIlwiICsgcm91dGVUb1VwZGF0ZS5pZCArIFwiXFxcIiBoYXMgYSBzdGF0aWMgcHJvcGVydHkgXFxcIlwiICsgbGF6eVJvdXRlUHJvcGVydHkgKyBcIlxcXCIgXCIgKyBcImRlZmluZWQgYnV0IGl0cyBsYXp5IGZ1bmN0aW9uIGlzIGFsc28gcmV0dXJuaW5nIGEgdmFsdWUgZm9yIHRoaXMgcHJvcGVydHkuIFwiICsgKFwiVGhlIGxhenkgcm91dGUgcHJvcGVydHkgXFxcIlwiICsgbGF6eVJvdXRlUHJvcGVydHkgKyBcIlxcXCIgd2lsbCBiZSBpZ25vcmVkLlwiKSk7XG4gICAgaWYgKCFpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQgJiYgIWltbXV0YWJsZVJvdXRlS2V5cy5oYXMobGF6eVJvdXRlUHJvcGVydHkpKSB7XG4gICAgICByb3V0ZVVwZGF0ZXNbbGF6eVJvdXRlUHJvcGVydHldID0gbGF6eVJvdXRlW2xhenlSb3V0ZVByb3BlcnR5XTtcbiAgICB9XG4gIH1cbiAgLy8gTXV0YXRlIHRoZSByb3V0ZSB3aXRoIHRoZSBwcm92aWRlZCB1cGRhdGVzLiAgRG8gdGhpcyBmaXJzdCBzbyB3ZSBwYXNzXG4gIC8vIHRoZSB1cGRhdGVkIHZlcnNpb24gdG8gbWFwUm91dGVQcm9wZXJ0aWVzXG4gIE9iamVjdC5hc3NpZ24ocm91dGVUb1VwZGF0ZSwgcm91dGVVcGRhdGVzKTtcbiAgLy8gTXV0YXRlIHRoZSBgaGFzRXJyb3JCb3VuZGFyeWAgcHJvcGVydHkgb24gdGhlIHJvdXRlIGJhc2VkIG9uIHRoZSByb3V0ZVxuICAvLyB1cGRhdGVzIGFuZCByZW1vdmUgdGhlIGBsYXp5YCBmdW5jdGlvbiBzbyB3ZSBkb24ndCByZXNvbHZlIHRoZSBsYXp5XG4gIC8vIHJvdXRlIGFnYWluLlxuICBPYmplY3QuYXNzaWduKHJvdXRlVG9VcGRhdGUsIF9leHRlbmRzKHt9LCBtYXBSb3V0ZVByb3BlcnRpZXMocm91dGVUb1VwZGF0ZSksIHtcbiAgICBsYXp5OiB1bmRlZmluZWRcbiAgfSkpO1xufVxuYXN5bmMgZnVuY3Rpb24gY2FsbExvYWRlck9yQWN0aW9uKHR5cGUsIHJlcXVlc3QsIG1hdGNoLCBtYXRjaGVzLCBtYW5pZmVzdCwgbWFwUm91dGVQcm9wZXJ0aWVzLCBiYXNlbmFtZSwgb3B0cykge1xuICBpZiAob3B0cyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIGxldCByZXN1bHRUeXBlO1xuICBsZXQgcmVzdWx0O1xuICBsZXQgb25SZWplY3Q7XG4gIGxldCBydW5IYW5kbGVyID0gaGFuZGxlciA9PiB7XG4gICAgLy8gU2V0dXAgYSBwcm9taXNlIHdlIGNhbiByYWNlIGFnYWluc3Qgc28gdGhhdCBhYm9ydCBzaWduYWxzIHNob3J0IGNpcmN1aXRcbiAgICBsZXQgcmVqZWN0O1xuICAgIGxldCBhYm9ydFByb21pc2UgPSBuZXcgUHJvbWlzZSgoXywgcikgPT4gcmVqZWN0ID0gcik7XG4gICAgb25SZWplY3QgPSAoKSA9PiByZWplY3QoKTtcbiAgICByZXF1ZXN0LnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgb25SZWplY3QpO1xuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW2hhbmRsZXIoe1xuICAgICAgcmVxdWVzdCxcbiAgICAgIHBhcmFtczogbWF0Y2gucGFyYW1zLFxuICAgICAgY29udGV4dDogb3B0cy5yZXF1ZXN0Q29udGV4dFxuICAgIH0pLCBhYm9ydFByb21pc2VdKTtcbiAgfTtcbiAgdHJ5IHtcbiAgICBsZXQgaGFuZGxlciA9IG1hdGNoLnJvdXRlW3R5cGVdO1xuICAgIGlmIChtYXRjaC5yb3V0ZS5sYXp5KSB7XG4gICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICAvLyBSdW4gc3RhdGljYWxseSBkZWZpbmVkIGhhbmRsZXIgaW4gcGFyYWxsZWwgd2l0aCBsYXp5KClcbiAgICAgICAgbGV0IGhhbmRsZXJFcnJvcjtcbiAgICAgICAgbGV0IHZhbHVlcyA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgLy8gSWYgdGhlIGhhbmRsZXIgdGhyb3dzLCBkb24ndCBsZXQgaXQgaW1tZWRpYXRlbHkgYnViYmxlIG91dCxcbiAgICAgICAgLy8gc2luY2Ugd2UgbmVlZCB0byBsZXQgdGhlIGxhenkoKSBleGVjdXRpb24gZmluaXNoIHNvIHdlIGtub3cgaWYgdGhpc1xuICAgICAgICAvLyByb3V0ZSBoYXMgYSBib3VuZGFyeSB0aGF0IGNhbiBoYW5kbGUgdGhlIGVycm9yXG4gICAgICAgIHJ1bkhhbmRsZXIoaGFuZGxlcikuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgaGFuZGxlckVycm9yID0gZTtcbiAgICAgICAgfSksIGxvYWRMYXp5Um91dGVNb2R1bGUobWF0Y2gucm91dGUsIG1hcFJvdXRlUHJvcGVydGllcywgbWFuaWZlc3QpXSk7XG4gICAgICAgIGlmIChoYW5kbGVyRXJyb3IpIHtcbiAgICAgICAgICB0aHJvdyBoYW5kbGVyRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdmFsdWVzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTG9hZCBsYXp5IHJvdXRlIG1vZHVsZSwgdGhlbiBydW4gYW55IHJldHVybmVkIGhhbmRsZXJcbiAgICAgICAgYXdhaXQgbG9hZExhenlSb3V0ZU1vZHVsZShtYXRjaC5yb3V0ZSwgbWFwUm91dGVQcm9wZXJ0aWVzLCBtYW5pZmVzdCk7XG4gICAgICAgIGhhbmRsZXIgPSBtYXRjaC5yb3V0ZVt0eXBlXTtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAvLyBIYW5kbGVyIHN0aWxsIHJ1biBldmVuIGlmIHdlIGdvdCBpbnRlcnJ1cHRlZCB0byBtYWludGFpbiBjb25zaXN0ZW5jeVxuICAgICAgICAgIC8vIHdpdGggdW4tYWJvcnRhYmxlIGJlaGF2aW9yIG9mIGhhbmRsZXIgZXhlY3V0aW9uIG9uIG5vbi1sYXp5IG9yXG4gICAgICAgICAgLy8gcHJldmlvdXNseS1sYXp5LWxvYWRlZCByb3V0ZXNcbiAgICAgICAgICByZXN1bHQgPSBhd2FpdCBydW5IYW5kbGVyKGhhbmRsZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiYWN0aW9uXCIpIHtcbiAgICAgICAgICBsZXQgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgICAgbGV0IHBhdGhuYW1lID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgICAgICB0aHJvdyBnZXRJbnRlcm5hbFJvdXRlckVycm9yKDQwNSwge1xuICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICAgIHBhdGhuYW1lLFxuICAgICAgICAgICAgcm91dGVJZDogbWF0Y2gucm91dGUuaWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBsYXp5KCkgcm91dGUgaGFzIG5vIGxvYWRlciB0byBydW4uICBTaG9ydCBjaXJjdWl0IGhlcmUgc28gd2UgZG9uJ3RcbiAgICAgICAgICAvLyBoaXQgdGhlIGludmFyaWFudCBiZWxvdyB0aGF0IGVycm9ycyBvbiByZXR1cm5pbmcgdW5kZWZpbmVkLlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgICAgICAgICBkYXRhOiB1bmRlZmluZWRcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaGFuZGxlcikge1xuICAgICAgbGV0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuICAgICAgbGV0IHBhdGhuYW1lID0gdXJsLnBhdGhuYW1lICsgdXJsLnNlYXJjaDtcbiAgICAgIHRocm93IGdldEludGVybmFsUm91dGVyRXJyb3IoNDA0LCB7XG4gICAgICAgIHBhdGhuYW1lXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gYXdhaXQgcnVuSGFuZGxlcihoYW5kbGVyKTtcbiAgICB9XG4gICAgaW52YXJpYW50KHJlc3VsdCAhPT0gdW5kZWZpbmVkLCBcIllvdSBkZWZpbmVkIFwiICsgKHR5cGUgPT09IFwiYWN0aW9uXCIgPyBcImFuIGFjdGlvblwiIDogXCJhIGxvYWRlclwiKSArIFwiIGZvciByb3V0ZSBcIiArIChcIlxcXCJcIiArIG1hdGNoLnJvdXRlLmlkICsgXCJcXFwiIGJ1dCBkaWRuJ3QgcmV0dXJuIGFueXRoaW5nIGZyb20geW91ciBgXCIgKyB0eXBlICsgXCJgIFwiKSArIFwiZnVuY3Rpb24uIFBsZWFzZSByZXR1cm4gYSB2YWx1ZSBvciBgbnVsbGAuXCIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVzdWx0VHlwZSA9IFJlc3VsdFR5cGUuZXJyb3I7XG4gICAgcmVzdWx0ID0gZTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAob25SZWplY3QpIHtcbiAgICAgIHJlcXVlc3Quc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvblJlamVjdCk7XG4gICAgfVxuICB9XG4gIGlmIChpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICBsZXQgc3RhdHVzID0gcmVzdWx0LnN0YXR1cztcbiAgICAvLyBQcm9jZXNzIHJlZGlyZWN0c1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c0NvZGVzLmhhcyhzdGF0dXMpKSB7XG4gICAgICBsZXQgbG9jYXRpb24gPSByZXN1bHQuaGVhZGVycy5nZXQoXCJMb2NhdGlvblwiKTtcbiAgICAgIGludmFyaWFudChsb2NhdGlvbiwgXCJSZWRpcmVjdHMgcmV0dXJuZWQvdGhyb3duIGZyb20gbG9hZGVycy9hY3Rpb25zIG11c3QgaGF2ZSBhIExvY2F0aW9uIGhlYWRlclwiKTtcbiAgICAgIC8vIFN1cHBvcnQgcmVsYXRpdmUgcm91dGluZyBpbiBpbnRlcm5hbCByZWRpcmVjdHNcbiAgICAgIGlmICghQUJTT0xVVEVfVVJMX1JFR0VYLnRlc3QobG9jYXRpb24pKSB7XG4gICAgICAgIGxvY2F0aW9uID0gbm9ybWFsaXplVG8obmV3IFVSTChyZXF1ZXN0LnVybCksIG1hdGNoZXMuc2xpY2UoMCwgbWF0Y2hlcy5pbmRleE9mKG1hdGNoKSArIDEpLCBiYXNlbmFtZSwgdHJ1ZSwgbG9jYXRpb24pO1xuICAgICAgfSBlbHNlIGlmICghb3B0cy5pc1N0YXRpY1JlcXVlc3QpIHtcbiAgICAgICAgLy8gU3RyaXAgb2ZmIHRoZSBwcm90b2NvbCtvcmlnaW4gZm9yIHNhbWUtb3JpZ2luICsgc2FtZS1iYXNlbmFtZSBhYnNvbHV0ZVxuICAgICAgICAvLyByZWRpcmVjdHMuIElmIHRoaXMgaXMgYSBzdGF0aWMgcmVxdWVzdCwgd2UgY2FuIGxldCBpdCBnbyBiYWNrIHRvIHRoZVxuICAgICAgICAvLyBicm93c2VyIGFzLWlzXG4gICAgICAgIGxldCBjdXJyZW50VXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgICAgIGxldCB1cmwgPSBsb2NhdGlvbi5zdGFydHNXaXRoKFwiLy9cIikgPyBuZXcgVVJMKGN1cnJlbnRVcmwucHJvdG9jb2wgKyBsb2NhdGlvbikgOiBuZXcgVVJMKGxvY2F0aW9uKTtcbiAgICAgICAgbGV0IGlzU2FtZUJhc2VuYW1lID0gc3RyaXBCYXNlbmFtZSh1cmwucGF0aG5hbWUsIGJhc2VuYW1lKSAhPSBudWxsO1xuICAgICAgICBpZiAodXJsLm9yaWdpbiA9PT0gY3VycmVudFVybC5vcmlnaW4gJiYgaXNTYW1lQmFzZW5hbWUpIHtcbiAgICAgICAgICBsb2NhdGlvbiA9IHVybC5wYXRobmFtZSArIHVybC5zZWFyY2ggKyB1cmwuaGFzaDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgcHJvY2VzcyByZWRpcmVjdHMgaW4gdGhlIHJvdXRlciBkdXJpbmcgc3RhdGljIHJlcXVlc3RzIHJlcXVlc3RzLlxuICAgICAgLy8gSW5zdGVhZCwgdGhyb3cgdGhlIFJlc3BvbnNlIGFuZCBsZXQgdGhlIHNlcnZlciBoYW5kbGUgaXQgd2l0aCBhbiBIVFRQXG4gICAgICAvLyByZWRpcmVjdC4gIFdlIGFsc28gdXBkYXRlIHRoZSBMb2NhdGlvbiBoZWFkZXIgaW4gcGxhY2UgaW4gdGhpcyBmbG93IHNvXG4gICAgICAvLyBiYXNlbmFtZSBhbmQgcmVsYXRpdmUgcm91dGluZyBpcyB0YWtlbiBpbnRvIGFjY291bnRcbiAgICAgIGlmIChvcHRzLmlzU3RhdGljUmVxdWVzdCkge1xuICAgICAgICByZXN1bHQuaGVhZGVycy5zZXQoXCJMb2NhdGlvblwiLCBsb2NhdGlvbik7XG4gICAgICAgIHRocm93IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUucmVkaXJlY3QsXG4gICAgICAgIHN0YXR1cyxcbiAgICAgICAgbG9jYXRpb24sXG4gICAgICAgIHJldmFsaWRhdGU6IHJlc3VsdC5oZWFkZXJzLmdldChcIlgtUmVtaXgtUmV2YWxpZGF0ZVwiKSAhPT0gbnVsbCxcbiAgICAgICAgcmVsb2FkRG9jdW1lbnQ6IHJlc3VsdC5oZWFkZXJzLmdldChcIlgtUmVtaXgtUmVsb2FkLURvY3VtZW50XCIpICE9PSBudWxsXG4gICAgICB9O1xuICAgIH1cbiAgICAvLyBGb3IgU1NSIHNpbmdsZS1yb3V0ZSByZXF1ZXN0cywgd2Ugd2FudCB0byBoYW5kIFJlc3BvbnNlcyBiYWNrIGRpcmVjdGx5XG4gICAgLy8gd2l0aG91dCB1bndyYXBwaW5nLiAgV2UgZG8gdGhpcyB3aXRoIHRoZSBRdWVyeVJvdXRlUmVzcG9uc2Ugd3JhcHBlclxuICAgIC8vIGludGVyZmFjZSBzbyB3ZSBjYW4ga25vdyB3aGV0aGVyIGl0IHdhcyByZXR1cm5lZCBvciB0aHJvd25cbiAgICBpZiAob3B0cy5pc1JvdXRlUmVxdWVzdCkge1xuICAgICAgbGV0IHF1ZXJ5Um91dGVSZXNwb25zZSA9IHtcbiAgICAgICAgdHlwZTogcmVzdWx0VHlwZSA9PT0gUmVzdWx0VHlwZS5lcnJvciA/IFJlc3VsdFR5cGUuZXJyb3IgOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgICAgIHJlc3BvbnNlOiByZXN1bHRcbiAgICAgIH07XG4gICAgICB0aHJvdyBxdWVyeVJvdXRlUmVzcG9uc2U7XG4gICAgfVxuICAgIGxldCBkYXRhO1xuICAgIGxldCBjb250ZW50VHlwZSA9IHJlc3VsdC5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKTtcbiAgICAvLyBDaGVjayBiZXR3ZWVuIHdvcmQgYm91bmRhcmllcyBpbnN0ZWFkIG9mIHN0YXJ0c1dpdGgoKSBkdWUgdG8gdGhlIGxhc3RcbiAgICAvLyBwYXJhZ3JhcGggb2YgaHR0cHM6Ly9odHRwd2cub3JnL3NwZWNzL3JmYzkxMTAuaHRtbCNmaWVsZC5jb250ZW50LXR5cGVcbiAgICBpZiAoY29udGVudFR5cGUgJiYgL1xcYmFwcGxpY2F0aW9uXFwvanNvblxcYi8udGVzdChjb250ZW50VHlwZSkpIHtcbiAgICAgIGRhdGEgPSBhd2FpdCByZXN1bHQuanNvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYXRhID0gYXdhaXQgcmVzdWx0LnRleHQoKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdFR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3IpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHJlc3VsdFR5cGUsXG4gICAgICAgIGVycm9yOiBuZXcgRXJyb3JSZXNwb25zZUltcGwoc3RhdHVzLCByZXN1bHQuc3RhdHVzVGV4dCwgZGF0YSksXG4gICAgICAgIGhlYWRlcnM6IHJlc3VsdC5oZWFkZXJzXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogUmVzdWx0VHlwZS5kYXRhLFxuICAgICAgZGF0YSxcbiAgICAgIHN0YXR1c0NvZGU6IHJlc3VsdC5zdGF0dXMsXG4gICAgICBoZWFkZXJzOiByZXN1bHQuaGVhZGVyc1xuICAgIH07XG4gIH1cbiAgaWYgKHJlc3VsdFR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogcmVzdWx0VHlwZSxcbiAgICAgIGVycm9yOiByZXN1bHRcbiAgICB9O1xuICB9XG4gIGlmIChpc0RlZmVycmVkRGF0YShyZXN1bHQpKSB7XG4gICAgdmFyIF9yZXN1bHQkaW5pdCwgX3Jlc3VsdCRpbml0MjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogUmVzdWx0VHlwZS5kZWZlcnJlZCxcbiAgICAgIGRlZmVycmVkRGF0YTogcmVzdWx0LFxuICAgICAgc3RhdHVzQ29kZTogKF9yZXN1bHQkaW5pdCA9IHJlc3VsdC5pbml0KSA9PSBudWxsID8gdm9pZCAwIDogX3Jlc3VsdCRpbml0LnN0YXR1cyxcbiAgICAgIGhlYWRlcnM6ICgoX3Jlc3VsdCRpbml0MiA9IHJlc3VsdC5pbml0KSA9PSBudWxsID8gdm9pZCAwIDogX3Jlc3VsdCRpbml0Mi5oZWFkZXJzKSAmJiBuZXcgSGVhZGVycyhyZXN1bHQuaW5pdC5oZWFkZXJzKVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgZGF0YTogcmVzdWx0XG4gIH07XG59XG4vLyBVdGlsaXR5IG1ldGhvZCBmb3IgY3JlYXRpbmcgdGhlIFJlcXVlc3QgaW5zdGFuY2VzIGZvciBsb2FkZXJzL2FjdGlvbnMgZHVyaW5nXG4vLyBjbGllbnQtc2lkZSBuYXZpZ2F0aW9ucyBhbmQgZmV0Y2hlcy4gIER1cmluZyBTU1Igd2Ugd2lsbCBhbHdheXMgaGF2ZSBhXG4vLyBSZXF1ZXN0IGluc3RhbmNlIGZyb20gdGhlIHN0YXRpYyBoYW5kbGVyIChxdWVyeS9xdWVyeVJvdXRlKVxuZnVuY3Rpb24gY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QoaGlzdG9yeSwgbG9jYXRpb24sIHNpZ25hbCwgc3VibWlzc2lvbikge1xuICBsZXQgdXJsID0gaGlzdG9yeS5jcmVhdGVVUkwoc3RyaXBIYXNoRnJvbVBhdGgobG9jYXRpb24pKS50b1N0cmluZygpO1xuICBsZXQgaW5pdCA9IHtcbiAgICBzaWduYWxcbiAgfTtcbiAgaWYgKHN1Ym1pc3Npb24gJiYgaXNNdXRhdGlvbk1ldGhvZChzdWJtaXNzaW9uLmZvcm1NZXRob2QpKSB7XG4gICAgbGV0IHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtRW5jVHlwZVxuICAgIH0gPSBzdWJtaXNzaW9uO1xuICAgIC8vIERpZG4ndCB0aGluayB3ZSBuZWVkZWQgdGhpcyBidXQgaXQgdHVybnMgb3V0IHVubGlrZSBvdGhlciBtZXRob2RzLCBwYXRjaFxuICAgIC8vIHdvbid0IGJlIHByb3Blcmx5IG5vcm1hbGl6ZWQgdG8gdXBwZXJjYXNlIGFuZCByZXN1bHRzIGluIGEgNDA1IGVycm9yLlxuICAgIC8vIFNlZTogaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtbWV0aG9kXG4gICAgaW5pdC5tZXRob2QgPSBmb3JtTWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gICAgaWYgKGZvcm1FbmNUeXBlID09PSBcImFwcGxpY2F0aW9uL2pzb25cIikge1xuICAgICAgaW5pdC5oZWFkZXJzID0gbmV3IEhlYWRlcnMoe1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBmb3JtRW5jVHlwZVxuICAgICAgfSk7XG4gICAgICBpbml0LmJvZHkgPSBKU09OLnN0cmluZ2lmeShzdWJtaXNzaW9uLmpzb24pO1xuICAgIH0gZWxzZSBpZiAoZm9ybUVuY1R5cGUgPT09IFwidGV4dC9wbGFpblwiKSB7XG4gICAgICAvLyBDb250ZW50LVR5cGUgaXMgaW5mZXJyZWQgKGh0dHBzOi8vZmV0Y2guc3BlYy53aGF0d2cub3JnLyNkb20tcmVxdWVzdClcbiAgICAgIGluaXQuYm9keSA9IHN1Ym1pc3Npb24udGV4dDtcbiAgICB9IGVsc2UgaWYgKGZvcm1FbmNUeXBlID09PSBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICYmIHN1Ym1pc3Npb24uZm9ybURhdGEpIHtcbiAgICAgIC8vIENvbnRlbnQtVHlwZSBpcyBpbmZlcnJlZCAoaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0KVxuICAgICAgaW5pdC5ib2R5ID0gY29udmVydEZvcm1EYXRhVG9TZWFyY2hQYXJhbXMoc3VibWlzc2lvbi5mb3JtRGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvbnRlbnQtVHlwZSBpcyBpbmZlcnJlZCAoaHR0cHM6Ly9mZXRjaC5zcGVjLndoYXR3Zy5vcmcvI2RvbS1yZXF1ZXN0KVxuICAgICAgaW5pdC5ib2R5ID0gc3VibWlzc2lvbi5mb3JtRGF0YTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KHVybCwgaW5pdCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyhmb3JtRGF0YSkge1xuICBsZXQgc2VhcmNoUGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgZm9ybURhdGEuZW50cmllcygpKSB7XG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybS1jb250cm9sLWluZnJhc3RydWN0dXJlLmh0bWwjY29udmVydGluZy1hbi1lbnRyeS1saXN0LXRvLWEtbGlzdC1vZi1uYW1lLXZhbHVlLXBhaXJzXG4gICAgc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlIDogdmFsdWUubmFtZSk7XG4gIH1cbiAgcmV0dXJuIHNlYXJjaFBhcmFtcztcbn1cbmZ1bmN0aW9uIGNvbnZlcnRTZWFyY2hQYXJhbXNUb0Zvcm1EYXRhKHNlYXJjaFBhcmFtcykge1xuICBsZXQgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgZm9yIChsZXQgW2tleSwgdmFsdWVdIG9mIHNlYXJjaFBhcmFtcy5lbnRyaWVzKCkpIHtcbiAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZvcm1EYXRhO1xufVxuZnVuY3Rpb24gcHJvY2Vzc1JvdXRlTG9hZGVyRGF0YShtYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCByZXN1bHRzLCBwZW5kaW5nRXJyb3IsIGFjdGl2ZURlZmVycmVkcykge1xuICAvLyBGaWxsIGluIGxvYWRlckRhdGEvZXJyb3JzIGZyb20gb3VyIGxvYWRlcnNcbiAgbGV0IGxvYWRlckRhdGEgPSB7fTtcbiAgbGV0IGVycm9ycyA9IG51bGw7XG4gIGxldCBzdGF0dXNDb2RlO1xuICBsZXQgZm91bmRFcnJvciA9IGZhbHNlO1xuICBsZXQgbG9hZGVySGVhZGVycyA9IHt9O1xuICAvLyBQcm9jZXNzIGxvYWRlciByZXN1bHRzIGludG8gc3RhdGUubG9hZGVyRGF0YS9zdGF0ZS5lcnJvcnNcbiAgcmVzdWx0cy5mb3JFYWNoKChyZXN1bHQsIGluZGV4KSA9PiB7XG4gICAgbGV0IGlkID0gbWF0Y2hlc1RvTG9hZFtpbmRleF0ucm91dGUuaWQ7XG4gICAgaW52YXJpYW50KCFpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCksIFwiQ2Fubm90IGhhbmRsZSByZWRpcmVjdCByZXN1bHRzIGluIHByb2Nlc3NMb2FkZXJEYXRhXCIpO1xuICAgIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIExvb2sgdXB3YXJkcyBmcm9tIHRoZSBtYXRjaGVkIHJvdXRlIGZvciB0aGUgY2xvc2VzdCBhbmNlc3RvclxuICAgICAgLy8gZXJyb3IgYm91bmRhcnksIGRlZmF1bHRpbmcgdG8gdGhlIHJvb3QgbWF0Y2hcbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCBpZCk7XG4gICAgICBsZXQgZXJyb3IgPSByZXN1bHQuZXJyb3I7XG4gICAgICAvLyBJZiB3ZSBoYXZlIGEgcGVuZGluZyBhY3Rpb24gZXJyb3IsIHdlIHJlcG9ydCBpdCBhdCB0aGUgaGlnaGVzdC1yb3V0ZVxuICAgICAgLy8gdGhhdCB0aHJvd3MgYSBsb2FkZXIgZXJyb3IsIGFuZCB0aGVuIGNsZWFyIGl0IG91dCB0byBpbmRpY2F0ZSB0aGF0XG4gICAgICAvLyBpdCB3YXMgY29uc3VtZWRcbiAgICAgIGlmIChwZW5kaW5nRXJyb3IpIHtcbiAgICAgICAgZXJyb3IgPSBPYmplY3QudmFsdWVzKHBlbmRpbmdFcnJvcilbMF07XG4gICAgICAgIHBlbmRpbmdFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGVycm9ycyA9IGVycm9ycyB8fCB7fTtcbiAgICAgIC8vIFByZWZlciBoaWdoZXIgZXJyb3IgdmFsdWVzIGlmIGxvd2VyIGVycm9ycyBidWJibGUgdG8gdGhlIHNhbWUgYm91bmRhcnlcbiAgICAgIGlmIChlcnJvcnNbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF0gPT0gbnVsbCkge1xuICAgICAgICBlcnJvcnNbYm91bmRhcnlNYXRjaC5yb3V0ZS5pZF0gPSBlcnJvcjtcbiAgICAgIH1cbiAgICAgIC8vIENsZWFyIG91ciBhbnkgcHJpb3IgbG9hZGVyRGF0YSBmb3IgdGhlIHRocm93aW5nIHJvdXRlXG4gICAgICBsb2FkZXJEYXRhW2lkXSA9IHVuZGVmaW5lZDtcbiAgICAgIC8vIE9uY2Ugd2UgZmluZCBvdXIgZmlyc3QgKGhpZ2hlc3QpIGVycm9yLCB3ZSBzZXQgdGhlIHN0YXR1cyBjb2RlIGFuZFxuICAgICAgLy8gcHJldmVudCBkZWVwZXIgc3RhdHVzIGNvZGVzIGZyb20gb3ZlcnJpZGluZ1xuICAgICAgaWYgKCFmb3VuZEVycm9yKSB7XG4gICAgICAgIGZvdW5kRXJyb3IgPSB0cnVlO1xuICAgICAgICBzdGF0dXNDb2RlID0gaXNSb3V0ZUVycm9yUmVzcG9uc2UocmVzdWx0LmVycm9yKSA/IHJlc3VsdC5lcnJvci5zdGF0dXMgOiA1MDA7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0LmhlYWRlcnMpIHtcbiAgICAgICAgbG9hZGVySGVhZGVyc1tpZF0gPSByZXN1bHQuaGVhZGVycztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzRGVmZXJyZWRSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICBhY3RpdmVEZWZlcnJlZHMuc2V0KGlkLCByZXN1bHQuZGVmZXJyZWREYXRhKTtcbiAgICAgICAgbG9hZGVyRGF0YVtpZF0gPSByZXN1bHQuZGVmZXJyZWREYXRhLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2FkZXJEYXRhW2lkXSA9IHJlc3VsdC5kYXRhO1xuICAgICAgfVxuICAgICAgLy8gRXJyb3Igc3RhdHVzIGNvZGVzIGFsd2F5cyBvdmVycmlkZSBzdWNjZXNzIHN0YXR1cyBjb2RlcywgYnV0IGlmIGFsbFxuICAgICAgLy8gbG9hZGVycyBhcmUgc3VjY2Vzc2Z1bCB3ZSB0YWtlIHRoZSBkZWVwZXN0IHN0YXR1cyBjb2RlLlxuICAgICAgaWYgKHJlc3VsdC5zdGF0dXNDb2RlICE9IG51bGwgJiYgcmVzdWx0LnN0YXR1c0NvZGUgIT09IDIwMCAmJiAhZm91bmRFcnJvcikge1xuICAgICAgICBzdGF0dXNDb2RlID0gcmVzdWx0LnN0YXR1c0NvZGU7XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0LmhlYWRlcnMpIHtcbiAgICAgICAgbG9hZGVySGVhZGVyc1tpZF0gPSByZXN1bHQuaGVhZGVycztcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICAvLyBJZiB3ZSBkaWRuJ3QgY29uc3VtZSB0aGUgcGVuZGluZyBhY3Rpb24gZXJyb3IgKGkuZS4sIGFsbCBsb2FkZXJzXG4gIC8vIHJlc29sdmVkKSwgdGhlbiBjb25zdW1lIGl0IGhlcmUuICBBbHNvIGNsZWFyIG91dCBhbnkgbG9hZGVyRGF0YSBmb3IgdGhlXG4gIC8vIHRocm93aW5nIHJvdXRlXG4gIGlmIChwZW5kaW5nRXJyb3IpIHtcbiAgICBlcnJvcnMgPSBwZW5kaW5nRXJyb3I7XG4gICAgbG9hZGVyRGF0YVtPYmplY3Qua2V5cyhwZW5kaW5nRXJyb3IpWzBdXSA9IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGxvYWRlckRhdGEsXG4gICAgZXJyb3JzLFxuICAgIHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUgfHwgMjAwLFxuICAgIGxvYWRlckhlYWRlcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NMb2FkZXJEYXRhKHN0YXRlLCBtYXRjaGVzLCBtYXRjaGVzVG9Mb2FkLCByZXN1bHRzLCBwZW5kaW5nRXJyb3IsIHJldmFsaWRhdGluZ0ZldGNoZXJzLCBmZXRjaGVyUmVzdWx0cywgYWN0aXZlRGVmZXJyZWRzKSB7XG4gIGxldCB7XG4gICAgbG9hZGVyRGF0YSxcbiAgICBlcnJvcnNcbiAgfSA9IHByb2Nlc3NSb3V0ZUxvYWRlckRhdGEobWF0Y2hlcywgbWF0Y2hlc1RvTG9hZCwgcmVzdWx0cywgcGVuZGluZ0Vycm9yLCBhY3RpdmVEZWZlcnJlZHMpO1xuICAvLyBQcm9jZXNzIHJlc3VsdHMgZnJvbSBvdXIgcmV2YWxpZGF0aW5nIGZldGNoZXJzXG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCByZXZhbGlkYXRpbmdGZXRjaGVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBsZXQge1xuICAgICAga2V5LFxuICAgICAgbWF0Y2gsXG4gICAgICBjb250cm9sbGVyXG4gICAgfSA9IHJldmFsaWRhdGluZ0ZldGNoZXJzW2luZGV4XTtcbiAgICBpbnZhcmlhbnQoZmV0Y2hlclJlc3VsdHMgIT09IHVuZGVmaW5lZCAmJiBmZXRjaGVyUmVzdWx0c1tpbmRleF0gIT09IHVuZGVmaW5lZCwgXCJEaWQgbm90IGZpbmQgY29ycmVzcG9uZGluZyBmZXRjaGVyIHJlc3VsdFwiKTtcbiAgICBsZXQgcmVzdWx0ID0gZmV0Y2hlclJlc3VsdHNbaW5kZXhdO1xuICAgIC8vIFByb2Nlc3MgZmV0Y2hlciBub24tcmVkaXJlY3QgZXJyb3JzXG4gICAgaWYgKGNvbnRyb2xsZXIgJiYgY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgLy8gTm90aGluZyB0byBkbyBmb3IgYWJvcnRlZCBmZXRjaGVyc1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChpc0Vycm9yUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIGxldCBib3VuZGFyeU1hdGNoID0gZmluZE5lYXJlc3RCb3VuZGFyeShzdGF0ZS5tYXRjaGVzLCBtYXRjaCA9PSBudWxsID8gdm9pZCAwIDogbWF0Y2gucm91dGUuaWQpO1xuICAgICAgaWYgKCEoZXJyb3JzICYmIGVycm9yc1tib3VuZGFyeU1hdGNoLnJvdXRlLmlkXSkpIHtcbiAgICAgICAgZXJyb3JzID0gX2V4dGVuZHMoe30sIGVycm9ycywge1xuICAgICAgICAgIFtib3VuZGFyeU1hdGNoLnJvdXRlLmlkXTogcmVzdWx0LmVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgc3RhdGUuZmV0Y2hlcnMuZGVsZXRlKGtleSk7XG4gICAgfSBlbHNlIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIC8vIFNob3VsZCBuZXZlciBnZXQgaGVyZSwgcmVkaXJlY3RzIHNob3VsZCBnZXQgcHJvY2Vzc2VkIGFib3ZlLCBidXQgd2VcbiAgICAgIC8vIGtlZXAgdGhpcyB0byB0eXBlIG5hcnJvdyB0byBhIHN1Y2Nlc3MgcmVzdWx0IGluIHRoZSBlbHNlXG4gICAgICBpbnZhcmlhbnQoZmFsc2UsIFwiVW5oYW5kbGVkIGZldGNoZXIgcmV2YWxpZGF0aW9uIHJlZGlyZWN0XCIpO1xuICAgIH0gZWxzZSBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAvLyBTaG91bGQgbmV2ZXIgZ2V0IGhlcmUsIGRlZmVycmVkIGRhdGEgc2hvdWxkIGJlIGF3YWl0ZWQgZm9yIGZldGNoZXJzXG4gICAgICAvLyBpbiByZXNvbHZlRGVmZXJyZWRSZXN1bHRzXG4gICAgICBpbnZhcmlhbnQoZmFsc2UsIFwiVW5oYW5kbGVkIGZldGNoZXIgZGVmZXJyZWQgZGF0YVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRvbmVGZXRjaGVyID0gZ2V0RG9uZUZldGNoZXIocmVzdWx0LmRhdGEpO1xuICAgICAgc3RhdGUuZmV0Y2hlcnMuc2V0KGtleSwgZG9uZUZldGNoZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIGxvYWRlckRhdGEsXG4gICAgZXJyb3JzXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZUxvYWRlckRhdGEobG9hZGVyRGF0YSwgbmV3TG9hZGVyRGF0YSwgbWF0Y2hlcywgZXJyb3JzKSB7XG4gIGxldCBtZXJnZWRMb2FkZXJEYXRhID0gX2V4dGVuZHMoe30sIG5ld0xvYWRlckRhdGEpO1xuICBmb3IgKGxldCBtYXRjaCBvZiBtYXRjaGVzKSB7XG4gICAgbGV0IGlkID0gbWF0Y2gucm91dGUuaWQ7XG4gICAgaWYgKG5ld0xvYWRlckRhdGEuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICBpZiAobmV3TG9hZGVyRGF0YVtpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtZXJnZWRMb2FkZXJEYXRhW2lkXSA9IG5ld0xvYWRlckRhdGFbaWRdO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobG9hZGVyRGF0YVtpZF0gIT09IHVuZGVmaW5lZCAmJiBtYXRjaC5yb3V0ZS5sb2FkZXIpIHtcbiAgICAgIC8vIFByZXNlcnZlIGV4aXN0aW5nIGtleXMgbm90IGluY2x1ZGVkIGluIG5ld0xvYWRlckRhdGEgYW5kIHdoZXJlIGEgbG9hZGVyXG4gICAgICAvLyB3YXNuJ3QgcmVtb3ZlZCBieSBITVJcbiAgICAgIG1lcmdlZExvYWRlckRhdGFbaWRdID0gbG9hZGVyRGF0YVtpZF07XG4gICAgfVxuICAgIGlmIChlcnJvcnMgJiYgZXJyb3JzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgLy8gRG9uJ3Qga2VlcCBhbnkgbG9hZGVyIGRhdGEgYmVsb3cgdGhlIGJvdW5kYXJ5XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lcmdlZExvYWRlckRhdGE7XG59XG4vLyBGaW5kIHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5LCBsb29raW5nIHVwd2FyZHMgZnJvbSB0aGUgbGVhZiByb3V0ZSAob3IgdGhlXG4vLyByb3V0ZSBzcGVjaWZpZWQgYnkgcm91dGVJZCkgZm9yIHRoZSBjbG9zZXN0IGFuY2VzdG9yIGVycm9yIGJvdW5kYXJ5LFxuLy8gZGVmYXVsdGluZyB0byB0aGUgcm9vdCBtYXRjaFxuZnVuY3Rpb24gZmluZE5lYXJlc3RCb3VuZGFyeShtYXRjaGVzLCByb3V0ZUlkKSB7XG4gIGxldCBlbGlnaWJsZU1hdGNoZXMgPSByb3V0ZUlkID8gbWF0Y2hlcy5zbGljZSgwLCBtYXRjaGVzLmZpbmRJbmRleChtID0+IG0ucm91dGUuaWQgPT09IHJvdXRlSWQpICsgMSkgOiBbLi4ubWF0Y2hlc107XG4gIHJldHVybiBlbGlnaWJsZU1hdGNoZXMucmV2ZXJzZSgpLmZpbmQobSA9PiBtLnJvdXRlLmhhc0Vycm9yQm91bmRhcnkgPT09IHRydWUpIHx8IG1hdGNoZXNbMF07XG59XG5mdW5jdGlvbiBnZXRTaG9ydENpcmN1aXRNYXRjaGVzKHJvdXRlcykge1xuICAvLyBQcmVmZXIgYSByb290IGxheW91dCByb3V0ZSBpZiBwcmVzZW50LCBvdGhlcndpc2Ugc2hpbSBpbiBhIHJvdXRlIG9iamVjdFxuICBsZXQgcm91dGUgPSByb3V0ZXMubGVuZ3RoID09PSAxID8gcm91dGVzWzBdIDogcm91dGVzLmZpbmQociA9PiByLmluZGV4IHx8ICFyLnBhdGggfHwgci5wYXRoID09PSBcIi9cIikgfHwge1xuICAgIGlkOiBcIl9fc2hpbS1lcnJvci1yb3V0ZV9fXCJcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBtYXRjaGVzOiBbe1xuICAgICAgcGFyYW1zOiB7fSxcbiAgICAgIHBhdGhuYW1lOiBcIlwiLFxuICAgICAgcGF0aG5hbWVCYXNlOiBcIlwiLFxuICAgICAgcm91dGVcbiAgICB9XSxcbiAgICByb3V0ZVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0SW50ZXJuYWxSb3V0ZXJFcnJvcihzdGF0dXMsIF90ZW1wNSkge1xuICBsZXQge1xuICAgIHBhdGhuYW1lLFxuICAgIHJvdXRlSWQsXG4gICAgbWV0aG9kLFxuICAgIHR5cGVcbiAgfSA9IF90ZW1wNSA9PT0gdm9pZCAwID8ge30gOiBfdGVtcDU7XG4gIGxldCBzdGF0dXNUZXh0ID0gXCJVbmtub3duIFNlcnZlciBFcnJvclwiO1xuICBsZXQgZXJyb3JNZXNzYWdlID0gXCJVbmtub3duIEByZW1peC1ydW4vcm91dGVyIGVycm9yXCI7XG4gIGlmIChzdGF0dXMgPT09IDQwMCkge1xuICAgIHN0YXR1c1RleHQgPSBcIkJhZCBSZXF1ZXN0XCI7XG4gICAgaWYgKG1ldGhvZCAmJiBwYXRobmFtZSAmJiByb3V0ZUlkKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBcIllvdSBtYWRlIGEgXCIgKyBtZXRob2QgKyBcIiByZXF1ZXN0IHRvIFxcXCJcIiArIHBhdGhuYW1lICsgXCJcXFwiIGJ1dCBcIiArIChcImRpZCBub3QgcHJvdmlkZSBhIGBsb2FkZXJgIGZvciByb3V0ZSBcXFwiXCIgKyByb3V0ZUlkICsgXCJcXFwiLCBcIikgKyBcInNvIHRoZXJlIGlzIG5vIHdheSB0byBoYW5kbGUgdGhlIHJlcXVlc3QuXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImRlZmVyLWFjdGlvblwiKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBcImRlZmVyKCkgaXMgbm90IHN1cHBvcnRlZCBpbiBhY3Rpb25zXCI7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcImludmFsaWQtYm9keVwiKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBcIlVuYWJsZSB0byBlbmNvZGUgc3VibWlzc2lvbiBib2R5XCI7XG4gICAgfVxuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDAzKSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiRm9yYmlkZGVuXCI7XG4gICAgZXJyb3JNZXNzYWdlID0gXCJSb3V0ZSBcXFwiXCIgKyByb3V0ZUlkICsgXCJcXFwiIGRvZXMgbm90IG1hdGNoIFVSTCBcXFwiXCIgKyBwYXRobmFtZSArIFwiXFxcIlwiO1xuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDA0KSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiTm90IEZvdW5kXCI7XG4gICAgZXJyb3JNZXNzYWdlID0gXCJObyByb3V0ZSBtYXRjaGVzIFVSTCBcXFwiXCIgKyBwYXRobmFtZSArIFwiXFxcIlwiO1xuICB9IGVsc2UgaWYgKHN0YXR1cyA9PT0gNDA1KSB7XG4gICAgc3RhdHVzVGV4dCA9IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCI7XG4gICAgaWYgKG1ldGhvZCAmJiBwYXRobmFtZSAmJiByb3V0ZUlkKSB7XG4gICAgICBlcnJvck1lc3NhZ2UgPSBcIllvdSBtYWRlIGEgXCIgKyBtZXRob2QudG9VcHBlckNhc2UoKSArIFwiIHJlcXVlc3QgdG8gXFxcIlwiICsgcGF0aG5hbWUgKyBcIlxcXCIgYnV0IFwiICsgKFwiZGlkIG5vdCBwcm92aWRlIGFuIGBhY3Rpb25gIGZvciByb3V0ZSBcXFwiXCIgKyByb3V0ZUlkICsgXCJcXFwiLCBcIikgKyBcInNvIHRoZXJlIGlzIG5vIHdheSB0byBoYW5kbGUgdGhlIHJlcXVlc3QuXCI7XG4gICAgfSBlbHNlIGlmIChtZXRob2QpIHtcbiAgICAgIGVycm9yTWVzc2FnZSA9IFwiSW52YWxpZCByZXF1ZXN0IG1ldGhvZCBcXFwiXCIgKyBtZXRob2QudG9VcHBlckNhc2UoKSArIFwiXFxcIlwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IEVycm9yUmVzcG9uc2VJbXBsKHN0YXR1cyB8fCA1MDAsIHN0YXR1c1RleHQsIG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpLCB0cnVlKTtcbn1cbi8vIEZpbmQgYW55IHJldHVybmVkIHJlZGlyZWN0IGVycm9ycywgc3RhcnRpbmcgZnJvbSB0aGUgbG93ZXN0IG1hdGNoXG5mdW5jdGlvbiBmaW5kUmVkaXJlY3QocmVzdWx0cykge1xuICBmb3IgKGxldCBpID0gcmVzdWx0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGxldCByZXN1bHQgPSByZXN1bHRzW2ldO1xuICAgIGlmIChpc1JlZGlyZWN0UmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgaWR4OiBpXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc3RyaXBIYXNoRnJvbVBhdGgocGF0aCkge1xuICBsZXQgcGFyc2VkUGF0aCA9IHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiID8gcGFyc2VQYXRoKHBhdGgpIDogcGF0aDtcbiAgcmV0dXJuIGNyZWF0ZVBhdGgoX2V4dGVuZHMoe30sIHBhcnNlZFBhdGgsIHtcbiAgICBoYXNoOiBcIlwiXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGlzSGFzaENoYW5nZU9ubHkoYSwgYikge1xuICBpZiAoYS5wYXRobmFtZSAhPT0gYi5wYXRobmFtZSB8fCBhLnNlYXJjaCAhPT0gYi5zZWFyY2gpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGEuaGFzaCA9PT0gXCJcIikge1xuICAgIC8vIC9wYWdlIC0+IC9wYWdlI2hhc2hcbiAgICByZXR1cm4gYi5oYXNoICE9PSBcIlwiO1xuICB9IGVsc2UgaWYgKGEuaGFzaCA9PT0gYi5oYXNoKSB7XG4gICAgLy8gL3BhZ2UjaGFzaCAtPiAvcGFnZSNoYXNoXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoYi5oYXNoICE9PSBcIlwiKSB7XG4gICAgLy8gL3BhZ2UjaGFzaCAtPiAvcGFnZSNvdGhlclxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIElmIHRoZSBoYXNoIGlzIHJlbW92ZWQgdGhlIGJyb3dzZXIgd2lsbCByZS1wZXJmb3JtIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyXG4gIC8vIC9wYWdlI2hhc2ggLT4gL3BhZ2VcbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdC50eXBlID09PSBSZXN1bHRUeXBlLmRlZmVycmVkO1xufVxuZnVuY3Rpb24gaXNFcnJvclJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHJlc3VsdC50eXBlID09PSBSZXN1bHRUeXBlLmVycm9yO1xufVxuZnVuY3Rpb24gaXNSZWRpcmVjdFJlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIChyZXN1bHQgJiYgcmVzdWx0LnR5cGUpID09PSBSZXN1bHRUeXBlLnJlZGlyZWN0O1xufVxuZnVuY3Rpb24gaXNEZWZlcnJlZERhdGEodmFsdWUpIHtcbiAgbGV0IGRlZmVycmVkID0gdmFsdWU7XG4gIHJldHVybiBkZWZlcnJlZCAmJiB0eXBlb2YgZGVmZXJyZWQgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGRlZmVycmVkLmRhdGEgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGRlZmVycmVkLnN1YnNjcmliZSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBkZWZlcnJlZC5jYW5jZWwgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZGVmZXJyZWQucmVzb2x2ZURhdGEgPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGlzUmVzcG9uc2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnN0YXR1cyA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgdmFsdWUuc3RhdHVzVGV4dCA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgdmFsdWUuaGVhZGVycyA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUuYm9keSAhPT0gXCJ1bmRlZmluZWRcIjtcbn1cbmZ1bmN0aW9uIGlzUmVkaXJlY3RSZXNwb25zZShyZXN1bHQpIHtcbiAgaWYgKCFpc1Jlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGV0IHN0YXR1cyA9IHJlc3VsdC5zdGF0dXM7XG4gIGxldCBsb2NhdGlvbiA9IHJlc3VsdC5oZWFkZXJzLmdldChcIkxvY2F0aW9uXCIpO1xuICByZXR1cm4gc3RhdHVzID49IDMwMCAmJiBzdGF0dXMgPD0gMzk5ICYmIGxvY2F0aW9uICE9IG51bGw7XG59XG5mdW5jdGlvbiBpc1F1ZXJ5Um91dGVSZXNwb25zZShvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBpc1Jlc3BvbnNlKG9iai5yZXNwb25zZSkgJiYgKG9iai50eXBlID09PSBSZXN1bHRUeXBlLmRhdGEgfHwgb2JqLnR5cGUgPT09IFJlc3VsdFR5cGUuZXJyb3IpO1xufVxuZnVuY3Rpb24gaXNWYWxpZE1ldGhvZChtZXRob2QpIHtcbiAgcmV0dXJuIHZhbGlkUmVxdWVzdE1ldGhvZHMuaGFzKG1ldGhvZC50b0xvd2VyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIGlzTXV0YXRpb25NZXRob2QobWV0aG9kKSB7XG4gIHJldHVybiB2YWxpZE11dGF0aW9uTWV0aG9kcy5oYXMobWV0aG9kLnRvTG93ZXJDYXNlKCkpO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZURlZmVycmVkUmVzdWx0cyhjdXJyZW50TWF0Y2hlcywgbWF0Y2hlc1RvTG9hZCwgcmVzdWx0cywgc2lnbmFscywgaXNGZXRjaGVyLCBjdXJyZW50TG9hZGVyRGF0YSkge1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcmVzdWx0cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBsZXQgcmVzdWx0ID0gcmVzdWx0c1tpbmRleF07XG4gICAgbGV0IG1hdGNoID0gbWF0Y2hlc1RvTG9hZFtpbmRleF07XG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIG1hdGNoLCB0aGVuIHdlIGNhbiBoYXZlIGEgZGVmZXJyZWQgcmVzdWx0IHRvIGRvXG4gICAgLy8gYW55dGhpbmcgd2l0aC4gIFRoaXMgaXMgZm9yIHJldmFsaWRhdGluZyBmZXRjaGVycyB3aGVyZSB0aGUgcm91dGUgd2FzXG4gICAgLy8gcmVtb3ZlZCBkdXJpbmcgSE1SXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldCBjdXJyZW50TWF0Y2ggPSBjdXJyZW50TWF0Y2hlcy5maW5kKG0gPT4gbS5yb3V0ZS5pZCA9PT0gbWF0Y2gucm91dGUuaWQpO1xuICAgIGxldCBpc1JldmFsaWRhdGluZ0xvYWRlciA9IGN1cnJlbnRNYXRjaCAhPSBudWxsICYmICFpc05ld1JvdXRlSW5zdGFuY2UoY3VycmVudE1hdGNoLCBtYXRjaCkgJiYgKGN1cnJlbnRMb2FkZXJEYXRhICYmIGN1cnJlbnRMb2FkZXJEYXRhW21hdGNoLnJvdXRlLmlkXSkgIT09IHVuZGVmaW5lZDtcbiAgICBpZiAoaXNEZWZlcnJlZFJlc3VsdChyZXN1bHQpICYmIChpc0ZldGNoZXIgfHwgaXNSZXZhbGlkYXRpbmdMb2FkZXIpKSB7XG4gICAgICAvLyBOb3RlOiB3ZSBkbyBub3QgaGF2ZSB0byB0b3VjaCBhY3RpdmVEZWZlcnJlZHMgaGVyZSBzaW5jZSB3ZSByYWNlIHRoZW1cbiAgICAgIC8vIGFnYWluc3QgdGhlIHNpZ25hbCBpbiByZXNvbHZlRGVmZXJyZWREYXRhIGFuZCB0aGV5J2xsIGdldCBhYm9ydGVkXG4gICAgICAvLyB0aGVyZSBpZiBuZWVkZWRcbiAgICAgIGxldCBzaWduYWwgPSBzaWduYWxzW2luZGV4XTtcbiAgICAgIGludmFyaWFudChzaWduYWwsIFwiRXhwZWN0ZWQgYW4gQWJvcnRTaWduYWwgZm9yIHJldmFsaWRhdGluZyBmZXRjaGVyIGRlZmVycmVkIHJlc3VsdFwiKTtcbiAgICAgIGF3YWl0IHJlc29sdmVEZWZlcnJlZERhdGEocmVzdWx0LCBzaWduYWwsIGlzRmV0Y2hlcikudGhlbihyZXN1bHQgPT4ge1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0c1tpbmRleF0gPSByZXN1bHQgfHwgcmVzdWx0c1tpbmRleF07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZURlZmVycmVkRGF0YShyZXN1bHQsIHNpZ25hbCwgdW53cmFwKSB7XG4gIGlmICh1bndyYXAgPT09IHZvaWQgMCkge1xuICAgIHVud3JhcCA9IGZhbHNlO1xuICB9XG4gIGxldCBhYm9ydGVkID0gYXdhaXQgcmVzdWx0LmRlZmVycmVkRGF0YS5yZXNvbHZlRGF0YShzaWduYWwpO1xuICBpZiAoYWJvcnRlZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodW53cmFwKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFJlc3VsdFR5cGUuZGF0YSxcbiAgICAgICAgZGF0YTogcmVzdWx0LmRlZmVycmVkRGF0YS51bndyYXBwZWREYXRhXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIEhhbmRsZSBhbnkgVHJhY2tlZFByb21pc2UuX2Vycm9yIHZhbHVlcyBlbmNvdW50ZXJlZCB3aGlsZSB1bndyYXBwaW5nXG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBSZXN1bHRUeXBlLmVycm9yLFxuICAgICAgICBlcnJvcjogZVxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBSZXN1bHRUeXBlLmRhdGEsXG4gICAgZGF0YTogcmVzdWx0LmRlZmVycmVkRGF0YS5kYXRhXG4gIH07XG59XG5mdW5jdGlvbiBoYXNOYWtlZEluZGV4UXVlcnkoc2VhcmNoKSB7XG4gIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKHNlYXJjaCkuZ2V0QWxsKFwiaW5kZXhcIikuc29tZSh2ID0+IHYgPT09IFwiXCIpO1xufVxuZnVuY3Rpb24gZ2V0VGFyZ2V0TWF0Y2gobWF0Y2hlcywgbG9jYXRpb24pIHtcbiAgbGV0IHNlYXJjaCA9IHR5cGVvZiBsb2NhdGlvbiA9PT0gXCJzdHJpbmdcIiA/IHBhcnNlUGF0aChsb2NhdGlvbikuc2VhcmNoIDogbG9jYXRpb24uc2VhcmNoO1xuICBpZiAobWF0Y2hlc1ttYXRjaGVzLmxlbmd0aCAtIDFdLnJvdXRlLmluZGV4ICYmIGhhc05ha2VkSW5kZXhRdWVyeShzZWFyY2ggfHwgXCJcIikpIHtcbiAgICAvLyBSZXR1cm4gdGhlIGxlYWYgaW5kZXggcm91dGUgd2hlbiBpbmRleCBpcyBwcmVzZW50XG4gICAgcmV0dXJuIG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgfVxuICAvLyBPdGhlcndpc2UgZ3JhYiB0aGUgZGVlcGVzdCBcInBhdGggY29udHJpYnV0aW5nXCIgbWF0Y2ggKGlnbm9yaW5nIGluZGV4IGFuZFxuICAvLyBwYXRobGVzcyBsYXlvdXQgcm91dGVzKVxuICBsZXQgcGF0aE1hdGNoZXMgPSBnZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcyhtYXRjaGVzKTtcbiAgcmV0dXJuIHBhdGhNYXRjaGVzW3BhdGhNYXRjaGVzLmxlbmd0aCAtIDFdO1xufVxuZnVuY3Rpb24gZ2V0U3VibWlzc2lvbkZyb21OYXZpZ2F0aW9uKG5hdmlnYXRpb24pIHtcbiAgbGV0IHtcbiAgICBmb3JtTWV0aG9kLFxuICAgIGZvcm1BY3Rpb24sXG4gICAgZm9ybUVuY1R5cGUsXG4gICAgdGV4dCxcbiAgICBmb3JtRGF0YSxcbiAgICBqc29uXG4gIH0gPSBuYXZpZ2F0aW9uO1xuICBpZiAoIWZvcm1NZXRob2QgfHwgIWZvcm1BY3Rpb24gfHwgIWZvcm1FbmNUeXBlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0ZXh0ICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhOiB1bmRlZmluZWQsXG4gICAgICBqc29uOiB1bmRlZmluZWQsXG4gICAgICB0ZXh0XG4gICAgfTtcbiAgfSBlbHNlIGlmIChmb3JtRGF0YSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YSxcbiAgICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICAgIHRleHQ6IHVuZGVmaW5lZFxuICAgIH07XG4gIH0gZWxzZSBpZiAoanNvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uLFxuICAgICAgZm9ybUVuY1R5cGUsXG4gICAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgICAganNvbixcbiAgICAgIHRleHQ6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGdldExvYWRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKSB7XG4gIGlmIChzdWJtaXNzaW9uKSB7XG4gICAgbGV0IG5hdmlnYXRpb24gPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBsb2NhdGlvbixcbiAgICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICAgIGZvcm1BY3Rpb246IHN1Ym1pc3Npb24uZm9ybUFjdGlvbixcbiAgICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAgICBqc29uOiBzdWJtaXNzaW9uLmpzb24sXG4gICAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHRcbiAgICB9O1xuICAgIHJldHVybiBuYXZpZ2F0aW9uO1xuICB9IGVsc2Uge1xuICAgIGxldCBuYXZpZ2F0aW9uID0ge1xuICAgICAgc3RhdGU6IFwibG9hZGluZ1wiLFxuICAgICAgbG9jYXRpb24sXG4gICAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICAgIHRleHQ6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgcmV0dXJuIG5hdmlnYXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFN1Ym1pdHRpbmdOYXZpZ2F0aW9uKGxvY2F0aW9uLCBzdWJtaXNzaW9uKSB7XG4gIGxldCBuYXZpZ2F0aW9uID0ge1xuICAgIHN0YXRlOiBcInN1Ym1pdHRpbmdcIixcbiAgICBsb2NhdGlvbixcbiAgICBmb3JtTWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgZm9ybUFjdGlvbjogc3VibWlzc2lvbi5mb3JtQWN0aW9uLFxuICAgIGZvcm1FbmNUeXBlOiBzdWJtaXNzaW9uLmZvcm1FbmNUeXBlLFxuICAgIGZvcm1EYXRhOiBzdWJtaXNzaW9uLmZvcm1EYXRhLFxuICAgIGpzb246IHN1Ym1pc3Npb24uanNvbixcbiAgICB0ZXh0OiBzdWJtaXNzaW9uLnRleHRcbiAgfTtcbiAgcmV0dXJuIG5hdmlnYXRpb247XG59XG5mdW5jdGlvbiBnZXRMb2FkaW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBkYXRhKSB7XG4gIGlmIChzdWJtaXNzaW9uKSB7XG4gICAgbGV0IGZldGNoZXIgPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBmb3JtTWV0aG9kOiBzdWJtaXNzaW9uLmZvcm1NZXRob2QsXG4gICAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24sXG4gICAgICBmb3JtRW5jVHlwZTogc3VibWlzc2lvbi5mb3JtRW5jVHlwZSxcbiAgICAgIGZvcm1EYXRhOiBzdWJtaXNzaW9uLmZvcm1EYXRhLFxuICAgICAganNvbjogc3VibWlzc2lvbi5qc29uLFxuICAgICAgdGV4dDogc3VibWlzc2lvbi50ZXh0LFxuICAgICAgZGF0YVxuICAgIH07XG4gICAgcmV0dXJuIGZldGNoZXI7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGZldGNoZXIgPSB7XG4gICAgICBzdGF0ZTogXCJsb2FkaW5nXCIsXG4gICAgICBmb3JtTWV0aG9kOiB1bmRlZmluZWQsXG4gICAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICBmb3JtRW5jVHlwZTogdW5kZWZpbmVkLFxuICAgICAgZm9ybURhdGE6IHVuZGVmaW5lZCxcbiAgICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICAgIHRleHQ6IHVuZGVmaW5lZCxcbiAgICAgIGRhdGFcbiAgICB9O1xuICAgIHJldHVybiBmZXRjaGVyO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTdWJtaXR0aW5nRmV0Y2hlcihzdWJtaXNzaW9uLCBleGlzdGluZ0ZldGNoZXIpIHtcbiAgbGV0IGZldGNoZXIgPSB7XG4gICAgc3RhdGU6IFwic3VibWl0dGluZ1wiLFxuICAgIGZvcm1NZXRob2Q6IHN1Ym1pc3Npb24uZm9ybU1ldGhvZCxcbiAgICBmb3JtQWN0aW9uOiBzdWJtaXNzaW9uLmZvcm1BY3Rpb24sXG4gICAgZm9ybUVuY1R5cGU6IHN1Ym1pc3Npb24uZm9ybUVuY1R5cGUsXG4gICAgZm9ybURhdGE6IHN1Ym1pc3Npb24uZm9ybURhdGEsXG4gICAganNvbjogc3VibWlzc2lvbi5qc29uLFxuICAgIHRleHQ6IHN1Ym1pc3Npb24udGV4dCxcbiAgICBkYXRhOiBleGlzdGluZ0ZldGNoZXIgPyBleGlzdGluZ0ZldGNoZXIuZGF0YSA6IHVuZGVmaW5lZFxuICB9O1xuICByZXR1cm4gZmV0Y2hlcjtcbn1cbmZ1bmN0aW9uIGdldERvbmVGZXRjaGVyKGRhdGEpIHtcbiAgbGV0IGZldGNoZXIgPSB7XG4gICAgc3RhdGU6IFwiaWRsZVwiLFxuICAgIGZvcm1NZXRob2Q6IHVuZGVmaW5lZCxcbiAgICBmb3JtQWN0aW9uOiB1bmRlZmluZWQsXG4gICAgZm9ybUVuY1R5cGU6IHVuZGVmaW5lZCxcbiAgICBmb3JtRGF0YTogdW5kZWZpbmVkLFxuICAgIGpzb246IHVuZGVmaW5lZCxcbiAgICB0ZXh0OiB1bmRlZmluZWQsXG4gICAgZGF0YVxuICB9O1xuICByZXR1cm4gZmV0Y2hlcjtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVBcHBsaWVkVHJhbnNpdGlvbnMoX3dpbmRvdywgdHJhbnNpdGlvbnMpIHtcbiAgdHJ5IHtcbiAgICBsZXQgc2Vzc2lvblBvc2l0aW9ucyA9IF93aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShUUkFOU0lUSU9OU19TVE9SQUdFX0tFWSk7XG4gICAgaWYgKHNlc3Npb25Qb3NpdGlvbnMpIHtcbiAgICAgIGxldCBqc29uID0gSlNPTi5wYXJzZShzZXNzaW9uUG9zaXRpb25zKTtcbiAgICAgIGZvciAobGV0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhqc29uIHx8IHt9KSkge1xuICAgICAgICBpZiAodiAmJiBBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgdHJhbnNpdGlvbnMuc2V0KGssIG5ldyBTZXQodiB8fCBbXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gbm8tb3AsIHVzZSBkZWZhdWx0IGVtcHR5IG9iamVjdFxuICB9XG59XG5mdW5jdGlvbiBwZXJzaXN0QXBwbGllZFRyYW5zaXRpb25zKF93aW5kb3csIHRyYW5zaXRpb25zKSB7XG4gIGlmICh0cmFuc2l0aW9ucy5zaXplID4gMCkge1xuICAgIGxldCBqc29uID0ge307XG4gICAgZm9yIChsZXQgW2ssIHZdIG9mIHRyYW5zaXRpb25zKSB7XG4gICAgICBqc29uW2tdID0gWy4uLnZdO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgX3dpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFRSQU5TSVRJT05TX1NUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShqc29uKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsIFwiRmFpbGVkIHRvIHNhdmUgYXBwbGllZCB2aWV3IHRyYW5zaXRpb25zIGluIHNlc3Npb25TdG9yYWdlIChcIiArIGVycm9yICsgXCIpLlwiKTtcbiAgICB9XG4gIH1cbn1cbi8vI2VuZHJlZ2lvblxuXG5leHBvcnQgeyBBYm9ydGVkRGVmZXJyZWRFcnJvciwgQWN0aW9uLCBJRExFX0JMT0NLRVIsIElETEVfRkVUQ0hFUiwgSURMRV9OQVZJR0FUSU9OLCBVTlNBRkVfREVGRVJSRURfU1lNQk9MLCBEZWZlcnJlZERhdGEgYXMgVU5TQUZFX0RlZmVycmVkRGF0YSwgRXJyb3JSZXNwb25zZUltcGwgYXMgVU5TQUZFX0Vycm9yUmVzcG9uc2VJbXBsLCBjb252ZXJ0Um91dGVNYXRjaFRvVWlNYXRjaCBhcyBVTlNBRkVfY29udmVydFJvdXRlTWF0Y2hUb1VpTWF0Y2gsIGNvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMgYXMgVU5TQUZFX2NvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMsIGdldFBhdGhDb250cmlidXRpbmdNYXRjaGVzIGFzIFVOU0FGRV9nZXRQYXRoQ29udHJpYnV0aW5nTWF0Y2hlcywgaW52YXJpYW50IGFzIFVOU0FGRV9pbnZhcmlhbnQsIHdhcm5pbmcgYXMgVU5TQUZFX3dhcm5pbmcsIGNyZWF0ZUJyb3dzZXJIaXN0b3J5LCBjcmVhdGVIYXNoSGlzdG9yeSwgY3JlYXRlTWVtb3J5SGlzdG9yeSwgY3JlYXRlUGF0aCwgY3JlYXRlUm91dGVyLCBjcmVhdGVTdGF0aWNIYW5kbGVyLCBkZWZlciwgZ2VuZXJhdGVQYXRoLCBnZXRTdGF0aWNDb250ZXh0RnJvbUVycm9yLCBnZXRUb1BhdGhuYW1lLCBpc0RlZmVycmVkRGF0YSwgaXNSb3V0ZUVycm9yUmVzcG9uc2UsIGpvaW5QYXRocywganNvbiwgbWF0Y2hQYXRoLCBtYXRjaFJvdXRlcywgbm9ybWFsaXplUGF0aG5hbWUsIHBhcnNlUGF0aCwgcmVkaXJlY3QsIHJlZGlyZWN0RG9jdW1lbnQsIHJlc29sdmVQYXRoLCByZXNvbHZlVG8sIHN0cmlwQmFzZW5hbWUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfZXh0ZW5kcyIsIk9iamVjdCIsImFzc2lnbiIsImJpbmQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwia2V5IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJBY3Rpb24iLCJQb3BTdGF0ZUV2ZW50VHlwZSIsImNyZWF0ZU1lbW9yeUhpc3RvcnkiLCJvcHRpb25zIiwiaW5pdGlhbEVudHJpZXMiLCJpbml0aWFsSW5kZXgiLCJ2NUNvbXBhdCIsImVudHJpZXMiLCJtYXAiLCJlbnRyeSIsImluZGV4IiwiY3JlYXRlTWVtb3J5TG9jYXRpb24iLCJzdGF0ZSIsInVuZGVmaW5lZCIsImNsYW1wSW5kZXgiLCJhY3Rpb24iLCJQb3AiLCJsaXN0ZW5lciIsIm4iLCJNYXRoIiwibWluIiwibWF4IiwiZ2V0Q3VycmVudExvY2F0aW9uIiwidG8iLCJsb2NhdGlvbiIsImNyZWF0ZUxvY2F0aW9uIiwicGF0aG5hbWUiLCJ3YXJuaW5nIiwiY2hhckF0IiwiSlNPTiIsInN0cmluZ2lmeSIsImNyZWF0ZUhyZWYiLCJjcmVhdGVQYXRoIiwiaGlzdG9yeSIsImNyZWF0ZVVSTCIsIlVSTCIsImVuY29kZUxvY2F0aW9uIiwicGF0aCIsInBhcnNlUGF0aCIsInNlYXJjaCIsImhhc2giLCJwdXNoIiwiUHVzaCIsIm5leHRMb2NhdGlvbiIsInNwbGljZSIsImRlbHRhIiwicmVwbGFjZSIsIlJlcGxhY2UiLCJnbyIsIm5leHRJbmRleCIsImxpc3RlbiIsImZuIiwiY3JlYXRlQnJvd3Nlckhpc3RvcnkiLCJjcmVhdGVCcm93c2VyTG9jYXRpb24iLCJ3aW5kb3ciLCJnbG9iYWxIaXN0b3J5IiwidXNyIiwiY3JlYXRlQnJvd3NlckhyZWYiLCJnZXRVcmxCYXNlZEhpc3RvcnkiLCJjcmVhdGVIYXNoSGlzdG9yeSIsImNyZWF0ZUhhc2hMb2NhdGlvbiIsInN1YnN0ciIsInN0YXJ0c1dpdGgiLCJjcmVhdGVIYXNoSHJlZiIsImJhc2UiLCJkb2N1bWVudCIsInF1ZXJ5U2VsZWN0b3IiLCJocmVmIiwiZ2V0QXR0cmlidXRlIiwidXJsIiwiaGFzaEluZGV4IiwiaW5kZXhPZiIsInNsaWNlIiwidmFsaWRhdGVIYXNoTG9jYXRpb24iLCJpbnZhcmlhbnQiLCJ2YWx1ZSIsIm1lc3NhZ2UiLCJFcnJvciIsImNvbmQiLCJjb25zb2xlIiwid2FybiIsImUiLCJjcmVhdGVLZXkiLCJyYW5kb20iLCJ0b1N0cmluZyIsImdldEhpc3RvcnlTdGF0ZSIsImlkeCIsImN1cnJlbnQiLCJfcmVmIiwicGFyc2VkUGF0aCIsInNlYXJjaEluZGV4IiwiZ2V0TG9jYXRpb24iLCJ2YWxpZGF0ZUxvY2F0aW9uIiwiZGVmYXVsdFZpZXciLCJnZXRJbmRleCIsInJlcGxhY2VTdGF0ZSIsImhhbmRsZVBvcCIsImhpc3RvcnlTdGF0ZSIsInB1c2hTdGF0ZSIsImVycm9yIiwiRE9NRXhjZXB0aW9uIiwibmFtZSIsIm9yaWdpbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiUmVzdWx0VHlwZSIsImltbXV0YWJsZVJvdXRlS2V5cyIsIlNldCIsImlzSW5kZXhSb3V0ZSIsInJvdXRlIiwiY29udmVydFJvdXRlc1RvRGF0YVJvdXRlcyIsInJvdXRlcyIsIm1hcFJvdXRlUHJvcGVydGllcyIsInBhcmVudFBhdGgiLCJtYW5pZmVzdCIsInRyZWVQYXRoIiwiaWQiLCJqb2luIiwiY2hpbGRyZW4iLCJpbmRleFJvdXRlIiwicGF0aE9yTGF5b3V0Um91dGUiLCJtYXRjaFJvdXRlcyIsImxvY2F0aW9uQXJnIiwiYmFzZW5hbWUiLCJzdHJpcEJhc2VuYW1lIiwiYnJhbmNoZXMiLCJmbGF0dGVuUm91dGVzIiwicmFua1JvdXRlQnJhbmNoZXMiLCJtYXRjaGVzIiwibWF0Y2hSb3V0ZUJyYW5jaCIsInNhZmVseURlY29kZVVSSSIsImNvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoIiwibWF0Y2giLCJsb2FkZXJEYXRhIiwicGFyYW1zIiwiZGF0YSIsImhhbmRsZSIsInBhcmVudHNNZXRhIiwiZmxhdHRlblJvdXRlIiwicmVsYXRpdmVQYXRoIiwibWV0YSIsImNhc2VTZW5zaXRpdmUiLCJjaGlsZHJlbkluZGV4Iiwiam9pblBhdGhzIiwicm91dGVzTWV0YSIsImNvbmNhdCIsInNjb3JlIiwiY29tcHV0ZVNjb3JlIiwiZm9yRWFjaCIsIl9yb3V0ZSRwYXRoIiwiaW5jbHVkZXMiLCJleHBsb2RlZCIsImV4cGxvZGVPcHRpb25hbFNlZ21lbnRzIiwic2VnbWVudHMiLCJzcGxpdCIsImZpcnN0IiwicmVzdCIsImlzT3B0aW9uYWwiLCJlbmRzV2l0aCIsInJlcXVpcmVkIiwicmVzdEV4cGxvZGVkIiwicmVzdWx0Iiwic3VicGF0aCIsInNvcnQiLCJhIiwiYiIsImNvbXBhcmVJbmRleGVzIiwicGFyYW1SZSIsImR5bmFtaWNTZWdtZW50VmFsdWUiLCJpbmRleFJvdXRlVmFsdWUiLCJlbXB0eVNlZ21lbnRWYWx1ZSIsInN0YXRpY1NlZ21lbnRWYWx1ZSIsInNwbGF0UGVuYWx0eSIsImlzU3BsYXQiLCJzIiwiaW5pdGlhbFNjb3JlIiwic29tZSIsImZpbHRlciIsInJlZHVjZSIsInNlZ21lbnQiLCJ0ZXN0Iiwic2libGluZ3MiLCJldmVyeSIsImJyYW5jaCIsIm1hdGNoZWRQYXJhbXMiLCJtYXRjaGVkUGF0aG5hbWUiLCJlbmQiLCJyZW1haW5pbmdQYXRobmFtZSIsIm1hdGNoUGF0aCIsInBhdGhuYW1lQmFzZSIsIm5vcm1hbGl6ZVBhdGhuYW1lIiwiZ2VuZXJhdGVQYXRoIiwib3JpZ2luYWxQYXRoIiwicHJlZml4IiwicCIsIlN0cmluZyIsImFycmF5IiwiaXNMYXN0U2VnbWVudCIsInN0YXIiLCJrZXlNYXRjaCIsIm9wdGlvbmFsIiwicGFyYW0iLCJwYXR0ZXJuIiwibWF0Y2hlciIsImNvbXBpbGVkUGFyYW1zIiwiY29tcGlsZVBhdGgiLCJjYXB0dXJlR3JvdXBzIiwibWVtbyIsInBhcmFtTmFtZSIsInNwbGF0VmFsdWUiLCJzYWZlbHlEZWNvZGVVUklDb21wb25lbnQiLCJyZWdleHBTb3VyY2UiLCJfIiwiUmVnRXhwIiwiZGVjb2RlVVJJIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwidG9Mb3dlckNhc2UiLCJzdGFydEluZGV4IiwibmV4dENoYXIiLCJyZXNvbHZlUGF0aCIsImZyb21QYXRobmFtZSIsInRvUGF0aG5hbWUiLCJyZXNvbHZlUGF0aG5hbWUiLCJub3JtYWxpemVTZWFyY2giLCJub3JtYWxpemVIYXNoIiwicmVsYXRpdmVTZWdtZW50cyIsInBvcCIsImdldEludmFsaWRQYXRoRXJyb3IiLCJjaGFyIiwiZmllbGQiLCJkZXN0IiwiZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMiLCJyZXNvbHZlVG8iLCJ0b0FyZyIsInJvdXRlUGF0aG5hbWVzIiwibG9jYXRpb25QYXRobmFtZSIsImlzUGF0aFJlbGF0aXZlIiwiaXNFbXB0eVBhdGgiLCJmcm9tIiwiZnJvbVNlZ21lbnRzIiwidG9TZWdtZW50cyIsInNoaWZ0Iiwicm91dGVQYXRobmFtZUluZGV4IiwiaGFzRXhwbGljaXRUcmFpbGluZ1NsYXNoIiwiaGFzQ3VycmVudFRyYWlsaW5nU2xhc2giLCJnZXRUb1BhdGhuYW1lIiwicGF0aHMiLCJqc29uIiwiaW5pdCIsInJlc3BvbnNlSW5pdCIsInN0YXR1cyIsImhlYWRlcnMiLCJIZWFkZXJzIiwiaGFzIiwic2V0IiwiUmVzcG9uc2UiLCJBYm9ydGVkRGVmZXJyZWRFcnJvciIsIkRlZmVycmVkRGF0YSIsImNvbnN0cnVjdG9yIiwicGVuZGluZ0tleXNTZXQiLCJzdWJzY3JpYmVycyIsImRlZmVycmVkS2V5cyIsIkFycmF5IiwiaXNBcnJheSIsInJlamVjdCIsImFib3J0UHJvbWlzZSIsIlByb21pc2UiLCJyIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsIm9uQWJvcnQiLCJ1bmxpc3RlbkFib3J0U2lnbmFsIiwic2lnbmFsIiwiYWNjIiwiX3JlZjIiLCJ0cmFja1Byb21pc2UiLCJkb25lIiwiYWRkIiwicHJvbWlzZSIsInJhY2UiLCJ0aGVuIiwib25TZXR0bGUiLCJjYXRjaCIsImRlZmluZVByb3BlcnR5IiwiZ2V0IiwiYWJvcnRlZCIsImRlbGV0ZSIsInVuZGVmaW5lZEVycm9yIiwiZW1pdCIsInNldHRsZWRLZXkiLCJzdWJzY3JpYmVyIiwic3Vic2NyaWJlIiwiY2FuY2VsIiwiYWJvcnQiLCJ2IiwiayIsInJlc29sdmVEYXRhIiwicmVzb2x2ZSIsInNpemUiLCJ1bndyYXBwZWREYXRhIiwiX3JlZjMiLCJ1bndyYXBUcmFja2VkUHJvbWlzZSIsInBlbmRpbmdLZXlzIiwiaXNUcmFja2VkUHJvbWlzZSIsIl90cmFja2VkIiwiX2Vycm9yIiwiX2RhdGEiLCJkZWZlciIsInJlZGlyZWN0IiwicmVkaXJlY3REb2N1bWVudCIsInJlc3BvbnNlIiwiRXJyb3JSZXNwb25zZUltcGwiLCJzdGF0dXNUZXh0IiwiaW50ZXJuYWwiLCJpc1JvdXRlRXJyb3JSZXNwb25zZSIsInZhbGlkTXV0YXRpb25NZXRob2RzQXJyIiwidmFsaWRNdXRhdGlvbk1ldGhvZHMiLCJ2YWxpZFJlcXVlc3RNZXRob2RzQXJyIiwidmFsaWRSZXF1ZXN0TWV0aG9kcyIsInJlZGlyZWN0U3RhdHVzQ29kZXMiLCJyZWRpcmVjdFByZXNlcnZlTWV0aG9kU3RhdHVzQ29kZXMiLCJJRExFX05BVklHQVRJT04iLCJmb3JtTWV0aG9kIiwiZm9ybUFjdGlvbiIsImZvcm1FbmNUeXBlIiwiZm9ybURhdGEiLCJ0ZXh0IiwiSURMRV9GRVRDSEVSIiwiSURMRV9CTE9DS0VSIiwicHJvY2VlZCIsInJlc2V0IiwiQUJTT0xVVEVfVVJMX1JFR0VYIiwiZGVmYXVsdE1hcFJvdXRlUHJvcGVydGllcyIsImhhc0Vycm9yQm91bmRhcnkiLCJCb29sZWFuIiwiVFJBTlNJVElPTlNfU1RPUkFHRV9LRVkiLCJjcmVhdGVSb3V0ZXIiLCJyb3V0ZXJXaW5kb3ciLCJpc0Jyb3dzZXIiLCJjcmVhdGVFbGVtZW50IiwiaXNTZXJ2ZXIiLCJkZXRlY3RFcnJvckJvdW5kYXJ5IiwiZGF0YVJvdXRlcyIsImluRmxpZ2h0RGF0YVJvdXRlcyIsImZ1dHVyZSIsInY3X2ZldGNoZXJQZXJzaXN0Iiwidjdfbm9ybWFsaXplRm9ybU1ldGhvZCIsInY3X3ByZXBlbmRCYXNlbmFtZSIsInVubGlzdGVuSGlzdG9yeSIsInNhdmVkU2Nyb2xsUG9zaXRpb25zIiwiZ2V0U2Nyb2xsUmVzdG9yYXRpb25LZXkiLCJnZXRTY3JvbGxQb3NpdGlvbiIsImluaXRpYWxTY3JvbGxSZXN0b3JlZCIsImh5ZHJhdGlvbkRhdGEiLCJpbml0aWFsTWF0Y2hlcyIsImluaXRpYWxFcnJvcnMiLCJnZXRJbnRlcm5hbFJvdXRlckVycm9yIiwiZ2V0U2hvcnRDaXJjdWl0TWF0Y2hlcyIsImluaXRpYWxpemVkIiwibSIsImxhenkiLCJsb2FkZXIiLCJyb3V0ZXIiLCJoaXN0b3J5QWN0aW9uIiwibmF2aWdhdGlvbiIsInJlc3RvcmVTY3JvbGxQb3NpdGlvbiIsInByZXZlbnRTY3JvbGxSZXNldCIsInJldmFsaWRhdGlvbiIsImFjdGlvbkRhdGEiLCJlcnJvcnMiLCJmZXRjaGVycyIsIk1hcCIsImJsb2NrZXJzIiwicGVuZGluZ0FjdGlvbiIsInBlbmRpbmdQcmV2ZW50U2Nyb2xsUmVzZXQiLCJwZW5kaW5nTmF2aWdhdGlvbkNvbnRyb2xsZXIiLCJwZW5kaW5nVmlld1RyYW5zaXRpb25FbmFibGVkIiwiYXBwbGllZFZpZXdUcmFuc2l0aW9ucyIsInJlbW92ZVBhZ2VIaWRlRXZlbnRMaXN0ZW5lciIsImlzVW5pbnRlcnJ1cHRlZFJldmFsaWRhdGlvbiIsImlzUmV2YWxpZGF0aW9uUmVxdWlyZWQiLCJjYW5jZWxsZWREZWZlcnJlZFJvdXRlcyIsImNhbmNlbGxlZEZldGNoZXJMb2FkcyIsImZldGNoQ29udHJvbGxlcnMiLCJpbmNyZW1lbnRpbmdMb2FkSWQiLCJwZW5kaW5nTmF2aWdhdGlvbkxvYWRJZCIsImZldGNoUmVsb2FkSWRzIiwiZmV0Y2hSZWRpcmVjdElkcyIsImZldGNoTG9hZE1hdGNoZXMiLCJhY3RpdmVGZXRjaGVycyIsImRlbGV0ZWRGZXRjaGVycyIsImFjdGl2ZURlZmVycmVkcyIsImJsb2NrZXJGdW5jdGlvbnMiLCJpZ25vcmVOZXh0SGlzdG9yeVVwZGF0ZSIsImluaXRpYWxpemUiLCJibG9ja2VyS2V5Iiwic2hvdWxkQmxvY2tOYXZpZ2F0aW9uIiwiY3VycmVudExvY2F0aW9uIiwidXBkYXRlQmxvY2tlciIsInVwZGF0ZVN0YXRlIiwic3RhcnROYXZpZ2F0aW9uIiwicmVzdG9yZUFwcGxpZWRUcmFuc2l0aW9ucyIsIl9zYXZlQXBwbGllZFRyYW5zaXRpb25zIiwicGVyc2lzdEFwcGxpZWRUcmFuc2l0aW9ucyIsImRpc3Bvc2UiLCJjbGVhciIsImRlbGV0ZUZldGNoZXIiLCJkZWxldGVCbG9ja2VyIiwibmV3U3RhdGUiLCJvcHRzIiwiY29tcGxldGVkRmV0Y2hlcnMiLCJkZWxldGVkRmV0Y2hlcnNLZXlzIiwiZmV0Y2hlciIsInVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uT3B0cyIsInZpZXdUcmFuc2l0aW9uT3B0cyIsInVuc3RhYmxlX2ZsdXNoU3luYyIsImZsdXNoU3luYyIsImNvbXBsZXRlTmF2aWdhdGlvbiIsIl90ZW1wIiwiX2xvY2F0aW9uJHN0YXRlIiwiX2xvY2F0aW9uJHN0YXRlMiIsImlzQWN0aW9uUmVsb2FkIiwiaXNNdXRhdGlvbk1ldGhvZCIsIl9pc1JlZGlyZWN0Iiwia2V5cyIsIm1lcmdlTG9hZGVyRGF0YSIsInByaW9yUGF0aHMiLCJ0b1BhdGhzIiwiZ2V0U2F2ZWRTY3JvbGxQb3NpdGlvbiIsIm5hdmlnYXRlIiwibm9ybWFsaXplZFBhdGgiLCJub3JtYWxpemVUbyIsImZyb21Sb3V0ZUlkIiwicmVsYXRpdmUiLCJzdWJtaXNzaW9uIiwibm9ybWFsaXplTmF2aWdhdGVPcHRpb25zIiwidXNlclJlcGxhY2UiLCJwZW5kaW5nRXJyb3IiLCJlbmFibGVWaWV3VHJhbnNpdGlvbiIsInVuc3RhYmxlX3ZpZXdUcmFuc2l0aW9uIiwicmV2YWxpZGF0ZSIsImludGVycnVwdEFjdGl2ZUxvYWRzIiwic3RhcnRVbmludGVycnVwdGVkUmV2YWxpZGF0aW9uIiwib3ZlcnJpZGVOYXZpZ2F0aW9uIiwic2F2ZVNjcm9sbFBvc2l0aW9uIiwicm91dGVzVG9Vc2UiLCJsb2FkaW5nTmF2aWdhdGlvbiIsIm5vdEZvdW5kTWF0Y2hlcyIsImNhbmNlbEFjdGl2ZURlZmVycmVkcyIsImlzSGFzaENoYW5nZU9ubHkiLCJyZXF1ZXN0IiwiY3JlYXRlQ2xpZW50U2lkZVJlcXVlc3QiLCJwZW5kaW5nQWN0aW9uRGF0YSIsImZpbmROZWFyZXN0Qm91bmRhcnkiLCJhY3Rpb25PdXRwdXQiLCJoYW5kbGVBY3Rpb24iLCJzaG9ydENpcmN1aXRlZCIsInBlbmRpbmdBY3Rpb25FcnJvciIsImdldExvYWRpbmdOYXZpZ2F0aW9uIiwiUmVxdWVzdCIsImhhbmRsZUxvYWRlcnMiLCJmZXRjaGVyU3VibWlzc2lvbiIsImdldFN1Ym1pdHRpbmdOYXZpZ2F0aW9uIiwiYWN0aW9uTWF0Y2giLCJnZXRUYXJnZXRNYXRjaCIsInR5cGUiLCJtZXRob2QiLCJyb3V0ZUlkIiwiY2FsbExvYWRlck9yQWN0aW9uIiwiaXNSZWRpcmVjdFJlc3VsdCIsInN0YXJ0UmVkaXJlY3ROYXZpZ2F0aW9uIiwiaXNFcnJvclJlc3VsdCIsImJvdW5kYXJ5TWF0Y2giLCJpc0RlZmVycmVkUmVzdWx0IiwiYWN0aXZlU3VibWlzc2lvbiIsImdldFN1Ym1pc3Npb25Gcm9tTmF2aWdhdGlvbiIsIm1hdGNoZXNUb0xvYWQiLCJyZXZhbGlkYXRpbmdGZXRjaGVycyIsImdldE1hdGNoZXNUb0xvYWQiLCJ1cGRhdGVkRmV0Y2hlcnMiLCJtYXJrRmV0Y2hSZWRpcmVjdHNEb25lIiwicmYiLCJyZXZhbGlkYXRpbmdGZXRjaGVyIiwiZ2V0TG9hZGluZ0ZldGNoZXIiLCJhYm9ydEZldGNoZXIiLCJhYm9ydFBlbmRpbmdGZXRjaFJldmFsaWRhdGlvbnMiLCJmIiwicmVzdWx0cyIsImxvYWRlclJlc3VsdHMiLCJmZXRjaGVyUmVzdWx0cyIsImNhbGxMb2FkZXJzQW5kTWF5YmVSZXNvbHZlRGF0YSIsImZpbmRSZWRpcmVjdCIsImZldGNoZXJLZXkiLCJwcm9jZXNzTG9hZGVyRGF0YSIsImRlZmVycmVkRGF0YSIsImRpZEFib3J0RmV0Y2hMb2FkcyIsImFib3J0U3RhbGVGZXRjaExvYWRzIiwic2hvdWxkVXBkYXRlRmV0Y2hlcnMiLCJmZXRjaCIsInNldEZldGNoZXJFcnJvciIsImhhbmRsZUZldGNoZXJBY3Rpb24iLCJoYW5kbGVGZXRjaGVyTG9hZGVyIiwicmVxdWVzdE1hdGNoZXMiLCJleGlzdGluZ0ZldGNoZXIiLCJ1cGRhdGVGZXRjaGVyU3RhdGUiLCJnZXRTdWJtaXR0aW5nRmV0Y2hlciIsImFib3J0Q29udHJvbGxlciIsImZldGNoUmVxdWVzdCIsIm9yaWdpbmF0aW5nTG9hZElkIiwiYWN0aW9uUmVzdWx0IiwiZ2V0RG9uZUZldGNoZXIiLCJyZXZhbGlkYXRpb25SZXF1ZXN0IiwibG9hZElkIiwibG9hZEZldGNoZXIiLCJzdGFsZUtleSIsImRvbmVGZXRjaGVyIiwicmVzb2x2ZURlZmVycmVkRGF0YSIsIl90ZW1wMiIsInJlZGlyZWN0TG9jYXRpb24iLCJpc0RvY3VtZW50UmVsb2FkIiwicmVsb2FkRG9jdW1lbnQiLCJyZWRpcmVjdEhpc3RvcnlBY3Rpb24iLCJjdXJyZW50TWF0Y2hlcyIsImZldGNoZXJzVG9Mb2FkIiwiYWxsIiwicmVzb2x2ZURlZmVycmVkUmVzdWx0cyIsImdldEZldGNoZXIiLCJkZWxldGVGZXRjaGVyQW5kVXBkYXRlU3RhdGUiLCJjb3VudCIsIm1hcmtGZXRjaGVyc0RvbmUiLCJkb25lS2V5cyIsImxhbmRlZElkIiwieWVldGVkS2V5cyIsImdldEJsb2NrZXIiLCJibG9ja2VyIiwibmV3QmxvY2tlciIsImJsb2NrZXJGdW5jdGlvbiIsInByZWRpY2F0ZSIsImNhbmNlbGxlZFJvdXRlSWRzIiwiZGZkIiwiZW5hYmxlU2Nyb2xsUmVzdG9yYXRpb24iLCJwb3NpdGlvbnMiLCJnZXRQb3NpdGlvbiIsImdldEtleSIsInkiLCJnZXRTY3JvbGxLZXkiLCJfaW50ZXJuYWxTZXRSb3V0ZXMiLCJuZXdSb3V0ZXMiLCJfaW50ZXJuYWxGZXRjaENvbnRyb2xsZXJzIiwiX2ludGVybmFsQWN0aXZlRGVmZXJyZWRzIiwiVU5TQUZFX0RFRkVSUkVEX1NZTUJPTCIsIlN5bWJvbCIsImNyZWF0ZVN0YXRpY0hhbmRsZXIiLCJxdWVyeSIsIl90ZW1wMyIsInJlcXVlc3RDb250ZXh0IiwiaXNWYWxpZE1ldGhvZCIsIm1ldGhvZE5vdEFsbG93ZWRNYXRjaGVzIiwic3RhdHVzQ29kZSIsImxvYWRlckhlYWRlcnMiLCJhY3Rpb25IZWFkZXJzIiwicXVlcnlJbXBsIiwiaXNSZXNwb25zZSIsInF1ZXJ5Um91dGUiLCJfdGVtcDQiLCJmaW5kIiwidmFsdWVzIiwiX3Jlc3VsdCRhY3RpdmVEZWZlcnJlIiwicm91dGVNYXRjaCIsInN1Ym1pdCIsImxvYWRSb3V0ZURhdGEiLCJpc1F1ZXJ5Um91dGVSZXNwb25zZSIsImlzUmVkaXJlY3RSZXNwb25zZSIsImlzUm91dGVSZXF1ZXN0IiwiaXNTdGF0aWNSZXF1ZXN0IiwiTG9jYXRpb24iLCJjb250ZXh0IiwibG9hZGVyUmVxdWVzdCIsImdldExvYWRlck1hdGNoZXNVbnRpbEJvdW5kYXJ5IiwicHJvY2Vzc1JvdXRlTG9hZGVyRGF0YSIsImV4ZWN1dGVkTG9hZGVycyIsImZyb21FbnRyaWVzIiwiZ2V0U3RhdGljQ29udGV4dEZyb21FcnJvciIsIm5ld0NvbnRleHQiLCJfZGVlcGVzdFJlbmRlcmVkQm91bmRhcnlJZCIsImlzU3VibWlzc2lvbk5hdmlnYXRpb24iLCJib2R5IiwicHJlcGVuZEJhc2VuYW1lIiwiY29udGV4dHVhbE1hdGNoZXMiLCJhY3RpdmVSb3V0ZU1hdGNoIiwiaGFzTmFrZWRJbmRleFF1ZXJ5Iiwibm9ybWFsaXplRm9ybU1ldGhvZCIsImlzRmV0Y2hlciIsImdldEludmFsaWRCb2R5RXJyb3IiLCJyYXdGb3JtTWV0aG9kIiwidG9VcHBlckNhc2UiLCJzdHJpcEhhc2hGcm9tUGF0aCIsIkZvcm1EYXRhIiwiVVJMU2VhcmNoUGFyYW1zIiwicGFyc2UiLCJzZWFyY2hQYXJhbXMiLCJjb252ZXJ0Rm9ybURhdGFUb1NlYXJjaFBhcmFtcyIsImNvbnZlcnRTZWFyY2hQYXJhbXNUb0Zvcm1EYXRhIiwiYXBwZW5kIiwiYm91bmRhcnlJZCIsImJvdW5kYXJ5TWF0Y2hlcyIsImZpbmRJbmRleCIsImN1cnJlbnRVcmwiLCJuZXh0VXJsIiwibmF2aWdhdGlvbk1hdGNoZXMiLCJpc05ld0xvYWRlciIsImN1cnJlbnRSb3V0ZU1hdGNoIiwibmV4dFJvdXRlTWF0Y2giLCJzaG91bGRSZXZhbGlkYXRlTG9hZGVyIiwiY3VycmVudFBhcmFtcyIsIm5leHRQYXJhbXMiLCJkZWZhdWx0U2hvdWxkUmV2YWxpZGF0ZSIsImlzTmV3Um91dGVJbnN0YW5jZSIsImZldGNoZXJNYXRjaGVzIiwiZmV0Y2hlck1hdGNoIiwic2hvdWxkUmV2YWxpZGF0ZSIsImN1cnJlbnRMb2FkZXJEYXRhIiwiY3VycmVudE1hdGNoIiwiaXNOZXciLCJpc01pc3NpbmdEYXRhIiwiY3VycmVudFBhdGgiLCJsb2FkZXJNYXRjaCIsImFyZyIsInJvdXRlQ2hvaWNlIiwibG9hZExhenlSb3V0ZU1vZHVsZSIsImxhenlSb3V0ZSIsInJvdXRlVG9VcGRhdGUiLCJyb3V0ZVVwZGF0ZXMiLCJsYXp5Um91dGVQcm9wZXJ0eSIsInN0YXRpY1JvdXRlVmFsdWUiLCJpc1Byb3BlcnR5U3RhdGljYWxseURlZmluZWQiLCJyZXN1bHRUeXBlIiwib25SZWplY3QiLCJydW5IYW5kbGVyIiwiaGFuZGxlciIsImhhbmRsZXJFcnJvciIsInByb3RvY29sIiwiaXNTYW1lQmFzZW5hbWUiLCJxdWVyeVJvdXRlUmVzcG9uc2UiLCJjb250ZW50VHlwZSIsImlzRGVmZXJyZWREYXRhIiwiX3Jlc3VsdCRpbml0IiwiX3Jlc3VsdCRpbml0MiIsImRlZmVycmVkIiwiZm91bmRFcnJvciIsIm5ld0xvYWRlckRhdGEiLCJtZXJnZWRMb2FkZXJEYXRhIiwiZWxpZ2libGVNYXRjaGVzIiwicmV2ZXJzZSIsIl90ZW1wNSIsImVycm9yTWVzc2FnZSIsIm9iaiIsInNpZ25hbHMiLCJpc1JldmFsaWRhdGluZ0xvYWRlciIsInVud3JhcCIsImdldEFsbCIsInBhdGhNYXRjaGVzIiwiX3dpbmRvdyIsInRyYW5zaXRpb25zIiwic2Vzc2lvblBvc2l0aW9ucyIsInNlc3Npb25TdG9yYWdlIiwiZ2V0SXRlbSIsInNldEl0ZW0iLCJVTlNBRkVfRGVmZXJyZWREYXRhIiwiVU5TQUZFX0Vycm9yUmVzcG9uc2VJbXBsIiwiVU5TQUZFX2NvbnZlcnRSb3V0ZU1hdGNoVG9VaU1hdGNoIiwiVU5TQUZFX2NvbnZlcnRSb3V0ZXNUb0RhdGFSb3V0ZXMiLCJVTlNBRkVfZ2V0UGF0aENvbnRyaWJ1dGluZ01hdGNoZXMiLCJVTlNBRkVfaW52YXJpYW50IiwiVU5TQUZFX3dhcm5pbmciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@remix-run/router/dist/router.js\n");

/***/ })

};
;